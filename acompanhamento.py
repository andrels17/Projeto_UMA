import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, date, timedelta
import os
import plotly.express as px
import hashlib
import json
import base64
import io
# Configura√ß√£o da p√°gina (deve ser o primeiro comando Streamlit)
st.set_page_config(
    page_title="Dashboard de Frotas - A√ß√∫car Alegre",
    page_icon="üöú",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/projeto-uma',
        'Report a bug': "https://github.com/seu-usuario/projeto-uma/issues",
        'About': "# Dashboard de Frotas\n\nSistema de gest√£o de frotas da A√ß√∫car Alegre\n\nDesenvolvido por Andr√© Luis"
    }
)

# Configura√ß√£o de tema
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark'

# CSS personalizado para tema claro/escuro
def get_theme_css():
    if st.session_state.theme == 'dark':
        return """
        <style>
        .stApp {
            background-color: #0e1117;
            color: #fafafa;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """
    else:
        return """
        <style>
        .stApp {
            background-color: #ffffff;
            color: #262730;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """

# Aplicar CSS do tema
st.markdown(get_theme_css(), unsafe_allow_html=True)

# Fun√ß√£o para alternar tema
def toggle_theme():
    st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
    st.rerun()

# Fun√ß√£o para exportar dados
def export_dataframe(df, filename, file_type='csv'):
    """Exporta DataFrame em diferentes formatos"""
    if file_type == 'csv':
        csv = df.to_csv(index=False, sep=';', decimal=',', encoding='utf-8-sig')
        st.download_button(
            label=f"üì• Download {filename}.csv",
            data=csv,
            file_name=f"{filename}.csv",
            mime="text/csv",
            help=f"Baixar {filename} em formato CSV"
        )
    elif file_type == 'excel':
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        buffer.seek(0)
        st.download_button(
            label=f"üì• Download {filename}.xlsx",
            data=buffer,
            file_name=f"{filename}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help=f"Baixar {filename} em formato Excel"
        )

# Fun√ß√£o para mostrar loading
def show_loading(message="Carregando dados..."):
    """Mostra indicador de carregamento"""
    with st.spinner(message):
        st.info(f"‚è≥ {message}")
        return True

# Fun√ß√£o para tooltip informativo
def info_tooltip(text, help_text):
    """Cria um elemento com tooltip informativo"""
    col1, col2 = st.columns([20, 1])
    with col1:
        st.write(text)
    with col2:
        st.info("‚ÑπÔ∏è", help=help_text)

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "frotas_data.db")

ALERTAS_MANUTENCAO = {
    'HORAS': { 'default': 20 },
    'QUIL√îMETROS': { 'default': 500 }
}

def formatar_brasileiro(valor: float, prefixo='') -> str:
    """Formata um n√∫mero com casas decimais para o padr√£o brasileiro."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{prefixo}{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

@st.cache_data(ttl=300)
def para_csv(df: pd.DataFrame):
    """Converte um DataFrame para CSV para download."""
    return df.to_csv(index=False, sep=';', decimal=',').encode('utf-8-sig')

def formatar_brasileiro_int(valor: float) -> str:
    """Formata um n√∫mero inteiro para o padr√£o brasileiro (ex: 123.456)."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{int(valor):,}".replace(",", ".")

def detect_equipment_type(df_completo: pd.DataFrame) -> pd.DataFrame:
    df = df_completo.copy()
    df['Tipo_Controle'] = df.get('Unid', pd.Series(index=df.index)).map({'HORAS': 'HORAS', 'QUIL√îMETROS': 'QUIL√îMETROS'})
    def inferir_tipo_por_classe(row):
        if pd.notna(row['Tipo_Controle']): return row['Tipo_Controle']
        classe = str(row.get('Classe_Operacional', '')).upper()
        if any(p in classe for p in ['TRATOR', 'COLHEITADEIRA', 'PULVERIZADOR', 'PLANTADEIRA', 'P√Å CARREGADEIRA', 'RETROESCAVADEIRA']): return 'HORAS'
        if any(p in classe for p in ['CAMINH√ÉO', 'CAMINHAO', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']): return 'QUIL√îMETROS'
        return 'HORAS'
    df['Tipo_Controle'] = df.apply(inferir_tipo_por_classe, axis=1)
    return df

def hash_password(password):
    """Gera um hash seguro da palavra-passe."""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login_db(username, password):
    """Verifica as credenciais contra a base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash, role FROM utilizadores WHERE username = ?", (username,))
        result = cursor.fetchone()
        conn.close()
        if result:
            password_hash_db, role = result
            if password_hash_db == hash_password(password):
                return role
        return None
    except Exception as e:
        st.error(f"Erro ao aceder √† base de dados de utilizadores: {e}")
        return None

def get_all_users():
    """Busca todos os utilizadores da base de dados."""
    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
        return pd.read_sql_query("SELECT id, username, role FROM utilizadores", conn)

def add_user(username, password, role):
    """Adiciona um novo utilizador √† base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO utilizadores (username, password_hash, role) VALUES (?, ?, ?)",
            (username, hash_password(password), role)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador adicionado com sucesso!"
    except sqlite3.IntegrityError:
        return False, f"Erro: O nome de utilizador '{username}' j√° existe."
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def update_user(user_id, new_username, new_role):
    """Atualiza o nome e a fun√ß√£o de um utilizador."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE utilizadores SET username = ?, role = ? WHERE id = ?",
            (new_username, new_role, user_id)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador atualizado com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def delete_user(user_id):
    """Remove um utilizador da base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM utilizadores WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        return True, "Utilizador removido com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

    
# APAGUE A SUA FUN√á√ÉO "load_data_from_db" INTEIRA E SUBSTITUA-A POR ESTE BLOCO FINAL

@st.cache_data(show_spinner="Carregando e processando dados...", ttl=300)
def load_data_from_db(db_path: str, ver_frotas: int=None, ver_abast: int=None, ver_manut: int=None, ver_comp: int=None, ver_chk: int=None):
    if not os.path.exists(db_path):
        st.error(f"Arquivo de banco de dados '{db_path}' n√£o encontrado.")
        st.stop()

    try:
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            df_abast = pd.read_sql_query("SELECT rowid, * FROM abastecimentos", conn)
            df_frotas = pd.read_sql_query("SELECT * FROM frotas", conn)
            df_manutencoes = pd.read_sql_query("SELECT rowid, * FROM manutencoes", conn)
            df_comp_regras = pd.read_sql_query("SELECT * FROM componentes_regras", conn)
            df_comp_historico = pd.read_sql_query("SELECT rowid, * FROM componentes_historico", conn)
            df_checklist_regras = pd.read_sql_query("SELECT * FROM checklist_regras", conn)
            df_checklist_itens = pd.read_sql_query("SELECT * FROM checklist_itens", conn)
            df_checklist_historico = pd.read_sql_query("SELECT rowid, * FROM checklist_historico", conn)

        # --- In√≠cio do Processamento Integrado ---
        
        # Renomeia colunas para um padr√£o consistente
        df_abast = df_abast.rename(columns={"C√≥d. Equip.": "Cod_Equip", "Qtde Litros": "Qtde Litros", "M√™s": "Mes", "M√©dia": "Media"}, errors='ignore')
        df_frotas = df_frotas.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip", "Classe Operacional": "Classe_Operacional"}, errors='ignore')

        # Cria o dataframe principal mesclando abastecimentos e frotas
        df_merged = pd.merge(df_abast, df_frotas, on="Cod_Equip", how="left")
        
        # Trata colunas de classe operacional que podem ter vindo da mesclagem
        if 'Classe_Operacional_x' in df_merged.columns:
            df_merged['Classe_Operacional'] = np.where(df_merged['Classe_Operacional_x'].notna(), df_merged['Classe_Operacional_x'], df_merged['Classe_Operacional_y'])
            df_merged.drop(columns=['Classe_Operacional_x', 'Classe_Operacional_y'], inplace=True)
        
        # Converte a coluna de data e cria colunas de tempo
        df_merged["Data"] = pd.to_datetime(df_merged["Data"], errors='coerce')
        df_merged.dropna(subset=["Data"], inplace=True)
        df_merged["Ano"] = df_merged["Data"].dt.year
        df_merged["AnoMes"] = df_merged["Data"].dt.to_period("M").astype(str)
        
        # Limpa e converte colunas num√©ricas
        for col in ["Qtde Litros", "Media", "Hod_Hor_Atual"]:
            if col in df_merged.columns:
                series = df_merged[col].astype(str)
                series = series.str.replace(',', '.', regex=False).str.replace('-', '', regex=False).str.strip()
                df_merged[col] = pd.to_numeric(series, errors='coerce')
        
        # Cria a coluna "label" no dataframe de frotas para uso em seletores
        df_frotas["label"] = df_frotas["Cod_Equip"].astype(str) + " - " + df_frotas.get("DESCRICAO_EQUIPAMENTO", "").fillna("") + " (" + df_frotas.get("PLACA", "").fillna("Sem Placa") + ")"

        # Vincula informa√ß√µes de motorista aos abastecimentos (merge durante o load)
        try:
            with sqlite3.connect(db_path, check_same_thread=False) as conn:
                df_motoristas = pd.read_sql_query("SELECT codigo_pessoa, matricula, nome FROM motoristas", conn)
            if not df_motoristas.empty:
                df_merged = df_merged.merge(
                    df_motoristas.rename(columns={"codigo_pessoa": "Cod_Pessoa", "matricula": "Matricula", "nome": "Nome_Motorista"}),
                    on=["Cod_Pessoa", "Matricula"], how="left"
                )
        except Exception:
            pass
        
        # Garante que a classe operacional em df_frotas est√° atualizada
        classe_map = df_merged.dropna(subset=['Classe_Operacional']).groupby('Cod_Equip')['Classe_Operacional'].first()
        df_frotas['Classe_Operacional'] = df_frotas['Cod_Equip'].map(classe_map).fillna(df_frotas.get('Classe_Operacional'))

        # Adiciona coluna de tipo de combust√≠vel se n√£o existir
        if 'tipo_combustivel' not in df_frotas.columns:
            df_frotas['tipo_combustivel'] = 'Diesel S500'  # Valor padr√£o
        else:
            # Se a coluna existe, apenas preencher valores nulos com padr√£o
            df_frotas['tipo_combustivel'] = df_frotas['tipo_combustivel'].fillna('Diesel S500')

        # Determina o tipo de controle (Horas ou Quil√¥metros) para cada equipamento
        def determinar_tipo_controle(row):
            texto_para_verificar = (
                str(row.get('DESCRICAO_EQUIPAMENTO', '')) + ' ' + 
                str(row.get('Classe_Operacional', ''))
            ).upper()
            km_keywords = ['CAMINH', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']
            if any(p in texto_para_verificar for p in km_keywords):
                return 'QUIL√îMETROS'
            return 'HORAS'
        df_frotas['Tipo_Controle'] = df_frotas.apply(determinar_tipo_controle, axis=1)

        # Retorna todos os dataframes processados
        return (
            df_merged, df_frotas, df_manutencoes,
            df_comp_regras, df_comp_historico,
            df_checklist_regras, df_checklist_itens, df_checklist_historico
        )

    except Exception as e:
        st.error(f"Erro ao ler e processar o banco de dados: {e}")
        st.stop()
        # Retorna dataframes vazios em caso de erro
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(),
                pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

                
    
def inserir_abastecimento(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO abastecimentos (
                "C√≥d. Equip.", Data, "Qtde Litros", Hod_Hor_Atual,
                Safra, "M√™s", "Classe Operacional", Matricula, Cod_Pessoa
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['data'],
            dados['qtde_litros'],
            dados['hod_hor_atual'],
            dados['safra'],
            dados['mes'],
            dados['classe_operacional'],
            dados.get('matricula'),
            dados.get('cod_pessoa')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao inserir dados no banco de dados: {e}")
        return False

def excluir_abastecimento(db_path: str, rowid: int) -> bool:
    """Exclui um registro de abastecimento do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        # Usar rowid √© a forma mais segura de deletar uma linha espec√≠fica
        sql = "DELETE FROM abastecimentos WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir dados do banco de dados: {e}")
        return False

def excluir_manutencao_componente(db_path: str, cod_equip: int, nome_componente: str, data: str, hod_hor: float) -> bool:
    """Exclui um registro de manuten√ß√£o de componente do banco de dados usando uma combina√ß√£o √∫nica de campos."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)
        nome_componente = str(nome_componente)
        data = str(data)
        hod_hor = float(hod_hor)
        
        # Debug: verificar todos os registros na tabela
        cursor.execute("SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico")
        all_records = cursor.fetchall()
        
        # Debug: verificar se h√° registros com valores similares
        cursor.execute(
            "SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico WHERE Cod_Equip = ?", 
            (cod_equip,)
        )
        similar_records = cursor.fetchall()
        
        # Primeiro, vamos verificar se o registro existe
        cursor.execute(
            "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        count = cursor.fetchone()[0]
        
        if count == 0:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - Nome Componente: {nome_componente} (tipo: {type(nome_componente)})
            - Data: {data} (tipo: {type(data)})
            - Hod_Hor: {hod_hor} (tipo: {type(hod_hor)})
            
            Registros similares encontrados (mesmo Cod_Equip):
            {similar_records}
            
            Todos os registros na tabela:
            {all_records}
            """
            st.error(debug_info)
            return False
        
        # Agora vamos excluir
        cursor.execute(
            "DELETE FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute(
                "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
                (cod_equip, nome_componente, data, hod_hor)
            )
            count_after = cursor.fetchone()[0]
            
            if count_after == 0:
                # For√ßar sincroniza√ß√£o do banco
                cursor.execute("PRAGMA wal_checkpoint(FULL)")
                cursor.execute("PRAGMA synchronous=FULL")
                conn.commit()
                
                # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                backup_success, backup_msg = save_backup_to_session_state()
                if backup_success:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Backup salvo: {backup_msg}")
                else:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Aviso: {backup_msg}")
                
                conn.close()
                return True
            else:
                st.error("Erro: Registro ainda existe ap√≥s exclus√£o")
                conn.close()
                return False
        else:
            st.error("Nenhum registro foi exclu√≠do")
            conn.close()
            return False
            
    except Exception as e:
        st.error(f"Erro ao excluir manuten√ß√£o de componente do banco de dados: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def excluir_manutencao(db_path: str, rowid: int) -> bool:
    """Exclui um registro de manuten√ß√£o do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = "DELETE FROM manutencoes WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir manuten√ß√£o do banco de dados: {e}")
        return False

def inserir_manutencao(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = 'INSERT INTO manutencoes (Cod_Equip, Data, Tipo_Servico, Hod_Hor_No_Servico) VALUES (?, ?, ?, ?)'
        params = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'])
        cursor.execute(sql, params)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False

def inserir_frota(db_path: str, dados: dict) -> bool:
    """Insere um novo registro de frota no banco de dados."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO frotas (
                COD_EQUIPAMENTO, DESCRICAO_EQUIPAMENTO, PLACA, 
                "Classe Operacional", ATIVO, tipo_combustivel
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['descricao'],
            dados['placa'],
            dados['classe_op'],
            dados['ativo'],
            dados.get('tipo_combustivel', 'Diesel S500')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False
    

def editar_abastecimento(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de abastecimento existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE abastecimentos SET
                "C√≥d. Equip." = ?, Data = ?, "Qtde Litros" = ?, Hod_Hor_Atual = ?, Safra = ?, Matricula = ?, Cod_Pessoa = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'], dados['data'], dados['qtde_litros'], dados['hod_hor_atual'], dados['safra'],
            dados.get('matricula'), dados.get('cod_pessoa'), rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar abastecimento: {e}")
        return False

def editar_manutencao(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de manuten√ß√£o existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE manutencoes SET
                Cod_Equip = ?, Data = ?, Tipo_Servico = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'], rowid)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar manuten√ß√£o: {e}")
        return False

def editar_manutencao_componente(db_path: str, rowid: int, dados: dict) -> bool:
    """Edita um registro de manuten√ß√£o de componente existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE componentes_historico 
            SET Cod_Equip = ?, nome_componente = ?, Observacoes = ?, Data = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'],
            dados['componente'],
            dados['acao'],
            dados['data'],
            dados['hod_hor_servico'],
            rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao editar manuten√ß√£o de componente no banco de dados: {e}")
        return False

def importar_abastecimentos_de_planilha(db_path: str, arquivo_carregado) -> tuple[int, int, str]:
    """L√™ uma planilha, verifica por duplicados, e insere os novos dados. Aceita opcionalmente as colunas Matricula e Cod_Pessoa."""
    try:
        df_novo = pd.read_excel(arquivo_carregado)
        
        mapa_colunas = {
            "C√≥d. Equip.": "C√≥d. Equip.",
            "Data": "Data",
            "Qtde Litros": "Qtde Litros",
            "Hod. Hor. Atual": "Hod_Hor_Atual",
            "Safra": "Safra",
            "M√™s": "M√™s",
            "Classe Operacional": "Classe Operacional",
            "Matricula": "Matricula",
            "Cod_Pessoa": "Cod_Pessoa",
        }
        df_novo = df_novo.rename(columns={k: v for k, v in mapa_colunas.items() if k in df_novo.columns})

        colunas_necessarias = ["C√≥d. Equip.", "Data", "Qtde Litros", "Hod_Hor_Atual", "Safra", "M√™s", "Classe Operacional"]
        colunas_opcionais = ["Matricula", "Cod_Pessoa"]
        colunas_faltando = [col for col in colunas_necessarias if col not in df_novo.columns]
        if colunas_faltando:
            return 0, 0, f"Erro: Colunas n√£o encontradas: {', '.join(colunas_faltando)}"
        conn = sqlite3.connect(db_path)
        df_existente = pd.read_sql_query("SELECT * FROM abastecimentos", conn)
        
        df_novo['Data'] = pd.to_datetime(df_novo['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')
        df_existente['Data'] = pd.to_datetime(df_existente['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')

        df_novo['chave_unica'] = df_novo['C√≥d. Equip.'].astype(str) + '_' + df_novo['Data'] + '_' + df_novo['Qtde Litros'].astype(str)
        df_existente['chave_unica'] = df_existente['C√≥d. Equip.'].astype(str) + '_' + df_existente['Data'] + '_' + df_existente['Qtde Litros'].astype(str)

        df_para_inserir = df_novo[~df_novo['chave_unica'].isin(df_existente['chave_unica'])]
        
        num_duplicados = len(df_novo) - len(df_para_inserir)

        if df_para_inserir.empty:
            return 0, num_duplicados, "Nenhum registo novo para importar. Todos os registos da planilha j√° existem na base de dados."

        colunas_insert = colunas_necessarias + [c for c in colunas_opcionais if c in df_para_inserir.columns]
        df_para_inserir_final = df_para_inserir[colunas_insert]
        registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
        
        cursor = conn.cursor()
        placeholders = ", ".join(["?"] * len(colunas_insert))
        sql = f"INSERT INTO abastecimentos ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
        cursor.executemany(sql, registros)
        
        conn.commit()
        num_inseridos = cursor.rowcount
        conn.close()
        
        mensagem_sucesso = f"{num_inseridos} registos novos foram importados com sucesso."
        if num_duplicados > 0:
            mensagem_sucesso += f" {num_duplicados} registos duplicados foram ignorados."
            
        return num_inseridos, num_duplicados, mensagem_sucesso

    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o: {e}"

def editar_frota(db_path: str, cod_equip: int, dados: dict) -> bool:
    """Atualiza um registro de frota existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE frotas SET
                DESCRICAO_EQUIPAMENTO = ?, PLACA = ?, "Classe Operacional" = ?, ATIVO = ?, tipo_combustivel = ?
            WHERE COD_EQUIPAMENTO = ?
        """
        valores = (dados['descricao'], dados['placa'], dados['classe_op'], dados['ativo'], dados.get('tipo_combustivel', 'Diesel S500'), cod_equip)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar frota: {e}")
        return False

# COLE ESTE BLOCO DE C√ìDIGO NO LOCAL INDICADO

def get_component_rules():
    """Busca todas as regras de componentes da base de dados."""
    with sqlite3.connect(DB_PATH) as conn:
        return pd.read_sql_query("SELECT * FROM componentes_regras", conn)

def add_component_rule(classe, componente, intervalo):
    """Adiciona uma nova regra de componente √† base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao) VALUES (?, ?, ?)",
                (classe, componente, intervalo)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def add_component_rule_advanced(classe, componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca", capacidade_litros=0.0):
    """Adiciona uma nova regra de componente com informa√ß√µes de lubrificante e tipo de manuten√ß√£o."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, tipo_manutencao, capacidade_litros) VALUES (?, ?, ?, ?, ?, ?)",
                (classe, componente, intervalo, lubrificante_id, tipo_manutencao, capacidade_litros)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def delete_component_rule(rule_id):
    """Remove uma regra de componente da base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM componentes_regras WHERE id_regra = ?", (rule_id,))
            conn.commit()
        return True, "Componente removido com sucesso."
    except Exception as e:
        return False, f"Erro ao remover componente: {e}"

def add_component_service(cod_equip, componente, data, hod_hor, obs):
    """Adiciona um novo registo de servi√ßo de componente ao hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, Observacoes) VALUES (?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def add_component_service_advanced(cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado=None, obs=""):
    """Adiciona um novo registo de servi√ßo de componente com informa√ß√µes detalhadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def get_component_status(cod_equip, componente):
    """Obt√©m o status atual de um componente espec√≠fico de um equipamento."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            # Buscar a √∫ltima manuten√ß√£o do componente
            query = """
            SELECT Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            ORDER BY Data DESC, Hod_Hor_No_Servico DESC
            LIMIT 1
            """
            df_ultima = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            
            # Buscar a regra do componente para obter o intervalo
            query_regra = """
            SELECT intervalo_padrao, lubrificante_id, tipo_manutencao
            FROM componentes_regras cr
            JOIN frotas f ON cr.classe_operacional = f."Classe Operacional"
            WHERE f.COD_EQUIPAMENTO = ? AND cr.nome_componente = ?
            """
            df_regra = pd.read_sql_query(query_regra, conn, params=(cod_equip, componente))
            
            # Buscar o hod√¥metro/hor√≠metro atual do equipamento
            query_hod = """
            SELECT Hod_Hor_Atual FROM abastecimentos 
            WHERE Cod_Equip = ? 
            ORDER BY Data DESC, Hod_Hor_Atual DESC 
            LIMIT 1
            """
            df_hod = pd.read_sql_query(query_hod, conn, params=(cod_equip,))
            
            return df_ultima, df_regra, df_hod
            
    except Exception as e:
        st.error(f"Erro ao obter status do componente: {e}")
        return None, None, None

def get_component_maintenance_count(cod_equip, componente):
    """Obt√©m o n√∫mero total de manuten√ß√µes realizadas em um componente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT COUNT(*) as total_manutencoes,
                   COUNT(CASE WHEN tipo_servico = 'Troca' THEN 1 END) as total_trocas,
                   COUNT(CASE WHEN tipo_servico = 'Remonta' THEN 1 END) as total_remontas
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            """
            df_count = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            return df_count.iloc[0] if not df_count.empty else {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}
            
    except Exception as e:
        st.error(f"Erro ao obter contagem de manuten√ß√µes: {e}")
        return {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}

def editar_manutencao_componente_advanced(DB_PATH, rowid, dados_editados):
    """Edita uma manuten√ß√£o de componente com informa√ß√µes avan√ßadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_historico 
                SET Cod_Equip = ?, nome_componente = ?, Data = ?, Hod_Hor_No_Servico = ?, 
                    Observacoes = ?, tipo_servico = ?, lubrificante_utilizado = ?
                WHERE rowid = ?
            """, (
                dados_editados['cod_equip'],
                dados_editados['componente'],
                dados_editados['data'],
                dados_editados['hod_hor_servico'],
                dados_editados['acao'],
                dados_editados['tipo_servico'],
                dados_editados['lubrificante_utilizado'],
                rowid
            ))
            conn.commit()
        return True, "Manuten√ß√£o de componente atualizada com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar manuten√ß√£o de componente: {e}"

def update_component_rule(rule_id, nome_componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca"):
    """Atualiza uma regra de componente existente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_regras 
                SET nome_componente = ?, intervalo_padrao = ?, lubrificante_id = ?, tipo_manutencao = ?
                WHERE id_regra = ?
            """, (nome_componente, intervalo, lubrificante_id, tipo_manutencao, rule_id))
            conn.commit()
        return True, f"Componente '{nome_componente}' atualizado com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar componente: {e}"

def get_frota_combustivel(cod_equip):
    """Obt√©m o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tipo_combustivel FROM frotas WHERE COD_EQUIPAMENTO = ?", (cod_equip,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        st.error(f"Erro ao obter tipo de combust√≠vel: {e}")
        return None

def update_frota_combustivel(cod_equip, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE COD_EQUIPAMENTO = ?", (tipo_combustivel, cod_equip))
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel: {e}"

def update_classe_combustivel(classe_operacional, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de todas as frotas de uma classe."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE \"Classe Operacional\" = ?", (tipo_combustivel, classe_operacional))
            rows_updated = cursor.rowcount
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel} em {rows_updated} frotas da classe {classe_operacional}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel da classe: {e}"

def add_tipo_combustivel_column():
    """Adiciona a coluna tipo_combustivel √† tabela frotas se ela n√£o existir."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            # Verificar se a coluna existe
            cursor.execute("PRAGMA table_info(frotas)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'tipo_combustivel' not in columns:
                cursor.execute("ALTER TABLE frotas ADD COLUMN tipo_combustivel TEXT DEFAULT 'Diesel S500'")
                conn.commit()
                return True, "Coluna tipo_combustivel adicionada com sucesso"
            else:
                return True, "Coluna tipo_combustivel j√° existe"
    except Exception as e:
        return False, f"Erro ao adicionar coluna tipo_combustivel: {e}"

def ensure_motoristas_schema():
    """Garante a exist√™ncia da tabela de motoristas e das colunas de v√≠nculo em abastecimentos."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS motoristas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    codigo_pessoa TEXT,
                    matricula TEXT UNIQUE,
                    nome TEXT,
                    ativo TEXT DEFAULT 'ATIVO'
                )
                """
            )
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_matricula ON motoristas(matricula)")
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_codigo_pessoa ON motoristas(codigo_pessoa)")

            cursor.execute("PRAGMA table_info(abastecimentos)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'Matricula' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Matricula TEXT")
            if 'Cod_Pessoa' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Cod_Pessoa TEXT")
            conn.commit()
        return True, "Esquema de motoristas verificado"
    except Exception as e:
        return False, f"Erro ao verificar esquema de motoristas: {e}"

def get_all_motoristas() -> pd.DataFrame:
    """Retorna o DataFrame de motoristas."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM motoristas", conn)
    except Exception:
        return pd.DataFrame(columns=['id', 'codigo_pessoa', 'matricula', 'nome', 'ativo'])

def importar_motoristas_de_planilha(db_path: str, arquivo_carregado):
    """Importa motoristas a partir de planilha Excel. Espera colunas: Matricula, Nome e opcional Cod_Pessoa/C√≥digo Pessoa."""
    try:
        df_mot = pd.read_excel(arquivo_carregado)
        df_mot.columns = [c.strip() for c in df_mot.columns]
        renomeios = {
            'Matr√≠cula': 'Matricula', 'matricula': 'Matricula', 'MATRICULA': 'Matricula',
            'Nome': 'Nome', 'nome': 'Nome', 'NOME': 'Nome',
            'Cod_Pessoa': 'Cod_Pessoa', 'C√≥digo Pessoa': 'Cod_Pessoa', 'codigo_pessoa': 'Cod_Pessoa', 'CODIGO_PESSOA': 'Cod_Pessoa'
        }
        df_mot.rename(columns={k: v for k, v in renomeios.items() if k in df_mot.columns}, inplace=True)
        obrig = ['Matricula', 'Nome']
        faltando = [c for c in obrig if c not in df_mot.columns]
        if faltando:
            return 0, 0, f"Erro: Colunas obrigat√≥rias n√£o encontradas: {', '.join(faltando)}"
        if 'Cod_Pessoa' not in df_mot.columns:
            df_mot['Cod_Pessoa'] = None
        df_mot = df_mot.dropna(subset=['Matricula', 'Nome']).copy()
        df_mot['Matricula'] = df_mot['Matricula'].astype(str).str.strip()
        df_mot['Nome'] = df_mot['Nome'].astype(str).str.strip()
        df_mot['Cod_Pessoa'] = df_mot['Cod_Pessoa'].astype(str).str.strip()
        df_mot = df_mot.drop_duplicates(subset=['Matricula'])
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            existentes = pd.read_sql_query("SELECT matricula FROM motoristas", conn)
            set_exist = set(existentes['matricula'].astype(str)) if not existentes.empty else set()
            df_novos = df_mot[~df_mot['Matricula'].isin(set_exist)].copy()
            if df_novos.empty:
                return 0, len(df_mot), "Nenhum motorista novo para importar. Todos j√° existem."
            registros = [
                (row.get('Cod_Pessoa', None), row['Matricula'], row['Nome'], 'ATIVO')
                for _, row in df_novos.iterrows()
            ]
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO motoristas (codigo_pessoa, matricula, nome, ativo) VALUES (?, ?, ?, ?)",
                registros
            )
            conn.commit()
            inseridos = cur.rowcount if cur.rowcount is not None else len(registros)
            duplicados = len(df_mot) - len(df_novos)
            return inseridos, duplicados, f"{inseridos} motoristas importados com sucesso. {duplicados} j√° existiam."
    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o de motoristas: {e}"
    
def ensure_pneus_schema():
    """Garante a exist√™ncia da tabela de hist√≥rico de pneus."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pneus_historico (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    Cod_Equip INTEGER,
                    posicao TEXT,
                    marca TEXT,
                    modelo TEXT,
                    numero_fogo TEXT,
                    data_instalacao TEXT,
                    hodometro_instalacao REAL,
                    
                    observacoes TEXT,
                    status TEXT DEFAULT 'Ativo',
                    vida_atual INTEGER DEFAULT 1
                )
            """)
            # Adiciona colunas se n√£o existirem
            cursor.execute("PRAGMA table_info(pneus_historico)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'status' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN status TEXT DEFAULT 'Ativo'")
            if 'vida_atual' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN vida_atual INTEGER DEFAULT 1")
            if 'numero_fogo' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN numero_fogo TEXT")
            conn.commit()
        return True, "Tabela de pneus verificada"
    except Exception as e:
        return False, f"Erro ao criar tabela de pneus: {e}"

def importar_pneus_de_planilha(db_path: str, arquivo_carregado):
    """Importa hist√≥rico de pneus de uma planilha Excel, verificando duplicatas."""
    try:
        df_pneus = pd.read_excel(arquivo_carregado)
        df_pneus.columns = [c.strip() for c in df_pneus.columns]
        obrig = ['Cod_Equip', 'posicao', 'marca', 'modelo', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao']
        faltando = [c for c in obrig if c not in df_pneus.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        if 'observacoes' not in df_pneus.columns:
            df_pneus['observacoes'] = ""
        
        
        # Limpar dados e remover linhas com valores nulos obrigat√≥rios
        df_pneus = df_pneus.dropna(subset=['Cod_Equip', 'posicao', 'numero_fogo'])
        
        # Normalizar tipos de dados
        df_pneus['Cod_Equip'] = df_pneus['Cod_Equip'].astype(str)
        df_pneus['posicao'] = df_pneus['posicao'].astype(str).str.strip()
        df_pneus['numero_fogo'] = df_pneus['numero_fogo'].astype(str).str.strip()
        df_pneus['data_instalacao'] = pd.to_datetime(df_pneus['data_instalacao']).dt.strftime('%Y-%m-%d')
        
        # Remover duplicatas na pr√≥pria planilha baseada em chave √∫nica
        df_pneus = df_pneus.drop_duplicates(subset=['Cod_Equip', 'posicao', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Buscar registros existentes para verificar duplicatas
            df_existente = pd.read_sql_query("SELECT Cod_Equip, posicao, numero_fogo, data_instalacao, hodometro_instalacao FROM pneus_historico", conn)
            
            if not df_existente.empty:
                # Normalizar dados existentes para compara√ß√£o
                df_existente['Cod_Equip'] = df_existente['Cod_Equip'].astype(str)
                df_existente['posicao'] = df_existente['posicao'].astype(str).str.strip()
                df_existente['numero_fogo'] = df_existente['numero_fogo'].astype(str).str.strip()
                df_existente['data_instalacao'] = pd.to_datetime(df_existente['data_instalacao']).dt.strftime('%Y-%m-%d')
                
                # Criar chaves √∫nicas para compara√ß√£o
                df_pneus['chave_unica'] = (df_pneus['Cod_Equip'] + '_' + 
                                          df_pneus['posicao'] + '_' + 
                                          df_pneus['numero_fogo'] + '_' + 
                                          df_pneus['data_instalacao'] + '_' + 
                                          df_pneus['hodometro_instalacao'].astype(str))
                
                df_existente['chave_unica'] = (df_existente['Cod_Equip'] + '_' + 
                                              df_existente['posicao'] + '_' + 
                                              df_existente['numero_fogo'] + '_' + 
                                              df_existente['data_instalacao'] + '_' + 
                                              df_existente['hodometro_instalacao'].astype(str))
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_pneus[~df_pneus['chave_unica'].isin(df_existente['chave_unica'])]
            else:
                df_para_inserir = df_pneus
            
            num_duplicados = len(df_pneus) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum pneu novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = obrig + ['observacoes']
            # Garantir que a coluna observacoes exista no DataFrame
            if 'observacoes' not in df_para_inserir.columns:
                df_para_inserir['observacoes'] = ''
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.fillna('').to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO pneus_historico ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} pneus novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar pneus: {e}"

def get_pneus_historico(cod_equip=None):
    """Retorna o hist√≥rico de pneus, opcionalmente filtrando por frota."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            query = "SELECT * FROM pneus_historico"
            params = ()
            if cod_equip:
                query += " WHERE Cod_Equip = ?"
                params = (cod_equip,)
            return pd.read_sql_query(query, conn, params=params)
    except Exception:
        return pd.DataFrame()

def ensure_precos_combustivel_schema():
    """Garante a exist√™ncia da tabela de pre√ßos por tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS precos_combustivel (
                    tipo_combustivel TEXT PRIMARY KEY,
                    preco REAL
                )
                """
            )
            tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
            for t in tipos:
                cur.execute("INSERT OR IGNORE INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?)", (t, NULL))
            conn.commit()
        return True, "Tabela de pre√ßos verificada"
    except Exception as e:
        return False, f"Erro ao verificar tabela de pre√ßos: {e}"

def get_precos_combustivel_map() -> dict:
    """Retorna um dicion√°rio {tipo_combustivel: preco}."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            dfp = pd.read_sql_query("SELECT tipo_combustivel, preco FROM precos_combustivel", conn)
        return {row['tipo_combustivel']: row['preco'] for _, row in dfp.iterrows()}
    except Exception:
        return {}

def upsert_preco_combustivel(tipo: str, preco: float) -> tuple[bool, str]:
    """Cria/atualiza pre√ßo para um tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?) ON CONFLICT(tipo_combustivel) DO UPDATE SET preco=excluded.preco",
                (tipo, preco)
            )
            conn.commit()
        return True, f"Pre√ßo atualizado para {tipo}"
    except Exception as e:
        return False, f"Erro ao atualizar pre√ßo: {e}"
    
def ensure_lubrificantes_schema():
    """Garante a exist√™ncia da tabela de lubrificantes, movimenta√ß√µes e almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            
            # Tabela de lubrificantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT,
                    viscosidade TEXT,
                    quantidade_estoque REAL,
                    unidade TEXT,
                    observacoes TEXT
                )
            """)
            
            # Verificar e adicionar coluna 'tipo' se n√£o existir
            cursor.execute("PRAGMA table_info(lubrificantes)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'tipo' not in cols:
                cursor.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
            
            # Tabela de almoxarifados
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifados (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT NOT NULL,
                    tipo TEXT DEFAULT 'fixo', -- 'fixo' para oficina, 'movel' para caminh√µes
                    localizacao TEXT,
                    responsavel TEXT,
                    observacoes TEXT,
                    ativo BOOLEAN DEFAULT 1
                )
            """)
            
            # Tabela de estoque por almoxarifado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifado_estoque (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_almoxarifado INTEGER,
                    id_lubrificante INTEGER,
                    quantidade_estoque REAL DEFAULT 0,
                    unidade TEXT,
                    data_atualizacao TEXT,
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id),
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    UNIQUE(id_almoxarifado, id_lubrificante)
                )
            """)
            
            # Tabela de movimenta√ß√µes (atualizada para incluir almoxarifado)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes_movimentacoes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_lubrificante INTEGER,
                    id_almoxarifado INTEGER,
                    tipo TEXT, -- 'entrada' ou 'saida'
                    quantidade REAL,
                    data TEXT,
                    cod_equip INTEGER,
                    observacoes TEXT,
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id)
                )
            """)
            
            # Verificar se a coluna id_almoxarifado existe na tabela de movimenta√ß√µes
            cursor.execute("PRAGMA table_info(lubrificantes_movimentacoes)")
            cols_mov = [c[1] for c in cursor.fetchall()]
            if 'id_almoxarifado' not in cols_mov:
                cursor.execute("ALTER TABLE lubrificantes_movimentacoes ADD COLUMN id_almoxarifado INTEGER")
            
            conn.commit()
        return True, "Tabelas de lubrificantes e almoxarifados verificadas"
    except Exception as e:
        return False, f"Erro ao criar tabelas de lubrificantes: {e}"
    
def add_almoxarifado(nome, tipo="fixo", localizacao="", responsavel="", observacoes=""):
    """Adiciona um novo almoxarifado."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO almoxarifados (nome, tipo, localizacao, responsavel, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, tipo, localizacao, responsavel, observacoes)
            )
            conn.commit()
        return True, "Almoxarifado cadastrado com sucesso!"
    except Exception as e:
        return False, f"Erro: {e}"

def get_almoxarifados():
    """Retorna todos os almoxarifados ativos."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            df = pd.read_sql("SELECT * FROM almoxarifados WHERE ativo = 1 ORDER BY nome", conn)
        return df
    except Exception as e:
        return pd.DataFrame()

def get_estoque_por_almoxarifado(id_lubrificante):
    """Retorna o estoque de um lubrificante distribu√≠do por almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT 
                a.nome as almoxarifado,
                a.tipo,
                COALESCE(ae.quantidade_estoque, 0) as quantidade,
                COALESCE(ae.unidade, l.unidade) as unidade,
                a.localizacao,
                a.responsavel
            FROM almoxarifados a
            CROSS JOIN lubrificantes l
            LEFT JOIN almoxarifado_estoque ae ON a.id = ae.id_almoxarifado AND l.id = ae.id_lubrificante
            WHERE l.id = ? AND a.ativo = 1
            ORDER BY a.nome
            """
            df = pd.read_sql(query, conn, params=(id_lubrificante,))
        return df
    except Exception as e:
        return pd.DataFrame()

def atualizar_estoque_almoxarifado(id_almoxarifado, id_lubrificante, quantidade, unidade):
    """Atualiza o estoque de um lubrificante em um almoxarifado espec√≠fico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO almoxarifado_estoque 
                (id_almoxarifado, id_lubrificante, quantidade_estoque, unidade, data_atualizacao) 
                VALUES (?, ?, ?, ?, ?)
            """, (id_almoxarifado, id_lubrificante, quantidade, unidade, date.today().strftime("%Y-%m-%d")))
            conn.commit()
        return True, "Estoque atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao atualizar estoque: {e}"

def add_lubrificante(nome, viscosidade, quantidade, unidade, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes (nome, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, viscosidade, quantidade, unidade, observacoes)
            )
            conn.commit()
        return True, "Lubrificante cadastrado!"
    except Exception as e:
        return False, f"Erro: {e}"

def importar_lubrificantes_de_planilha(db_path: str, arquivo_carregado):
    """Importa lubrificantes de uma planilha Excel, verificando duplicatas."""
    try:
        df_lub = pd.read_excel(arquivo_carregado)
        df_lub.columns = [c.strip() for c in df_lub.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome': 'nome',
            'tipo': 'tipo',
            'viscosidade': 'viscosidade',
            'quantidade_estoque': 'quantidade_estoque',
            'unidade': 'unidade',
            'observacoes': 'observacoes'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_lub.columns:
                df_lub = df_lub.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome']
        faltando = [c for c in obrig if c not in df_lub.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'tipo' not in df_lub.columns:
            df_lub['tipo'] = '√≥leo'
        if 'viscosidade' not in df_lub.columns:
            df_lub['viscosidade'] = ''
        if 'quantidade_estoque' not in df_lub.columns:
            df_lub['quantidade_estoque'] = 0
        if 'unidade' not in df_lub.columns:
            df_lub['unidade'] = 'L'
        if 'observacoes' not in df_lub.columns:
            df_lub['observacoes'] = ''
        
        # Limpar e normalizar dados
        df_lub = df_lub.dropna(subset=['nome'])
        df_lub['nome'] = df_lub['nome'].astype(str).str.strip()
        df_lub['tipo'] = df_lub['tipo'].astype(str).str.strip().fillna('√≥leo')
        df_lub['viscosidade'] = df_lub['viscosidade'].astype(str).str.strip().fillna('')
        df_lub['quantidade_estoque'] = pd.to_numeric(df_lub['quantidade_estoque'], errors='coerce').fillna(0)
        df_lub['unidade'] = df_lub['unidade'].astype(str).str.strip().fillna('L')
        df_lub['observacoes'] = df_lub['observacoes'].astype(str).str.strip().fillna('')
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome
        df_lub = df_lub.drop_duplicates(subset=['nome'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que a tabela existe com a coluna tipo
            ensure_lubrificantes_schema()
            
            # Buscar lubrificantes existentes
            df_existente = pd.read_sql_query("SELECT nome FROM lubrificantes", conn)
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome'] = df_existente['nome'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_lub[~df_lub['nome'].isin(df_existente['nome'])]
            else:
                df_para_inserir = df_lub
            
            num_duplicados = len(df_lub) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum lubrificante novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = ['nome', 'tipo', 'viscosidade', 'quantidade_estoque', 'unidade', 'observacoes']
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO lubrificantes ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} lubrificantes novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar lubrificantes: {e}"

def importar_componentes_de_planilha(db_path: str, arquivo_carregado, classe_operacional: str):
    """Importa componentes de uma planilha Excel, verificando duplicatas e criando lubrificantes se necess√°rio."""
    try:
        df_comp = pd.read_excel(arquivo_carregado)
        df_comp.columns = [c.strip() for c in df_comp.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome_componente': 'nome_componente',
            'componente': 'nome_componente',
            'intervalo_padrao': 'intervalo_padrao',
            'intervalo': 'intervalo_padrao',
            'lubrificante_nome': 'lubrificante_nome',
            'lubrificante': 'lubrificante_nome',
            'capacidade_litros': 'capacidade_litros',
            'capacidade': 'capacidade_litros'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_comp.columns:
                df_comp = df_comp.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome_componente', 'intervalo_padrao']
        faltando = [c for c in obrig if c not in df_comp.columns]
        if faltando:
            return 0, 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'lubrificante_nome' not in df_comp.columns:
            df_comp['lubrificante_nome'] = None
        if 'capacidade_litros' not in df_comp.columns:
            df_comp['capacidade_litros'] = 0.0
        
        # Limpar e normalizar dados
        df_comp = df_comp.dropna(subset=['nome_componente'])
        df_comp['nome_componente'] = df_comp['nome_componente'].astype(str).str.strip()
        df_comp['intervalo_padrao'] = pd.to_numeric(df_comp['intervalo_padrao'], errors='coerce')
        df_comp = df_comp.dropna(subset=['intervalo_padrao'])
        df_comp['lubrificante_nome'] = df_comp['lubrificante_nome'].astype(str).str.strip().replace('nan', None)
        df_comp['capacidade_litros'] = pd.to_numeric(df_comp['capacidade_litros'], errors='coerce').fillna(0.0)
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome do componente
        df_comp = df_comp.drop_duplicates(subset=['nome_componente'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que as tabelas existem
            ensure_lubrificantes_schema()
            
            # Verificar se a tabela componentes_regras tem a coluna capacidade_litros
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'capacidade_litros' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN capacidade_litros REAL DEFAULT 0.0")
            
            # Buscar componentes existentes na classe
            df_existente = pd.read_sql_query(
                "SELECT nome_componente FROM componentes_regras WHERE classe_operacional = ?", 
                conn, params=(classe_operacional,)
            )
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome_componente'] = df_existente['nome_componente'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem na classe
                df_para_inserir = df_comp[~df_comp['nome_componente'].isin(df_existente['nome_componente'])]
            else:
                df_para_inserir = df_comp
            
            num_duplicados = len(df_comp) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, 0, "Nenhum componente novo para importar. Todos os registros da planilha j√° existem na classe selecionada."
            
            # Processar lubrificantes
            lubrificantes_criados = 0
            for _, row in df_para_inserir.iterrows():
                if pd.notna(row['lubrificante_nome']) and row['lubrificante_nome']:
                    # Verificar se o lubrificante existe
                    df_lub_existente = pd.read_sql_query(
                        "SELECT id FROM lubrificantes WHERE nome = ?", 
                        conn, params=(row['lubrificante_nome'],)
                    )
                    
                    if df_lub_existente.empty:
                        # Criar lubrificante automaticamente
                        cur = conn.cursor()
                        cur.execute(
                            "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                            (row['lubrificante_nome'], '√≥leo', '', 0, 'L', f'Criado automaticamente durante importa√ß√£o de componentes')
                        )
                        lubrificantes_criados += 1
                        
                        # Buscar o ID do lubrificante criado
                        lub_id = cur.lastrowid
                    else:
                        lub_id = df_lub_existente.iloc[0]['id']
                else:
                    lub_id = None
                
                # Inserir componente
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, capacidade_litros) VALUES (?, ?, ?, ?, ?)",
                    (classe_operacional, row['nome_componente'], row['intervalo_padrao'], lub_id, row['capacidade_litros'])
                )
            
            conn.commit()
            num_inseridos = len(df_para_inserir)
            
            mensagem_sucesso = f"{num_inseridos} componentes foram importados com sucesso para a classe '{classe_operacional}'."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} componentes duplicados foram ignorados."
            if lubrificantes_criados > 0:
                mensagem_sucesso += f" {lubrificantes_criados} lubrificantes foram criados automaticamente."
            
            return num_inseridos, num_duplicados, lubrificantes_criados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, 0, f"Erro ao importar componentes: {e}"

def movimentar_lubrificante(id_lubrificante, tipo, quantidade, data, cod_equip=None, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes_movimentacoes (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes)
            )
            # Atualiza estoque
            sinal = 1 if tipo == "entrada" else -1
            cur.execute(
                "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque + ? WHERE id = ?",
                (sinal * quantidade, id_lubrificante)
            )
            conn.commit()
        return True, "Movimenta√ß√£o registrada!"
    except Exception as e:
        return False, f"Erro: {e}"

@st.cache_data(ttl=120)
def filtrar_dados(df: pd.DataFrame, opts: dict) -> pd.DataFrame:
    # Garante que a coluna de data √© do tipo datetime
    df['Data'] = pd.to_datetime(df['Data'])
    
    # Filtra por per√≠odo de datas
    df_filtrado = df[
        (df['Data'].dt.date >= opts['data_inicio']) & 
        (df['Data'].dt.date <= opts['data_fim'])
    ]
    
    # Filtra pelas outras sele√ß√µes, se existirem
    if opts.get("classes_op"):
        df_filtrado = df_filtrado[df_filtrado["Classe_Operacional"].isin(opts["classes_op"])]
    
    if opts.get("safras"):
        df_filtrado = df_filtrado[df_filtrado["Safra"].isin(opts["safras"])]
        
    return df_filtrado.copy()

@st.cache_data(show_spinner="Calculando plano de manuten√ß√£o...", ttl=300)
def build_component_maintenance_plan(_df_frotas: pd.DataFrame, _df_abastecimentos: pd.DataFrame, _df_componentes_regras: pd.DataFrame, _df_componentes_historico: pd.DataFrame) -> pd.DataFrame:
    latest_readings = _df_abastecimentos.sort_values('Data').groupby('Cod_Equip')['Hod_Hor_Atual'].last()
    plan_data = []

    for _, frota_row in _df_frotas.iterrows():
        cod_equip = frota_row['Cod_Equip']
        classe_op = frota_row.get('Classe_Operacional')
        hod_hor_atual = latest_readings.get(cod_equip)

        if pd.isna(hod_hor_atual) or not classe_op:
            continue
        
        regras_da_classe = _df_componentes_regras[_df_componentes_regras['classe_operacional'] == classe_op]
        if regras_da_classe.empty:
            continue

        unidade = 'km' if frota_row['Tipo_Controle'] == 'QUIL√îMETROS' else 'h'
        alerta_default = ALERTAS_MANUTENCAO.get(frota_row['Tipo_Controle'], {}).get('default', 500)
        
        record = {
            'Cod_Equip': cod_equip, 
            'Equipamento': frota_row.get('DESCRICAO_EQUIPAMENTO'), 
            'Leitura_Atual': hod_hor_atual, 
            'Unidade': unidade, 
            'Qualquer_Alerta': False, 
            'Alertas': []
        }

        for _, regra in regras_da_classe.iterrows():
            componente = regra['nome_componente']
            intervalo = regra['intervalo_padrao']
            
            historico_componente = _df_componentes_historico[
                (_df_componentes_historico['Cod_Equip'] == cod_equip) &
                (_df_componentes_historico['nome_componente'] == componente)
            ]
            
            ultimo_servico_hod_hor = 0
            if not historico_componente.empty:
                ultimo_servico_hod_hor = historico_componente['Hod_Hor_No_Servico'].max()

            prox_servico = ((ultimo_servico_hod_hor // intervalo) * intervalo) + intervalo
            while prox_servico < hod_hor_atual:
                prox_servico += intervalo

            restante = prox_servico - hod_hor_atual
            
            record[f'Restante_{componente}'] = restante
            
            if restante <= alerta_default:
                record['Qualquer_Alerta'] = True
                record['Alertas'].append(componente)

        plan_data.append(record)

    # üîπ Garante que sempre retorna um DataFrame com as colunas b√°sicas
    if not plan_data:
        return pd.DataFrame(columns=['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Qualquer_Alerta', 'Alertas'])

    return pd.DataFrame(plan_data)

def prever_manutencoes(df_veiculos: pd.DataFrame, df_abastecimentos: pd.DataFrame, plan_df: pd.DataFrame) -> pd.DataFrame:
    """Estima as datas das pr√≥ximas manuten√ß√µes com base no uso m√©dio."""
    if plan_df.empty or 'Leitura_Atual' not in plan_df.columns:
        return pd.DataFrame()

    # Calcula o uso di√°rio m√©dio de cada ve√≠culo
    uso_diario = {}
    for cod_equip in df_abastecimentos['Cod_Equip'].unique():
        dados_equip = df_abastecimentos[df_abastecimentos['Cod_Equip'] == cod_equip].sort_values('Data')
        if len(dados_equip) > 1:
            total_dias = (dados_equip['Data'].max() - dados_equip['Data'].min()).days
            total_uso = dados_equip['Hod_Hor_Atual'].max() - dados_equip['Hod_Hor_Atual'].min()
            if total_dias > 0 and total_uso > 0: # Garante que houve uso e passagem de tempo
                uso_diario[cod_equip] = total_uso / total_dias

    previsoes = []
    servicos_nomes = [col.replace('Restante_', '') for col in plan_df.columns if 'Restante_' in col]

    for _, row in plan_df.iterrows():
        cod_equip = row['Cod_Equip']
        uso = uso_diario.get(cod_equip)
        if uso:
            for nome_servico in servicos_nomes:
                col_restante = f'Restante_{nome_servico}'
                if col_restante in row and pd.notna(row[col_restante]):
                    dias_para_manut = row[col_restante] / uso
                    data_prevista = datetime.now() + pd.Timedelta(days=dias_para_manut)
                    previsoes.append({
                        'Equipamento': row['Equipamento'],
                        'Manuten√ß√£o': nome_servico,
                        'Data Prevista': data_prevista.strftime('%d/%m/%Y'),
                        'Dias Restantes': int(dias_para_manut)
                    })

    if not previsoes:
        return pd.DataFrame()

    df_previsoes = pd.DataFrame(previsoes)
    return df_previsoes.sort_values('Dias Restantes')

# ---------------------------
# Fun√ß√µes para Checklists
# ---------------------------

@st.cache_data(ttl=120)
def get_checklist_rules():
    """Busca todas as regras de checklist do banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM checklist_regras", conn)
    except Exception as e:
        st.error(f"Erro ao buscar regras de checklist: {e}")
        return pd.DataFrame()

@st.cache_data(ttl=120)
def get_checklist_items(id_regra):
    """Busca os itens de checklist para uma determinada regra."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query(
                "SELECT * FROM checklist_itens WHERE id_regra = ?",
                conn,
                params=(id_regra,)
            )
    except Exception as e:
        st.error(f"Erro ao buscar itens de checklist: {e}")
        return pd.DataFrame()

# ---------------------------
# CRUD para Checklists
# ---------------------------

def add_checklist_rule(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra de checklist ao banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
        return True, "Regra de checklist adicionada com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar regra de checklist: {e}"

def add_checklist_rule_and_get_id(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra e devolve o ID criado (ou None em erro).

    Mant√©m a fun√ß√£o "add_checklist_rule" para compatibilidade, mas quando for
    necess√°rio o ID imediatamente ap√≥s a cria√ß√£o, utilize esta fun√ß√£o.
    """
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        st.error(f"Erro ao adicionar regra de checklist: {e}")
        return None

def edit_checklist_rule(id_regra, classe_operacional, titulo_checklist, turno, frequencia):
    """Edita uma regra de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_regras
                SET classe_operacional = ?, titulo_checklist = ?, frequencia = ?, turno = ?
                WHERE id_regra = ?
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno, id_regra)
            )
            conn.commit()
        return True, "Regra de checklist atualizada com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar regra de checklist: {e}"

def delete_checklist_rule(id_regra):
    """Remove uma regra de checklist e seus itens associados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_regra = ?", (id_regra,))
            cursor.execute("DELETE FROM checklist_regras WHERE id_regra = ?", (id_regra,))
            conn.commit()
        return True, "Regra de checklist removida com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover regra de checklist: {e}"

def add_checklist_item(id_regra, nome_item):
    """Adiciona um novo item de checklist a uma regra existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_itens (id_regra, nome_item)
                VALUES (?, ?)
                """ ,
                (id_regra, nome_item)
            )
            conn.commit()
        return True, "Item de checklist adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar item de checklist: {e}"

def edit_checklist_item(id_item, nome_item):
    """Edita um item de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_itens
                SET nome_item = ?
                WHERE id_item = ?
                """ ,
                (nome_item, id_item)
            )
            conn.commit()
        return True, "Item de checklist atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar item de checklist: {e}"

def delete_checklist_item(id_item):
    """Remove um item de checklist."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_item = ?", (id_item,))
            conn.commit()
        return True, "Item de checklist removido com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover item de checklist: {e}"

def save_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno, status_geral):
    """Salva um checklist preenchido no hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_historico 
                (Cod_Equip, titulo_checklist, data_preenchimento, turno, status_geral) 
                VALUES (?, ?, ?, ?, ?)
                """ ,
                (cod_equip, titulo_checklist, data_preenchimento, turno, status_geral)
            )
            conn.commit()
    except Exception as e:
        st.error(f"Erro ao salvar hist√≥rico de checklist: {e}")

def delete_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno):
    """Remove um registro do hist√≥rico de checklists usando uma combina√ß√£o √∫nica de campos."""
    try:
        # Primeira tentativa: usar conex√£o direta
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)  # Converter numpy.int64 para int
        titulo_checklist = str(titulo_checklist)
        data_preenchimento = str(data_preenchimento)
        turno = str(turno)
        
        # Debug: verificar todos os registros na tabela ANTES da exclus√£o
        cursor.execute("SELECT rowid, Cod_Equip, titulo_checklist, data_preenchimento, turno FROM checklist_historico")
        all_records_before = cursor.fetchall()
        
        # Tentar encontrar o registro com diferentes abordagens
        rowid = None
        
        # Primeira tentativa: busca exata
        cursor.execute(
            "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
            (cod_equip, titulo_checklist, data_preenchimento, turno)
        )
        result = cursor.fetchone()
        
        if result:
            rowid = result[0]
        else:
            # Segunda tentativa: buscar apenas por Cod_Equip, t√≠tulo e turno (ignorar data)
            cursor.execute(
                "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND turno = ?", 
                (cod_equip, titulo_checklist, turno)
            )
            result = cursor.fetchone()
            
            if result:
                rowid = result[0]
            else:
                # Terceira tentativa: buscar apenas por Cod_Equip e t√≠tulo
                cursor.execute(
                    "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ?", 
                    (cod_equip, titulo_checklist)
                )
                result = cursor.fetchone()
                
                if result:
                    rowid = result[0]
        
        if rowid is None:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - T√≠tulo: {titulo_checklist} (tipo: {type(titulo_checklist)})
            - Data: {data_preenchimento} (tipo: {type(data_preenchimento)})
            - Turno: {turno} (tipo: {type(turno)})
            
            Todos os registros na tabela ANTES da exclus√£o:
            {all_records_before}
            """
            conn.close()
            return False, debug_info
        
        # Agora vamos excluir usando rowid
        cursor.execute("DELETE FROM checklist_historico WHERE rowid = ?", (rowid,))
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute("SELECT COUNT(*) FROM checklist_historico WHERE rowid = ?", (rowid,))
            count_after = cursor.fetchone()[0]
            
            # Verificar tamb√©m se o registro ainda existe pelos outros campos
            cursor.execute(
                "SELECT COUNT(*) FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
                (cod_equip, titulo_checklist, data_preenchimento, turno)
            )
            count_by_fields = cursor.fetchone()[0]
            
            if count_after == 0 and count_by_fields == 0:
                 # Verificar o total de registros na tabela
                 cursor.execute("SELECT COUNT(*) FROM checklist_historico")
                 total_after = cursor.fetchone()[0]
                 
                 # For√ßar sincroniza√ß√£o do banco
                 cursor.execute("PRAGMA wal_checkpoint(FULL)")
                 cursor.execute("PRAGMA synchronous=FULL")
                 conn.commit()
                 
                 success_msg = f"Checklist exclu√≠do com sucesso! ({rows_deleted} registro(s) removido(s)). Total na tabela: {total_after}"
                 
                 # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                 backup_success, backup_msg = save_backup_to_session_state()
                 if backup_success:
                     success_msg += f" | Backup salvo: {backup_msg}"
                 else:
                     success_msg += f" | Aviso: {backup_msg}"
                 
                 conn.close()
                 return True, success_msg
            else:
                conn.close()
                return False, f"Erro: Registro ainda existe ap√≥s exclus√£o. Count by rowid: {count_after}, Count by fields: {count_by_fields}"
        else:
            conn.close()
            return False, "Nenhum registro foi exclu√≠do"
                
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return False, f"Erro ao excluir checklist: {e}"

def force_cache_clear():
    """For√ßa a limpeza completa de todos os caches."""
    try:
        # Limpar cache de dados
        st.cache_data.clear()
        
        # Limpar cache de recursos
        st.cache_resource.clear()
        
        # For√ßar rerun da aplica√ß√£o
        st.rerun()
    except Exception as e:
        st.error(f"Erro ao limpar cache: {e}")

def force_database_sync():
    """For√ßa a sincroniza√ß√£o do banco de dados com o disco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # For√ßar commit
        conn.commit()
        
        # Executar PRAGMA para for√ßar sincroniza√ß√£o
        cursor.execute("PRAGMA wal_checkpoint(FULL)")
        cursor.execute("PRAGMA synchronous=FULL")
        cursor.execute("PRAGMA journal_mode=DELETE")
        
        # For√ßar commit novamente
        conn.commit()
        
        # Verificar se o banco est√° em modo WAL
        cursor.execute("PRAGMA journal_mode")
        journal_mode = cursor.fetchone()[0]
        
        conn.close()
        
        return True, f"Banco sincronizado. Modo journal: {journal_mode}"
    except Exception as e:
        return False, f"Erro ao sincronizar banco: {e}"

def export_database_backup():
    """Exporta todos os dados do banco para um arquivo de backup."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        
        # Obter todas as tabelas
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        backup_data = {}
        
        for table in tables:
            table_name = table[0]
            if table_name != 'sqlite_master':
                # Exportar dados da tabela
                df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
                backup_data[table_name] = df.to_dict('records')
        
        conn.close()
        
        # Converter para JSON
        backup_json = json.dumps(backup_data, default=str, indent=2)
        
        # Criar arquivo de download
        backup_bytes = backup_json.encode('utf-8')
        backup_b64 = base64.b64encode(backup_bytes).decode()
        
        return backup_b64, backup_data
        
    except Exception as e:
        return None, f"Erro ao exportar backup: {e}"

def import_database_backup(backup_data):
    """Importa dados de backup para o banco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        for table_name, records in backup_data.items():
            if records:  # Se a tabela tem dados
                # Limpar tabela existente
                cursor.execute(f"DELETE FROM {table_name}")
                
                # Inserir novos dados
                for record in records:
                    columns = list(record.keys())
                    placeholders = ', '.join(['?' for _ in columns])
                    values = list(record.values())
                    
                    # Converter tipos de dados
                    converted_values = []
                    for value in values:
                        if isinstance(value, str):
                            # Tentar converter para datetime se for uma data
                            try:
                                if 'T' in value or '-' in value:
                                    dt = pd.to_datetime(value)
                                    converted_values.append(dt.strftime('%Y-%m-%d %H:%M:%S'))
                                else:
                                    converted_values.append(value)
                            except:
                                converted_values.append(value)
                        else:
                            converted_values.append(value)
                    
                    cursor.execute(
                        f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})",
                        converted_values
                    )
        
        conn.commit()
        conn.close()
        
        return True, "Backup restaurado com sucesso!"
        
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def save_backup_to_session_state():
    """Salva backup dos dados na sess√£o do Streamlit."""
    try:
        backup_b64, backup_data = export_database_backup()
        if backup_b64:
            st.session_state['database_backup'] = backup_b64
            st.session_state['backup_timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return True, "Backup salvo na sess√£o"
        else:
            return False, "Erro ao criar backup"
    except Exception as e:
        return False, f"Erro ao salvar backup: {e}"

def restore_backup_from_session_state():
    """Restaura backup dos dados da sess√£o do Streamlit."""
    try:
        if 'database_backup' in st.session_state:
            backup_b64 = st.session_state['database_backup']
            backup_bytes = base64.b64decode(backup_b64)
            backup_json = backup_bytes.decode('utf-8')
            backup_data = json.loads(backup_json)
            
            success, message = import_database_backup(backup_data)
            if success:
                # Limpar cache para for√ßar recarregamento
                force_cache_clear()
                return True, message
            else:
                return False, message
        else:
            return False, "Nenhum backup encontrado na sess√£o"
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def auto_restore_backup_on_startup():
    """Tenta restaurar backup automaticamente na inicializa√ß√£o da aplica√ß√£o."""
    try:
        if 'database_backup' in st.session_state:
            # Verificar se o banco est√° vazio
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
            num_tables = cursor.fetchone()[0]
            conn.close()
            
            if num_tables == 0:
                # Banco vazio, tentar restaurar
                success, message = restore_backup_from_session_state()
                if success:
                    st.info("üîÑ Backup restaurado automaticamente na inicializa√ß√£o!")
                    return True
                else:
                    st.warning(f"‚ö†Ô∏è Falha na restaura√ß√£o autom√°tica: {message}")
                    return False
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na restaura√ß√£o autom√°tica: {e}")
        return False

def main():
    
    # Garante tema dark coerente mesmo sem config.toml
    st.markdown(
        """
        <style>
        :root {
            --primary: #10b981;
            --bg: #0f172a;
            --bg2: #111827;
            --text: #e5e7eb;
        }
        body { background: var(--bg); color: var(--text); }
        section.main > div { background: var(--bg); }
        .stApp { background: var(--bg); }
        .st-emotion-cache-1r4qj8v, .st-emotion-cache-13ln4jf { background: var(--bg2) !important; }
        .stButton>button { background: var(--primary); color: #062e24; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    # CSS fino para polir a UI
    st.markdown(
        """
        <style>
        /* Cart√µes/containers */
        .stExpander, .stDataFrame, .stTable { border-radius: 10px !important; }
        .stButton>button { border-radius: 8px; padding: 0.5rem 1rem; }
        .stSelectbox, .stTextInput, .stNumberInput, .stDateInput, .stTextArea { border-radius: 8px !important; }
        /* M√©tricas com mais destaque */
        div[data-testid="stMetric"] { background: rgba(255,255,255,0.04); padding: 10px 14px; border-radius: 12px; }
        /* T√≠tulos com leve gradiente */
        h1, h2, h3 { background: linear-gradient(90deg, #10b981 0%, #06b6d4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        /* Linhas divis√≥rias mais suaves */
        hr { border: none; height: 1px; background: rgba(255,255,255,0.08); }
        /* Subt√≠tulo de marca (opcional) */
        .brand-subtitle { display: none; }
        /* Centralizar e limitar logo na sidebar */
        section[data-testid="stSidebar"] img { display: block; margin: 0.5rem auto 0.75rem; max-width: 140px; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
        st.session_state.role = None
        st.session_state.username = ""

    if not st.session_state.authenticated:
        _ , col_central, _ = st.columns([1, 1.5, 1])
    
        with col_central:
            
            if os.path.exists("logo.png"):
                # Cria 3 sub-colunas dentro da coluna central
                _, logo_col, _ = st.columns([1, 2, 1])
                with logo_col:
                    st.image("logo.png", width=140)
            
            st.title("Bem vindo ao Aplicativo de Controle do PCMA")

            username = st.text_input("Usu√°rio", key="login_user")
            password = st.text_input("Senha", type="password", key="login_pass")

            if st.button("Entrar", use_container_width=True):
                role = check_login_db(username, password)
                if role:
                    st.session_state.authenticated = True
                    st.session_state.role = role
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("Usu√°rio ou Senha incorretos.")
    else:

        # Cabe√ßalho com logo + t√≠tulo
        if os.path.exists("logo.png"):
            col_logo, col_title = st.columns([1, 8])
            with col_logo:
                st.image("logo.png", width=80)
            with col_title:
                st.title("üìä Dashboard de Frotas e Abastecimentos")
        else:
            st.title("üìä Dashboard de Frotas e Abastecimentos")

        # Tentar restaurar backup automaticamente na inicializa√ß√£o
        auto_restore_backup_on_startup()
        
        # Adicionar coluna de tipo de combust√≠vel se n√£o existir
        add_tipo_combustivel_column()
        
        # Setup de esquemas (motoristas, pre√ßos, combust√≠vel)
        ensure_motoristas_schema()
        ensure_precos_combustivel_schema()

        # Passo um fingerprint simples das tabelas para invalidar cache quando necess√°rio
        ver_frotas = int(os.path.getmtime(DB_PATH)) if os.path.exists(DB_PATH) else 0
        df, df_frotas, df_manutencoes, df_comp_regras, df_comp_historico, df_checklist_regras, df_checklist_itens, df_checklist_historico = load_data_from_db(DB_PATH, ver_frotas, ver_frotas, ver_frotas, ver_frotas, ver_frotas)
        

        if 'intervalos_por_classe' not in st.session_state:
            st.session_state.intervalos_por_classe = {}
        classes_operacionais = [c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()]
        for classe in classes_operacionais:
            if classe not in st.session_state.intervalos_por_classe:
                tipo_controle = df_frotas[df_frotas['Classe_Operacional'] == classe]['Tipo_Controle'].iloc[0]
                if tipo_controle == 'HORAS':
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 5.0,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 250},
                            'servico_2': {'nome': 'Revisao A', 'intervalo': 100},
                            'servico_3': {'nome': 'Revisao B', 'intervalo': 300},
                            'servico_4': {'nome': 'Revisao C', 'intervalo': 500}
                        }
                    }
                else: # QUIL√îMETROS
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 2.5,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 5000},
                            'servico_2': {'nome': 'Revisao 5k', 'intervalo': 5000},
                            'servico_3': {'nome': 'Revisao 10k', 'intervalo': 10000},
                            'servico_4': {'nome': 'Revisao 20k', 'intervalo': 20000}
                        }
                    }
                    
        with st.sidebar:
            if os.path.exists("logo.png"):
                st.image("logo.png", width=200)
            st.write(f"Bem-vindo, **{st.session_state.username}**!")
            if st.button("Sair"):
                st.session_state.authenticated = False
                st.session_state.username = "" # Limpa o username ao sair
                st.session_state.role = None
                st.rerun()
            st.markdown("---")

        with st.sidebar:
            st.header("üìÖ Filtros (v√°lidos apenas na aba An√°lise Geral)")

            # Persist√™ncia de per√≠odo
            if 'filtro_data_inicio' not in st.session_state:
                st.session_state['filtro_data_inicio'] = df['Data'].min().date()
            if 'filtro_data_fim' not in st.session_state:
                st.session_state['filtro_data_fim'] = df['Data'].max().date()

            st.subheader("Per√≠odo de An√°lise")
            data_inicio = st.date_input(
                "Data de In√≠cio", 
                st.session_state['filtro_data_inicio'],
                key='data_inicio'
            )
            data_fim = st.date_input(
                "Data de Fim", 
                st.session_state['filtro_data_fim'],
                key='data_fim'
            )
            st.session_state['filtro_data_inicio'] = data_inicio
            st.session_state['filtro_data_fim'] = data_fim

            st.markdown("---")
            st.caption("Desenvolvido por Andr√© Luis")

            with st.expander("Filtrar por Classe Operacional"):
                classe_opts = sorted(list(df["Classe_Operacional"].dropna().unique()))
                sel_classes = st.multiselect(
                    "Selecione as Classes", 
                    classe_opts, 
                    default=classe_opts,
                    key="sel_classes"
                )

            with st.expander("Filtrar por Safra"):
                safra_opts = sorted(list(df["Safra"].dropna().unique()))
                sel_safras = st.multiselect(
                    "Selecione as Safras", 
                    safra_opts, 
                    default=safra_opts,
                    key="sel_safras"
                )

            # S√≥ aplicaremos os filtros na aba "üìà An√°lise Geral" (guardaremos em sess√£o)
            st.session_state['filtro_opts_analise'] = {
                "data_inicio": data_inicio,
                "data_fim": data_fim,
                "classes_op": sel_classes,
                "safras": sel_safras
            }
    
import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, date, timedelta
import os
import plotly.express as px
import hashlib
import json
import base64
import io
# Configura√ß√£o da p√°gina (deve ser o primeiro comando Streamlit)
st.set_page_config(
    page_title="Dashboard de Frotas - A√ß√∫car Alegre",
    page_icon="üöú",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/projeto-uma',
        'Report a bug': "https://github.com/seu-usuario/projeto-uma/issues",
        'About': "# Dashboard de Frotas\n\nSistema de gest√£o de frotas da A√ß√∫car Alegre\n\nDesenvolvido por Andr√© Luis"
    }
)

# Configura√ß√£o de tema
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark'

# CSS personalizado para tema claro/escuro
def get_theme_css():
    if st.session_state.theme == 'dark':
        return """
        <style>
        .stApp {
            background-color: #0e1117;
            color: #fafafa;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """
    else:
        return """
        <style>
        .stApp {
            background-color: #ffffff;
            color: #262730;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """

# Aplicar CSS do tema
st.markdown(get_theme_css(), unsafe_allow_html=True)

# Fun√ß√£o para alternar tema
def toggle_theme():
    st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
    st.rerun()

# Fun√ß√£o para exportar dados
def export_dataframe(df, filename, file_type='csv'):
    """Exporta DataFrame em diferentes formatos"""
    if file_type == 'csv':
        csv = df.to_csv(index=False, sep=';', decimal=',', encoding='utf-8-sig')
        st.download_button(
            label=f"üì• Download {filename}.csv",
            data=csv,
            file_name=f"{filename}.csv",
            mime="text/csv",
            help=f"Baixar {filename} em formato CSV"
        )
    elif file_type == 'excel':
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        buffer.seek(0)
        st.download_button(
            label=f"üì• Download {filename}.xlsx",
            data=buffer,
            file_name=f"{filename}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help=f"Baixar {filename} em formato Excel"
        )

# Fun√ß√£o para mostrar loading
def show_loading(message="Carregando dados..."):
    """Mostra indicador de carregamento"""
    with st.spinner(message):
        st.info(f"‚è≥ {message}")
        return True

# Fun√ß√£o para tooltip informativo
def info_tooltip(text, help_text):
    """Cria um elemento com tooltip informativo"""
    col1, col2 = st.columns([20, 1])
    with col1:
        st.write(text)
    with col2:
        st.info("‚ÑπÔ∏è", help=help_text)

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "frotas_data.db")

ALERTAS_MANUTENCAO = {
    'HORAS': { 'default': 20 },
    'QUIL√îMETROS': { 'default': 500 }
}

def formatar_brasileiro(valor: float, prefixo='') -> str:
    """Formata um n√∫mero com casas decimais para o padr√£o brasileiro."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{prefixo}{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

@st.cache_data(ttl=300)
def para_csv(df: pd.DataFrame):
    """Converte um DataFrame para CSV para download."""
    return df.to_csv(index=False, sep=';', decimal=',').encode('utf-8-sig')

def formatar_brasileiro_int(valor: float) -> str:
    """Formata um n√∫mero inteiro para o padr√£o brasileiro (ex: 123.456)."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{int(valor):,}".replace(",", ".")

def detect_equipment_type(df_completo: pd.DataFrame) -> pd.DataFrame:
    df = df_completo.copy()
    df['Tipo_Controle'] = df.get('Unid', pd.Series(index=df.index)).map({'HORAS': 'HORAS', 'QUIL√îMETROS': 'QUIL√îMETROS'})
    def inferir_tipo_por_classe(row):
        if pd.notna(row['Tipo_Controle']): return row['Tipo_Controle']
        classe = str(row.get('Classe_Operacional', '')).upper()
        if any(p in classe for p in ['TRATOR', 'COLHEITADEIRA', 'PULVERIZADOR', 'PLANTADEIRA', 'P√Å CARREGADEIRA', 'RETROESCAVADEIRA']): return 'HORAS'
        if any(p in classe for p in ['CAMINH√ÉO', 'CAMINHAO', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']): return 'QUIL√îMETROS'
        return 'HORAS'
    df['Tipo_Controle'] = df.apply(inferir_tipo_por_classe, axis=1)
    return df

def hash_password(password):
    """Gera um hash seguro da palavra-passe."""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login_db(username, password):
    """Verifica as credenciais contra a base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash, role FROM utilizadores WHERE username = ?", (username,))
        result = cursor.fetchone()
        conn.close()
        if result:
            password_hash_db, role = result
            if password_hash_db == hash_password(password):
                return role
        return None
    except Exception as e:
        st.error(f"Erro ao aceder √† base de dados de utilizadores: {e}")
        return None

def get_all_users():
    """Busca todos os utilizadores da base de dados."""
    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
        return pd.read_sql_query("SELECT id, username, role FROM utilizadores", conn)

def add_user(username, password, role):
    """Adiciona um novo utilizador √† base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO utilizadores (username, password_hash, role) VALUES (?, ?, ?)",
            (username, hash_password(password), role)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador adicionado com sucesso!"
    except sqlite3.IntegrityError:
        return False, f"Erro: O nome de utilizador '{username}' j√° existe."
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def update_user(user_id, new_username, new_role):
    """Atualiza o nome e a fun√ß√£o de um utilizador."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE utilizadores SET username = ?, role = ? WHERE id = ?",
            (new_username, new_role, user_id)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador atualizado com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def delete_user(user_id):
    """Remove um utilizador da base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM utilizadores WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        return True, "Utilizador removido com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

    
# APAGUE A SUA FUN√á√ÉO "load_data_from_db" INTEIRA E SUBSTITUA-A POR ESTE BLOCO FINAL

@st.cache_data(show_spinner="Carregando e processando dados...", ttl=300)
def load_data_from_db(db_path: str, ver_frotas: int=None, ver_abast: int=None, ver_manut: int=None, ver_comp: int=None, ver_chk: int=None):
    if not os.path.exists(db_path):
        st.error(f"Arquivo de banco de dados '{db_path}' n√£o encontrado.")
        st.stop()

    try:
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            df_abast = pd.read_sql_query("SELECT rowid, * FROM abastecimentos", conn)
            df_frotas = pd.read_sql_query("SELECT * FROM frotas", conn)
            df_manutencoes = pd.read_sql_query("SELECT rowid, * FROM manutencoes", conn)
            df_comp_regras = pd.read_sql_query("SELECT * FROM componentes_regras", conn)
            df_comp_historico = pd.read_sql_query("SELECT rowid, * FROM componentes_historico", conn)
            df_checklist_regras = pd.read_sql_query("SELECT * FROM checklist_regras", conn)
            df_checklist_itens = pd.read_sql_query("SELECT * FROM checklist_itens", conn)
            df_checklist_historico = pd.read_sql_query("SELECT rowid, * FROM checklist_historico", conn)

        # --- In√≠cio do Processamento Integrado ---
        
        # Renomeia colunas para um padr√£o consistente
        df_abast = df_abast.rename(columns={"C√≥d. Equip.": "Cod_Equip", "Qtde Litros": "Qtde Litros", "M√™s": "Mes", "M√©dia": "Media"}, errors='ignore')
        df_frotas = df_frotas.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip", "Classe Operacional": "Classe_Operacional"}, errors='ignore')

        # Cria o dataframe principal mesclando abastecimentos e frotas
        df_merged = pd.merge(df_abast, df_frotas, on="Cod_Equip", how="left")
        
        # Trata colunas de classe operacional que podem ter vindo da mesclagem
        if 'Classe_Operacional_x' in df_merged.columns:
            df_merged['Classe_Operacional'] = np.where(df_merged['Classe_Operacional_x'].notna(), df_merged['Classe_Operacional_x'], df_merged['Classe_Operacional_y'])
            df_merged.drop(columns=['Classe_Operacional_x', 'Classe_Operacional_y'], inplace=True)
        
        # Converte a coluna de data e cria colunas de tempo
        df_merged["Data"] = pd.to_datetime(df_merged["Data"], errors='coerce')
        df_merged.dropna(subset=["Data"], inplace=True)
        df_merged["Ano"] = df_merged["Data"].dt.year
        df_merged["AnoMes"] = df_merged["Data"].dt.to_period("M").astype(str)
        
        # Limpa e converte colunas num√©ricas
        for col in ["Qtde Litros", "Media", "Hod_Hor_Atual"]:
            if col in df_merged.columns:
                series = df_merged[col].astype(str)
                series = series.str.replace(',', '.', regex=False).str.replace('-', '', regex=False).str.strip()
                df_merged[col] = pd.to_numeric(series, errors='coerce')
        
        # Cria a coluna "label" no dataframe de frotas para uso em seletores
        df_frotas["label"] = df_frotas["Cod_Equip"].astype(str) + " - " + df_frotas.get("DESCRICAO_EQUIPAMENTO", "").fillna("") + " (" + df_frotas.get("PLACA", "").fillna("Sem Placa") + ")"

        # Vincula informa√ß√µes de motorista aos abastecimentos (merge durante o load)
        try:
            with sqlite3.connect(db_path, check_same_thread=False) as conn:
                df_motoristas = pd.read_sql_query("SELECT codigo_pessoa, matricula, nome FROM motoristas", conn)
            if not df_motoristas.empty:
                df_merged = df_merged.merge(
                    df_motoristas.rename(columns={"codigo_pessoa": "Cod_Pessoa", "matricula": "Matricula", "nome": "Nome_Motorista"}),
                    on=["Cod_Pessoa", "Matricula"], how="left"
                )
        except Exception:
            pass
        
        # Garante que a classe operacional em df_frotas est√° atualizada
        classe_map = df_merged.dropna(subset=['Classe_Operacional']).groupby('Cod_Equip')['Classe_Operacional'].first()
        df_frotas['Classe_Operacional'] = df_frotas['Cod_Equip'].map(classe_map).fillna(df_frotas.get('Classe_Operacional'))

        # Adiciona coluna de tipo de combust√≠vel se n√£o existir
        if 'tipo_combustivel' not in df_frotas.columns:
            df_frotas['tipo_combustivel'] = 'Diesel S500'  # Valor padr√£o
        else:
            # Se a coluna existe, apenas preencher valores nulos com padr√£o
            df_frotas['tipo_combustivel'] = df_frotas['tipo_combustivel'].fillna('Diesel S500')

        # Determina o tipo de controle (Horas ou Quil√¥metros) para cada equipamento
        def determinar_tipo_controle(row):
            texto_para_verificar = (
                str(row.get('DESCRICAO_EQUIPAMENTO', '')) + ' ' + 
                str(row.get('Classe_Operacional', ''))
            ).upper()
            km_keywords = ['CAMINH', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']
            if any(p in texto_para_verificar for p in km_keywords):
                return 'QUIL√îMETROS'
            return 'HORAS'
        df_frotas['Tipo_Controle'] = df_frotas.apply(determinar_tipo_controle, axis=1)

        # Retorna todos os dataframes processados
        return (
            df_merged, df_frotas, df_manutencoes,
            df_comp_regras, df_comp_historico,
            df_checklist_regras, df_checklist_itens, df_checklist_historico
        )

    except Exception as e:
        st.error(f"Erro ao ler e processar o banco de dados: {e}")
        st.stop()
        # Retorna dataframes vazios em caso de erro
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(),
                pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

                
    
def inserir_abastecimento(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO abastecimentos (
                "C√≥d. Equip.", Data, "Qtde Litros", Hod_Hor_Atual,
                Safra, "M√™s", "Classe Operacional", Matricula, Cod_Pessoa
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['data'],
            dados['qtde_litros'],
            dados['hod_hor_atual'],
            dados['safra'],
            dados['mes'],
            dados['classe_operacional'],
            dados.get('matricula'),
            dados.get('cod_pessoa')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao inserir dados no banco de dados: {e}")
        return False

def excluir_abastecimento(db_path: str, rowid: int) -> bool:
    """Exclui um registro de abastecimento do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        # Usar rowid √© a forma mais segura de deletar uma linha espec√≠fica
        sql = "DELETE FROM abastecimentos WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir dados do banco de dados: {e}")
        return False

def excluir_manutencao_componente(db_path: str, cod_equip: int, nome_componente: str, data: str, hod_hor: float) -> bool:
    """Exclui um registro de manuten√ß√£o de componente do banco de dados usando uma combina√ß√£o √∫nica de campos."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)
        nome_componente = str(nome_componente)
        data = str(data)
        hod_hor = float(hod_hor)
        
        # Debug: verificar todos os registros na tabela
        cursor.execute("SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico")
        all_records = cursor.fetchall()
        
        # Debug: verificar se h√° registros com valores similares
        cursor.execute(
            "SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico WHERE Cod_Equip = ?", 
            (cod_equip,)
        )
        similar_records = cursor.fetchall()
        
        # Primeiro, vamos verificar se o registro existe
        cursor.execute(
            "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        count = cursor.fetchone()[0]
        
        if count == 0:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - Nome Componente: {nome_componente} (tipo: {type(nome_componente)})
            - Data: {data} (tipo: {type(data)})
            - Hod_Hor: {hod_hor} (tipo: {type(hod_hor)})
            
            Registros similares encontrados (mesmo Cod_Equip):
            {similar_records}
            
            Todos os registros na tabela:
            {all_records}
            """
            st.error(debug_info)
            return False
        
        # Agora vamos excluir
        cursor.execute(
            "DELETE FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute(
                "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
                (cod_equip, nome_componente, data, hod_hor)
            )
            count_after = cursor.fetchone()[0]
            
            if count_after == 0:
                # For√ßar sincroniza√ß√£o do banco
                cursor.execute("PRAGMA wal_checkpoint(FULL)")
                cursor.execute("PRAGMA synchronous=FULL")
                conn.commit()
                
                # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                backup_success, backup_msg = save_backup_to_session_state()
                if backup_success:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Backup salvo: {backup_msg}")
                else:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Aviso: {backup_msg}")
                
                conn.close()
                return True
            else:
                st.error("Erro: Registro ainda existe ap√≥s exclus√£o")
                conn.close()
                return False
        else:
            st.error("Nenhum registro foi exclu√≠do")
            conn.close()
            return False
            
    except Exception as e:
        st.error(f"Erro ao excluir manuten√ß√£o de componente do banco de dados: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def excluir_manutencao(db_path: str, rowid: int) -> bool:
    """Exclui um registro de manuten√ß√£o do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = "DELETE FROM manutencoes WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir manuten√ß√£o do banco de dados: {e}")
        return False

def inserir_manutencao(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = 'INSERT INTO manutencoes (Cod_Equip, Data, Tipo_Servico, Hod_Hor_No_Servico) VALUES (?, ?, ?, ?)'
        params = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'])
        cursor.execute(sql, params)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False

def inserir_frota(db_path: str, dados: dict) -> bool:
    """Insere um novo registro de frota no banco de dados."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO frotas (
                COD_EQUIPAMENTO, DESCRICAO_EQUIPAMENTO, PLACA, 
                "Classe Operacional", ATIVO, tipo_combustivel
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['descricao'],
            dados['placa'],
            dados['classe_op'],
            dados['ativo'],
            dados.get('tipo_combustivel', 'Diesel S500')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False
    

def editar_abastecimento(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de abastecimento existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE abastecimentos SET
                "C√≥d. Equip." = ?, Data = ?, "Qtde Litros" = ?, Hod_Hor_Atual = ?, Safra = ?, Matricula = ?, Cod_Pessoa = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'], dados['data'], dados['qtde_litros'], dados['hod_hor_atual'], dados['safra'],
            dados.get('matricula'), dados.get('cod_pessoa'), rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar abastecimento: {e}")
        return False

def editar_manutencao(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de manuten√ß√£o existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE manutencoes SET
                Cod_Equip = ?, Data = ?, Tipo_Servico = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'], rowid)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar manuten√ß√£o: {e}")
        return False

def editar_manutencao_componente(db_path: str, rowid: int, dados: dict) -> bool:
    """Edita um registro de manuten√ß√£o de componente existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE componentes_historico 
            SET Cod_Equip = ?, nome_componente = ?, Observacoes = ?, Data = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'],
            dados['componente'],
            dados['acao'],
            dados['data'],
            dados['hod_hor_servico'],
            rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao editar manuten√ß√£o de componente no banco de dados: {e}")
        return False

def importar_abastecimentos_de_planilha(db_path: str, arquivo_carregado) -> tuple[int, int, str]:
    """L√™ uma planilha, verifica por duplicados, e insere os novos dados. Aceita opcionalmente as colunas Matricula e Cod_Pessoa."""
    try:
        df_novo = pd.read_excel(arquivo_carregado)
        
        mapa_colunas = {
            "C√≥d. Equip.": "C√≥d. Equip.",
            "Data": "Data",
            "Qtde Litros": "Qtde Litros",
            "Hod. Hor. Atual": "Hod_Hor_Atual",
            "Safra": "Safra",
            "M√™s": "M√™s",
            "Classe Operacional": "Classe Operacional",
            "Matricula": "Matricula",
            "Cod_Pessoa": "Cod_Pessoa",
        }
        df_novo = df_novo.rename(columns={k: v for k, v in mapa_colunas.items() if k in df_novo.columns})

        colunas_necessarias = ["C√≥d. Equip.", "Data", "Qtde Litros", "Hod_Hor_Atual", "Safra", "M√™s", "Classe Operacional"]
        colunas_opcionais = ["Matricula", "Cod_Pessoa"]
        colunas_faltando = [col for col in colunas_necessarias if col not in df_novo.columns]
        if colunas_faltando:
            return 0, 0, f"Erro: Colunas n√£o encontradas: {', '.join(colunas_faltando)}"
        conn = sqlite3.connect(db_path)
        df_existente = pd.read_sql_query("SELECT * FROM abastecimentos", conn)
        
        df_novo['Data'] = pd.to_datetime(df_novo['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')
        df_existente['Data'] = pd.to_datetime(df_existente['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')

        df_novo['chave_unica'] = df_novo['C√≥d. Equip.'].astype(str) + '_' + df_novo['Data'] + '_' + df_novo['Qtde Litros'].astype(str)
        df_existente['chave_unica'] = df_existente['C√≥d. Equip.'].astype(str) + '_' + df_existente['Data'] + '_' + df_existente['Qtde Litros'].astype(str)

        df_para_inserir = df_novo[~df_novo['chave_unica'].isin(df_existente['chave_unica'])]
        
        num_duplicados = len(df_novo) - len(df_para_inserir)

        if df_para_inserir.empty:
            return 0, num_duplicados, "Nenhum registo novo para importar. Todos os registos da planilha j√° existem na base de dados."

        colunas_insert = colunas_necessarias + [c for c in colunas_opcionais if c in df_para_inserir.columns]
        df_para_inserir_final = df_para_inserir[colunas_insert]
        registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
        
        cursor = conn.cursor()
        placeholders = ", ".join(["?"] * len(colunas_insert))
        sql = f"INSERT INTO abastecimentos ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
        cursor.executemany(sql, registros)
        
        conn.commit()
        num_inseridos = cursor.rowcount
        conn.close()
        
        mensagem_sucesso = f"{num_inseridos} registos novos foram importados com sucesso."
        if num_duplicados > 0:
            mensagem_sucesso += f" {num_duplicados} registos duplicados foram ignorados."
            
        return num_inseridos, num_duplicados, mensagem_sucesso

    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o: {e}"

def editar_frota(db_path: str, cod_equip: int, dados: dict) -> bool:
    """Atualiza um registro de frota existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE frotas SET
                DESCRICAO_EQUIPAMENTO = ?, PLACA = ?, "Classe Operacional" = ?, ATIVO = ?, tipo_combustivel = ?
            WHERE COD_EQUIPAMENTO = ?
        """
        valores = (dados['descricao'], dados['placa'], dados['classe_op'], dados['ativo'], dados.get('tipo_combustivel', 'Diesel S500'), cod_equip)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar frota: {e}")
        return False

# COLE ESTE BLOCO DE C√ìDIGO NO LOCAL INDICADO

def get_component_rules():
    """Busca todas as regras de componentes da base de dados."""
    with sqlite3.connect(DB_PATH) as conn:
        return pd.read_sql_query("SELECT * FROM componentes_regras", conn)

def add_component_rule(classe, componente, intervalo):
    """Adiciona uma nova regra de componente √† base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao) VALUES (?, ?, ?)",
                (classe, componente, intervalo)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def add_component_rule_advanced(classe, componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca", capacidade_litros=0.0):
    """Adiciona uma nova regra de componente com informa√ß√µes de lubrificante e tipo de manuten√ß√£o."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, tipo_manutencao, capacidade_litros) VALUES (?, ?, ?, ?, ?, ?)",
                (classe, componente, intervalo, lubrificante_id, tipo_manutencao, capacidade_litros)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def delete_component_rule(rule_id):
    """Remove uma regra de componente da base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM componentes_regras WHERE id_regra = ?", (rule_id,))
            conn.commit()
        return True, "Componente removido com sucesso."
    except Exception as e:
        return False, f"Erro ao remover componente: {e}"

def add_component_service(cod_equip, componente, data, hod_hor, obs):
    """Adiciona um novo registo de servi√ßo de componente ao hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, Observacoes) VALUES (?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def add_component_service_advanced(cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado=None, obs=""):
    """Adiciona um novo registo de servi√ßo de componente com informa√ß√µes detalhadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def get_component_status(cod_equip, componente):
    """Obt√©m o status atual de um componente espec√≠fico de um equipamento."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            # Buscar a √∫ltima manuten√ß√£o do componente
            query = """
            SELECT Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            ORDER BY Data DESC, Hod_Hor_No_Servico DESC
            LIMIT 1
            """
            df_ultima = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            
            # Buscar a regra do componente para obter o intervalo
            query_regra = """
            SELECT intervalo_padrao, lubrificante_id, tipo_manutencao
            FROM componentes_regras cr
            JOIN frotas f ON cr.classe_operacional = f."Classe Operacional"
            WHERE f.COD_EQUIPAMENTO = ? AND cr.nome_componente = ?
            """
            df_regra = pd.read_sql_query(query_regra, conn, params=(cod_equip, componente))
            
            # Buscar o hod√¥metro/hor√≠metro atual do equipamento
            query_hod = """
            SELECT Hod_Hor_Atual FROM abastecimentos 
            WHERE Cod_Equip = ? 
            ORDER BY Data DESC, Hod_Hor_Atual DESC 
            LIMIT 1
            """
            df_hod = pd.read_sql_query(query_hod, conn, params=(cod_equip,))
            
            return df_ultima, df_regra, df_hod
            
    except Exception as e:
        st.error(f"Erro ao obter status do componente: {e}")
        return None, None, None

def get_component_maintenance_count(cod_equip, componente):
    """Obt√©m o n√∫mero total de manuten√ß√µes realizadas em um componente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT COUNT(*) as total_manutencoes,
                   COUNT(CASE WHEN tipo_servico = 'Troca' THEN 1 END) as total_trocas,
                   COUNT(CASE WHEN tipo_servico = 'Remonta' THEN 1 END) as total_remontas
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            """
            df_count = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            return df_count.iloc[0] if not df_count.empty else {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}
            
    except Exception as e:
        st.error(f"Erro ao obter contagem de manuten√ß√µes: {e}")
        return {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}

def editar_manutencao_componente_advanced(DB_PATH, rowid, dados_editados):
    """Edita uma manuten√ß√£o de componente com informa√ß√µes avan√ßadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_historico 
                SET Cod_Equip = ?, nome_componente = ?, Data = ?, Hod_Hor_No_Servico = ?, 
                    Observacoes = ?, tipo_servico = ?, lubrificante_utilizado = ?
                WHERE rowid = ?
            """, (
                dados_editados['cod_equip'],
                dados_editados['componente'],
                dados_editados['data'],
                dados_editados['hod_hor_servico'],
                dados_editados['acao'],
                dados_editados['tipo_servico'],
                dados_editados['lubrificante_utilizado'],
                rowid
            ))
            conn.commit()
        return True, "Manuten√ß√£o de componente atualizada com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar manuten√ß√£o de componente: {e}"

def update_component_rule(rule_id, nome_componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca"):
    """Atualiza uma regra de componente existente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_regras 
                SET nome_componente = ?, intervalo_padrao = ?, lubrificante_id = ?, tipo_manutencao = ?
                WHERE id_regra = ?
            """, (nome_componente, intervalo, lubrificante_id, tipo_manutencao, rule_id))
            conn.commit()
        return True, f"Componente '{nome_componente}' atualizado com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar componente: {e}"

def get_frota_combustivel(cod_equip):
    """Obt√©m o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tipo_combustivel FROM frotas WHERE COD_EQUIPAMENTO = ?", (cod_equip,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        st.error(f"Erro ao obter tipo de combust√≠vel: {e}")
        return None

def update_frota_combustivel(cod_equip, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE COD_EQUIPAMENTO = ?", (tipo_combustivel, cod_equip))
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel: {e}"

def update_classe_combustivel(classe_operacional, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de todas as frotas de uma classe."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE \"Classe Operacional\" = ?", (tipo_combustivel, classe_operacional))
            rows_updated = cursor.rowcount
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel} em {rows_updated} frotas da classe {classe_operacional}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel da classe: {e}"

def add_tipo_combustivel_column():
    """Adiciona a coluna tipo_combustivel √† tabela frotas se ela n√£o existir."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            # Verificar se a coluna existe
            cursor.execute("PRAGMA table_info(frotas)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'tipo_combustivel' not in columns:
                cursor.execute("ALTER TABLE frotas ADD COLUMN tipo_combustivel TEXT DEFAULT 'Diesel S500'")
                conn.commit()
                return True, "Coluna tipo_combustivel adicionada com sucesso"
            else:
                return True, "Coluna tipo_combustivel j√° existe"
    except Exception as e:
        return False, f"Erro ao adicionar coluna tipo_combustivel: {e}"

def ensure_motoristas_schema():
    """Garante a exist√™ncia da tabela de motoristas e das colunas de v√≠nculo em abastecimentos."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS motoristas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    codigo_pessoa TEXT,
                    matricula TEXT UNIQUE,
                    nome TEXT,
                    ativo TEXT DEFAULT 'ATIVO'
                )
                """
            )
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_matricula ON motoristas(matricula)")
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_codigo_pessoa ON motoristas(codigo_pessoa)")

            cursor.execute("PRAGMA table_info(abastecimentos)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'Matricula' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Matricula TEXT")
            if 'Cod_Pessoa' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Cod_Pessoa TEXT")
            conn.commit()
        return True, "Esquema de motoristas verificado"
    except Exception as e:
        return False, f"Erro ao verificar esquema de motoristas: {e}"

def get_all_motoristas() -> pd.DataFrame:
    """Retorna o DataFrame de motoristas."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM motoristas", conn)
    except Exception:
        return pd.DataFrame(columns=['id', 'codigo_pessoa', 'matricula', 'nome', 'ativo'])

def importar_motoristas_de_planilha(db_path: str, arquivo_carregado):
    """Importa motoristas a partir de planilha Excel. Espera colunas: Matricula, Nome e opcional Cod_Pessoa/C√≥digo Pessoa."""
    try:
        df_mot = pd.read_excel(arquivo_carregado)
        df_mot.columns = [c.strip() for c in df_mot.columns]
        renomeios = {
            'Matr√≠cula': 'Matricula', 'matricula': 'Matricula', 'MATRICULA': 'Matricula',
            'Nome': 'Nome', 'nome': 'Nome', 'NOME': 'Nome',
            'Cod_Pessoa': 'Cod_Pessoa', 'C√≥digo Pessoa': 'Cod_Pessoa', 'codigo_pessoa': 'Cod_Pessoa', 'CODIGO_PESSOA': 'Cod_Pessoa'
        }
        df_mot.rename(columns={k: v for k, v in renomeios.items() if k in df_mot.columns}, inplace=True)
        obrig = ['Matricula', 'Nome']
        faltando = [c for c in obrig if c not in df_mot.columns]
        if faltando:
            return 0, 0, f"Erro: Colunas obrigat√≥rias n√£o encontradas: {', '.join(faltando)}"
        if 'Cod_Pessoa' not in df_mot.columns:
            df_mot['Cod_Pessoa'] = None
        df_mot = df_mot.dropna(subset=['Matricula', 'Nome']).copy()
        df_mot['Matricula'] = df_mot['Matricula'].astype(str).str.strip()
        df_mot['Nome'] = df_mot['Nome'].astype(str).str.strip()
        df_mot['Cod_Pessoa'] = df_mot['Cod_Pessoa'].astype(str).str.strip()
        df_mot = df_mot.drop_duplicates(subset=['Matricula'])
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            existentes = pd.read_sql_query("SELECT matricula FROM motoristas", conn)
            set_exist = set(existentes['matricula'].astype(str)) if not existentes.empty else set()
            df_novos = df_mot[~df_mot['Matricula'].isin(set_exist)].copy()
            if df_novos.empty:
                return 0, len(df_mot), "Nenhum motorista novo para importar. Todos j√° existem."
            registros = [
                (row.get('Cod_Pessoa', None), row['Matricula'], row['Nome'], 'ATIVO')
                for _, row in df_novos.iterrows()
            ]
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO motoristas (codigo_pessoa, matricula, nome, ativo) VALUES (?, ?, ?, ?)",
                registros
            )
            conn.commit()
            inseridos = cur.rowcount if cur.rowcount is not None else len(registros)
            duplicados = len(df_mot) - len(df_novos)
            return inseridos, duplicados, f"{inseridos} motoristas importados com sucesso. {duplicados} j√° existiam."
    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o de motoristas: {e}"
    
def ensure_pneus_schema():
    """Garante a exist√™ncia da tabela de hist√≥rico de pneus."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pneus_historico (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    Cod_Equip INTEGER,
                    posicao TEXT,
                    marca TEXT,
                    modelo TEXT,
                    data_instalacao TEXT,
                    hodometro_instalacao REAL,
                    
                    observacoes TEXT,
                    status TEXT DEFAULT 'Ativo',
                    vida_atual INTEGER DEFAULT 1,
                    numero_fogo TEXT,
                    causa_sucateamento TEXT,
                    data_sucateamento TEXT
                )
            """)
            # Adiciona colunas se n√£o existirem
            cursor.execute("PRAGMA table_info(pneus_historico)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'status' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN status TEXT DEFAULT 'Ativo'")
            if 'vida_atual' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN vida_atual INTEGER DEFAULT 1")
            if 'numero_fogo' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN numero_fogo TEXT")
            if 'causa_sucateamento' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN causa_sucateamento TEXT")
            if 'data_sucateamento' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN data_sucateamento TEXT")
            conn.commit()
        return True, "Tabela de pneus verificada"
    except Exception as e:
        return False, f"Erro ao criar tabela de pneus: {e}"

def importar_pneus_de_planilha(db_path: str, arquivo_carregado):
    """Importa hist√≥rico de pneus de uma planilha Excel, verificando duplicatas."""
    try:
        df_pneus = pd.read_excel(arquivo_carregado)
        df_pneus.columns = [c.strip() for c in df_pneus.columns]
        obrig = ['Cod_Equip', 'posicao', 'marca', 'modelo', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao']
        faltando = [c for c in obrig if c not in df_pneus.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        if 'observacoes' not in df_pneus.columns:
            df_pneus['observacoes'] = ""
        
        
        # Limpar dados e remover linhas com valores nulos obrigat√≥rios
        df_pneus = df_pneus.dropna(subset=['Cod_Equip', 'posicao', 'numero_fogo'])
        
        # Normalizar tipos de dados
        df_pneus['Cod_Equip'] = df_pneus['Cod_Equip'].astype(str)
        df_pneus['posicao'] = df_pneus['posicao'].astype(str).str.strip()
        df_pneus['numero_fogo'] = df_pneus['numero_fogo'].astype(str).str.strip()
        df_pneus['data_instalacao'] = pd.to_datetime(df_pneus['data_instalacao']).dt.strftime('%Y-%m-%d')
        
        # Remover duplicatas na pr√≥pria planilha baseada em chave √∫nica
        df_pneus = df_pneus.drop_duplicates(subset=['Cod_Equip', 'posicao', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Buscar registros existentes para verificar duplicatas
            df_existente = pd.read_sql_query("SELECT Cod_Equip, posicao, numero_fogo, data_instalacao, hodometro_instalacao FROM pneus_historico", conn)
            
            if not df_existente.empty:
                # Normalizar dados existentes para compara√ß√£o
                df_existente['Cod_Equip'] = df_existente['Cod_Equip'].astype(str)
                df_existente['posicao'] = df_existente['posicao'].astype(str).str.strip()
                df_existente['numero_fogo'] = df_existente['numero_fogo'].astype(str).str.strip()
                df_existente['data_instalacao'] = pd.to_datetime(df_existente['data_instalacao']).dt.strftime('%Y-%m-%d')
                
                # Criar chaves √∫nicas para compara√ß√£o
                df_pneus['chave_unica'] = (df_pneus['Cod_Equip'] + '_' + 
                                          df_pneus['posicao'] + '_' + 
                                          df_pneus['numero_fogo'] + '_' + 
                                          df_pneus['data_instalacao'] + '_' + 
                                          df_pneus['hodometro_instalacao'].astype(str))
                
                df_existente['chave_unica'] = (df_existente['Cod_Equip'] + '_' + 
                                              df_existente['posicao'] + '_' + 
                                              df_existente['numero_fogo'] + '_' + 
                                              df_existente['data_instalacao'] + '_' + 
                                              df_existente['hodometro_instalacao'].astype(str))
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_pneus[~df_pneus['chave_unica'].isin(df_existente['chave_unica'])]
            else:
                df_para_inserir = df_pneus
            
            num_duplicados = len(df_pneus) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum pneu novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = obrig + ['observacoes']
            # Garantir que a coluna observacoes exista no DataFrame
            if 'observacoes' not in df_para_inserir.columns:
                df_para_inserir['observacoes'] = ''
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.fillna('').to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO pneus_historico ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} pneus novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar pneus: {e}"

def get_pneus_historico(cod_equip=None):
    """Retorna o hist√≥rico de pneus, opcionalmente filtrando por frota."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            query = "SELECT * FROM pneus_historico"
            params = ()
            if cod_equip:
                query += " WHERE Cod_Equip = ?"
                params = (cod_equip,)
            return pd.read_sql_query(query, conn, params=params)
    except Exception:
        return pd.DataFrame()

def ensure_precos_combustivel_schema():
    """Garante a exist√™ncia da tabela de pre√ßos por tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS precos_combustivel (
                    tipo_combustivel TEXT PRIMARY KEY,
                    preco REAL
                )
                """
            )
            tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
            for t in tipos:
                cur.execute("INSERT OR IGNORE INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?)", (t, NULL))
            conn.commit()
        return True, "Tabela de pre√ßos verificada"
    except Exception as e:
        return False, f"Erro ao verificar tabela de pre√ßos: {e}"

def get_precos_combustivel_map() -> dict:
    """Retorna um dicion√°rio {tipo_combustivel: preco}."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            dfp = pd.read_sql_query("SELECT tipo_combustivel, preco FROM precos_combustivel", conn)
        return {row['tipo_combustivel']: row['preco'] for _, row in dfp.iterrows()}
    except Exception:
        return {}

def upsert_preco_combustivel(tipo: str, preco: float) -> tuple[bool, str]:
    """Cria/atualiza pre√ßo para um tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?) ON CONFLICT(tipo_combustivel) DO UPDATE SET preco=excluded.preco",
                (tipo, preco)
            )
            conn.commit()
        return True, f"Pre√ßo atualizado para {tipo}"
    except Exception as e:
        return False, f"Erro ao atualizar pre√ßo: {e}"
    
def ensure_lubrificantes_schema():
    """Garante a exist√™ncia da tabela de lubrificantes, movimenta√ß√µes e almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            
            # Tabela de lubrificantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT,
                    viscosidade TEXT,
                    quantidade_estoque REAL,
                    unidade TEXT,
                    observacoes TEXT
                )
            """)
            
            # Verificar e adicionar coluna 'tipo' se n√£o existir
            cursor.execute("PRAGMA table_info(lubrificantes)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'tipo' not in cols:
                cursor.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
            
            # Tabela de almoxarifados
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifados (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT NOT NULL,
                    tipo TEXT DEFAULT 'fixo', -- 'fixo' para oficina, 'movel' para caminh√µes
                    localizacao TEXT,
                    responsavel TEXT,
                    observacoes TEXT,
                    ativo BOOLEAN DEFAULT 1
                )
            """)
            
            # Tabela de estoque por almoxarifado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifado_estoque (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_almoxarifado INTEGER,
                    id_lubrificante INTEGER,
                    quantidade_estoque REAL DEFAULT 0,
                    unidade TEXT,
                    data_atualizacao TEXT,
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id),
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    UNIQUE(id_almoxarifado, id_lubrificante)
                )
            """)
            
            # Tabela de movimenta√ß√µes (atualizada para incluir almoxarifado)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes_movimentacoes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_lubrificante INTEGER,
                    id_almoxarifado INTEGER,
                    tipo TEXT, -- 'entrada' ou 'saida'
                    quantidade REAL,
                    data TEXT,
                    cod_equip INTEGER,
                    observacoes TEXT,
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id)
                )
            """)
            
            # Verificar se a coluna id_almoxarifado existe na tabela de movimenta√ß√µes
            cursor.execute("PRAGMA table_info(lubrificantes_movimentacoes)")
            cols_mov = [c[1] for c in cursor.fetchall()]
            if 'id_almoxarifado' not in cols_mov:
                cursor.execute("ALTER TABLE lubrificantes_movimentacoes ADD COLUMN id_almoxarifado INTEGER")
            
            conn.commit()
        return True, "Tabelas de lubrificantes e almoxarifados verificadas"
    except Exception as e:
        return False, f"Erro ao criar tabelas de lubrificantes: {e}"
    
def add_almoxarifado(nome, tipo="fixo", localizacao="", responsavel="", observacoes=""):
    """Adiciona um novo almoxarifado."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO almoxarifados (nome, tipo, localizacao, responsavel, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, tipo, localizacao, responsavel, observacoes)
            )
            conn.commit()
        return True, "Almoxarifado cadastrado com sucesso!"
    except Exception as e:
        return False, f"Erro: {e}"

def get_almoxarifados():
    """Retorna todos os almoxarifados ativos."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            df = pd.read_sql("SELECT * FROM almoxarifados WHERE ativo = 1 ORDER BY nome", conn)
        return df
    except Exception as e:
        return pd.DataFrame()

def get_estoque_por_almoxarifado(id_lubrificante):
    """Retorna o estoque de um lubrificante distribu√≠do por almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT 
                a.nome as almoxarifado,
                a.tipo,
                COALESCE(ae.quantidade_estoque, 0) as quantidade,
                COALESCE(ae.unidade, l.unidade) as unidade,
                a.localizacao,
                a.responsavel
            FROM almoxarifados a
            CROSS JOIN lubrificantes l
            LEFT JOIN almoxarifado_estoque ae ON a.id = ae.id_almoxarifado AND l.id = ae.id_lubrificante
            WHERE l.id = ? AND a.ativo = 1
            ORDER BY a.nome
            """
            df = pd.read_sql(query, conn, params=(id_lubrificante,))
        return df
    except Exception as e:
        return pd.DataFrame()

def atualizar_estoque_almoxarifado(id_almoxarifado, id_lubrificante, quantidade, unidade):
    """Atualiza o estoque de um lubrificante em um almoxarifado espec√≠fico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO almoxarifado_estoque 
                (id_almoxarifado, id_lubrificante, quantidade_estoque, unidade, data_atualizacao) 
                VALUES (?, ?, ?, ?, ?)
            """, (id_almoxarifado, id_lubrificante, quantidade, unidade, date.today().strftime("%Y-%m-%d")))
            conn.commit()
        return True, "Estoque atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao atualizar estoque: {e}"

def add_lubrificante(nome, viscosidade, quantidade, unidade, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes (nome, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, viscosidade, quantidade, unidade, observacoes)
            )
            conn.commit()
        return True, "Lubrificante cadastrado!"
    except Exception as e:
        return False, f"Erro: {e}"

def importar_lubrificantes_de_planilha(db_path: str, arquivo_carregado):
    """Importa lubrificantes de uma planilha Excel, verificando duplicatas."""
    try:
        df_lub = pd.read_excel(arquivo_carregado)
        df_lub.columns = [c.strip() for c in df_lub.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome': 'nome',
            'tipo': 'tipo',
            'viscosidade': 'viscosidade',
            'quantidade_estoque': 'quantidade_estoque',
            'unidade': 'unidade',
            'observacoes': 'observacoes'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_lub.columns:
                df_lub = df_lub.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome']
        faltando = [c for c in obrig if c not in df_lub.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'tipo' not in df_lub.columns:
            df_lub['tipo'] = '√≥leo'
        if 'viscosidade' not in df_lub.columns:
            df_lub['viscosidade'] = ''
        if 'quantidade_estoque' not in df_lub.columns:
            df_lub['quantidade_estoque'] = 0
        if 'unidade' not in df_lub.columns:
            df_lub['unidade'] = 'L'
        if 'observacoes' not in df_lub.columns:
            df_lub['observacoes'] = ''
        
        # Limpar e normalizar dados
        df_lub = df_lub.dropna(subset=['nome'])
        df_lub['nome'] = df_lub['nome'].astype(str).str.strip()
        df_lub['tipo'] = df_lub['tipo'].astype(str).str.strip().fillna('√≥leo')
        df_lub['viscosidade'] = df_lub['viscosidade'].astype(str).str.strip().fillna('')
        df_lub['quantidade_estoque'] = pd.to_numeric(df_lub['quantidade_estoque'], errors='coerce').fillna(0)
        df_lub['unidade'] = df_lub['unidade'].astype(str).str.strip().fillna('L')
        df_lub['observacoes'] = df_lub['observacoes'].astype(str).str.strip().fillna('')
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome
        df_lub = df_lub.drop_duplicates(subset=['nome'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que a tabela existe com a coluna tipo
            ensure_lubrificantes_schema()
            
            # Buscar lubrificantes existentes
            df_existente = pd.read_sql_query("SELECT nome FROM lubrificantes", conn)
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome'] = df_existente['nome'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_lub[~df_lub['nome'].isin(df_existente['nome'])]
            else:
                df_para_inserir = df_lub
            
            num_duplicados = len(df_lub) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum lubrificante novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = ['nome', 'tipo', 'viscosidade', 'quantidade_estoque', 'unidade', 'observacoes']
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO lubrificantes ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} lubrificantes novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar lubrificantes: {e}"

def importar_componentes_de_planilha(db_path: str, arquivo_carregado, classe_operacional: str):
    """Importa componentes de uma planilha Excel, verificando duplicatas e criando lubrificantes se necess√°rio."""
    try:
        df_comp = pd.read_excel(arquivo_carregado)
        df_comp.columns = [c.strip() for c in df_comp.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome_componente': 'nome_componente',
            'componente': 'nome_componente',
            'intervalo_padrao': 'intervalo_padrao',
            'intervalo': 'intervalo_padrao',
            'lubrificante_nome': 'lubrificante_nome',
            'lubrificante': 'lubrificante_nome',
            'capacidade_litros': 'capacidade_litros',
            'capacidade': 'capacidade_litros'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_comp.columns:
                df_comp = df_comp.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome_componente', 'intervalo_padrao']
        faltando = [c for c in obrig if c not in df_comp.columns]
        if faltando:
            return 0, 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'lubrificante_nome' not in df_comp.columns:
            df_comp['lubrificante_nome'] = None
        if 'capacidade_litros' not in df_comp.columns:
            df_comp['capacidade_litros'] = 0.0
        
        # Limpar e normalizar dados
        df_comp = df_comp.dropna(subset=['nome_componente'])
        df_comp['nome_componente'] = df_comp['nome_componente'].astype(str).str.strip()
        df_comp['intervalo_padrao'] = pd.to_numeric(df_comp['intervalo_padrao'], errors='coerce')
        df_comp = df_comp.dropna(subset=['intervalo_padrao'])
        df_comp['lubrificante_nome'] = df_comp['lubrificante_nome'].astype(str).str.strip().replace('nan', None)
        df_comp['capacidade_litros'] = pd.to_numeric(df_comp['capacidade_litros'], errors='coerce').fillna(0.0)
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome do componente
        df_comp = df_comp.drop_duplicates(subset=['nome_componente'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que as tabelas existem
            ensure_lubrificantes_schema()
            
            # Verificar se a tabela componentes_regras tem a coluna capacidade_litros
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'capacidade_litros' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN capacidade_litros REAL DEFAULT 0.0")
            
            # Buscar componentes existentes na classe
            df_existente = pd.read_sql_query(
                "SELECT nome_componente FROM componentes_regras WHERE classe_operacional = ?", 
                conn, params=(classe_operacional,)
            )
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome_componente'] = df_existente['nome_componente'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem na classe
                df_para_inserir = df_comp[~df_comp['nome_componente'].isin(df_existente['nome_componente'])]
            else:
                df_para_inserir = df_comp
            
            num_duplicados = len(df_comp) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, 0, "Nenhum componente novo para importar. Todos os registros da planilha j√° existem na classe selecionada."
            
            # Processar lubrificantes
            lubrificantes_criados = 0
            for _, row in df_para_inserir.iterrows():
                if pd.notna(row['lubrificante_nome']) and row['lubrificante_nome']:
                    # Verificar se o lubrificante existe
                    df_lub_existente = pd.read_sql_query(
                        "SELECT id FROM lubrificantes WHERE nome = ?", 
                        conn, params=(row['lubrificante_nome'],)
                    )
                    
                    if df_lub_existente.empty:
                        # Criar lubrificante automaticamente
                        cur = conn.cursor()
                        cur.execute(
                            "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                            (row['lubrificante_nome'], '√≥leo', '', 0, 'L', f'Criado automaticamente durante importa√ß√£o de componentes')
                        )
                        lubrificantes_criados += 1
                        
                        # Buscar o ID do lubrificante criado
                        lub_id = cur.lastrowid
                    else:
                        lub_id = df_lub_existente.iloc[0]['id']
                else:
                    lub_id = None
                
                # Inserir componente
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, capacidade_litros) VALUES (?, ?, ?, ?, ?)",
                    (classe_operacional, row['nome_componente'], row['intervalo_padrao'], lub_id, row['capacidade_litros'])
                )
            
            conn.commit()
            num_inseridos = len(df_para_inserir)
            
            mensagem_sucesso = f"{num_inseridos} componentes foram importados com sucesso para a classe '{classe_operacional}'."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} componentes duplicados foram ignorados."
            if lubrificantes_criados > 0:
                mensagem_sucesso += f" {lubrificantes_criados} lubrificantes foram criados automaticamente."
            
            return num_inseridos, num_duplicados, lubrificantes_criados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, 0, f"Erro ao importar componentes: {e}"

def movimentar_lubrificante(id_lubrificante, tipo, quantidade, data, cod_equip=None, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes_movimentacoes (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes)
            )
            # Atualiza estoque
            sinal = 1 if tipo == "entrada" else -1
            cur.execute(
                "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque + ? WHERE id = ?",
                (sinal * quantidade, id_lubrificante)
            )
            conn.commit()
        return True, "Movimenta√ß√£o registrada!"
    except Exception as e:
        return False, f"Erro: {e}"

@st.cache_data(ttl=120)
def filtrar_dados(df: pd.DataFrame, opts: dict) -> pd.DataFrame:
    # Garante que a coluna de data √© do tipo datetime
    df['Data'] = pd.to_datetime(df['Data'])
    
    # Filtra por per√≠odo de datas
    df_filtrado = df[
        (df['Data'].dt.date >= opts['data_inicio']) & 
        (df['Data'].dt.date <= opts['data_fim'])
    ]
    
    # Filtra pelas outras sele√ß√µes, se existirem
    if opts.get("classes_op"):
        df_filtrado = df_filtrado[df_filtrado["Classe_Operacional"].isin(opts["classes_op"])]
    
    if opts.get("safras"):
        df_filtrado = df_filtrado[df_filtrado["Safra"].isin(opts["safras"])]
        
    return df_filtrado.copy()

@st.cache_data(show_spinner="Calculando plano de manuten√ß√£o...", ttl=300)
def build_component_maintenance_plan(_df_frotas: pd.DataFrame, _df_abastecimentos: pd.DataFrame, _df_componentes_regras: pd.DataFrame, _df_componentes_historico: pd.DataFrame) -> pd.DataFrame:
    latest_readings = _df_abastecimentos.sort_values('Data').groupby('Cod_Equip')['Hod_Hor_Atual'].last()
    plan_data = []

    for _, frota_row in _df_frotas.iterrows():
        cod_equip = frota_row['Cod_Equip']
        classe_op = frota_row.get('Classe_Operacional')
        hod_hor_atual = latest_readings.get(cod_equip)

        if pd.isna(hod_hor_atual) or not classe_op:
            continue
        
        regras_da_classe = _df_componentes_regras[_df_componentes_regras['classe_operacional'] == classe_op]
        if regras_da_classe.empty:
            continue

        unidade = 'km' if frota_row['Tipo_Controle'] == 'QUIL√îMETROS' else 'h'
        alerta_default = ALERTAS_MANUTENCAO.get(frota_row['Tipo_Controle'], {}).get('default', 500)
        
        record = {
            'Cod_Equip': cod_equip, 
            'Equipamento': frota_row.get('DESCRICAO_EQUIPAMENTO'), 
            'Leitura_Atual': hod_hor_atual, 
            'Unidade': unidade, 
            'Qualquer_Alerta': False, 
            'Alertas': []
        }

        for _, regra in regras_da_classe.iterrows():
            componente = regra['nome_componente']
            intervalo = regra['intervalo_padrao']
            
            historico_componente = _df_componentes_historico[
                (_df_componentes_historico['Cod_Equip'] == cod_equip) &
                (_df_componentes_historico['nome_componente'] == componente)
            ]
            
            ultimo_servico_hod_hor = 0
            if not historico_componente.empty:
                ultimo_servico_hod_hor = historico_componente['Hod_Hor_No_Servico'].max()

            prox_servico = ((ultimo_servico_hod_hor // intervalo) * intervalo) + intervalo
            while prox_servico < hod_hor_atual:
                prox_servico += intervalo

            restante = prox_servico - hod_hor_atual
            
            record[f'Restante_{componente}'] = restante
            
            if restante <= alerta_default:
                record['Qualquer_Alerta'] = True
                record['Alertas'].append(componente)

        plan_data.append(record)

    # üîπ Garante que sempre retorna um DataFrame com as colunas b√°sicas
    if not plan_data:
        return pd.DataFrame(columns=['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Qualquer_Alerta', 'Alertas'])

    return pd.DataFrame(plan_data)

def prever_manutencoes(df_veiculos: pd.DataFrame, df_abastecimentos: pd.DataFrame, plan_df: pd.DataFrame) -> pd.DataFrame:
    """Estima as datas das pr√≥ximas manuten√ß√µes com base no uso m√©dio."""
    if plan_df.empty or 'Leitura_Atual' not in plan_df.columns:
        return pd.DataFrame()

    # Calcula o uso di√°rio m√©dio de cada ve√≠culo
    uso_diario = {}
    for cod_equip in df_abastecimentos['Cod_Equip'].unique():
        dados_equip = df_abastecimentos[df_abastecimentos['Cod_Equip'] == cod_equip].sort_values('Data')
        if len(dados_equip) > 1:
            total_dias = (dados_equip['Data'].max() - dados_equip['Data'].min()).days
            total_uso = dados_equip['Hod_Hor_Atual'].max() - dados_equip['Hod_Hor_Atual'].min()
            if total_dias > 0 and total_uso > 0: # Garante que houve uso e passagem de tempo
                uso_diario[cod_equip] = total_uso / total_dias

    previsoes = []
    servicos_nomes = [col.replace('Restante_', '') for col in plan_df.columns if 'Restante_' in col]

    for _, row in plan_df.iterrows():
        cod_equip = row['Cod_Equip']
        uso = uso_diario.get(cod_equip)
        if uso:
            for nome_servico in servicos_nomes:
                col_restante = f'Restante_{nome_servico}'
                if col_restante in row and pd.notna(row[col_restante]):
                    dias_para_manut = row[col_restante] / uso
                    data_prevista = datetime.now() + pd.Timedelta(days=dias_para_manut)
                    previsoes.append({
                        'Equipamento': row['Equipamento'],
                        'Manuten√ß√£o': nome_servico,
                        'Data Prevista': data_prevista.strftime('%d/%m/%Y'),
                        'Dias Restantes': int(dias_para_manut)
                    })

    if not previsoes:
        return pd.DataFrame()

    df_previsoes = pd.DataFrame(previsoes)
    return df_previsoes.sort_values('Dias Restantes')

# ---------------------------
# Fun√ß√µes para Checklists
# ---------------------------

@st.cache_data(ttl=120)
def get_checklist_rules():
    """Busca todas as regras de checklist do banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM checklist_regras", conn)
    except Exception as e:
        st.error(f"Erro ao buscar regras de checklist: {e}")
        return pd.DataFrame()

@st.cache_data(ttl=120)
def get_checklist_items(id_regra):
    """Busca os itens de checklist para uma determinada regra."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query(
                "SELECT * FROM checklist_itens WHERE id_regra = ?",
                conn,
                params=(id_regra,)
            )
    except Exception as e:
        st.error(f"Erro ao buscar itens de checklist: {e}")
        return pd.DataFrame()

# ---------------------------
# CRUD para Checklists
# ---------------------------

def add_checklist_rule(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra de checklist ao banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
        return True, "Regra de checklist adicionada com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar regra de checklist: {e}"

def add_checklist_rule_and_get_id(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra e devolve o ID criado (ou None em erro).

    Mant√©m a fun√ß√£o "add_checklist_rule" para compatibilidade, mas quando for
    necess√°rio o ID imediatamente ap√≥s a cria√ß√£o, utilize esta fun√ß√£o.
    """
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        st.error(f"Erro ao adicionar regra de checklist: {e}")
        return None

def edit_checklist_rule(id_regra, classe_operacional, titulo_checklist, turno, frequencia):
    """Edita uma regra de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_regras
                SET classe_operacional = ?, titulo_checklist = ?, frequencia = ?, turno = ?
                WHERE id_regra = ?
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno, id_regra)
            )
            conn.commit()
        return True, "Regra de checklist atualizada com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar regra de checklist: {e}"

def delete_checklist_rule(id_regra):
    """Remove uma regra de checklist e seus itens associados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_regra = ?", (id_regra,))
            cursor.execute("DELETE FROM checklist_regras WHERE id_regra = ?", (id_regra,))
            conn.commit()
        return True, "Regra de checklist removida com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover regra de checklist: {e}"

def add_checklist_item(id_regra, nome_item):
    """Adiciona um novo item de checklist a uma regra existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_itens (id_regra, nome_item)
                VALUES (?, ?)
                """ ,
                (id_regra, nome_item)
            )
            conn.commit()
        return True, "Item de checklist adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar item de checklist: {e}"

def edit_checklist_item(id_item, nome_item):
    """Edita um item de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_itens
                SET nome_item = ?
                WHERE id_item = ?
                """ ,
                (nome_item, id_item)
            )
            conn.commit()
        return True, "Item de checklist atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar item de checklist: {e}"

def delete_checklist_item(id_item):
    """Remove um item de checklist."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_item = ?", (id_item,))
            conn.commit()
        return True, "Item de checklist removido com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover item de checklist: {e}"

def save_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno, status_geral):
    """Salva um checklist preenchido no hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_historico 
                (Cod_Equip, titulo_checklist, data_preenchimento, turno, status_geral) 
                VALUES (?, ?, ?, ?, ?)
                """ ,
                (cod_equip, titulo_checklist, data_preenchimento, turno, status_geral)
            )
            conn.commit()
    except Exception as e:
        st.error(f"Erro ao salvar hist√≥rico de checklist: {e}")

def delete_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno):
    """Remove um registro do hist√≥rico de checklists usando uma combina√ß√£o √∫nica de campos."""
    try:
        # Primeira tentativa: usar conex√£o direta
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)  # Converter numpy.int64 para int
        titulo_checklist = str(titulo_checklist)
        data_preenchimento = str(data_preenchimento)
        turno = str(turno)
        
        # Debug: verificar todos os registros na tabela ANTES da exclus√£o
        cursor.execute("SELECT rowid, Cod_Equip, titulo_checklist, data_preenchimento, turno FROM checklist_historico")
        all_records_before = cursor.fetchall()
        
        # Tentar encontrar o registro com diferentes abordagens
        rowid = None
        
        # Primeira tentativa: busca exata
        cursor.execute(
            "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
            (cod_equip, titulo_checklist, data_preenchimento, turno)
        )
        result = cursor.fetchone()
        
        if result:
            rowid = result[0]
        else:
            # Segunda tentativa: buscar apenas por Cod_Equip, t√≠tulo e turno (ignorar data)
            cursor.execute(
                "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND turno = ?", 
                (cod_equip, titulo_checklist, turno)
            )
            result = cursor.fetchone()
            
            if result:
                rowid = result[0]
            else:
                # Terceira tentativa: buscar apenas por Cod_Equip e t√≠tulo
                cursor.execute(
                    "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ?", 
                    (cod_equip, titulo_checklist)
                )
                result = cursor.fetchone()
                
                if result:
                    rowid = result[0]
        
        if rowid is None:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - T√≠tulo: {titulo_checklist} (tipo: {type(titulo_checklist)})
            - Data: {data_preenchimento} (tipo: {type(data_preenchimento)})
            - Turno: {turno} (tipo: {type(turno)})
            
            Todos os registros na tabela ANTES da exclus√£o:
            {all_records_before}
            """
            conn.close()
            return False, debug_info
        
        # Agora vamos excluir usando rowid
        cursor.execute("DELETE FROM checklist_historico WHERE rowid = ?", (rowid,))
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute("SELECT COUNT(*) FROM checklist_historico WHERE rowid = ?", (rowid,))
            count_after = cursor.fetchone()[0]
            
            # Verificar tamb√©m se o registro ainda existe pelos outros campos
            cursor.execute(
                "SELECT COUNT(*) FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
                (cod_equip, titulo_checklist, data_preenchimento, turno)
            )
            count_by_fields = cursor.fetchone()[0]
            
            if count_after == 0 and count_by_fields == 0:
                 # Verificar o total de registros na tabela
                 cursor.execute("SELECT COUNT(*) FROM checklist_historico")
                 total_after = cursor.fetchone()[0]
                 
                 # For√ßar sincroniza√ß√£o do banco
                 cursor.execute("PRAGMA wal_checkpoint(FULL)")
                 cursor.execute("PRAGMA synchronous=FULL")
                 conn.commit()
                 
                 success_msg = f"Checklist exclu√≠do com sucesso! ({rows_deleted} registro(s) removido(s)). Total na tabela: {total_after}"
                 
                 # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                 backup_success, backup_msg = save_backup_to_session_state()
                 if backup_success:
                     success_msg += f" | Backup salvo: {backup_msg}"
                 else:
                     success_msg += f" | Aviso: {backup_msg}"
                 
                 conn.close()
                 return True, success_msg
            else:
                conn.close()
                return False, f"Erro: Registro ainda existe ap√≥s exclus√£o. Count by rowid: {count_after}, Count by fields: {count_by_fields}"
        else:
            conn.close()
            return False, "Nenhum registro foi exclu√≠do"
                
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return False, f"Erro ao excluir checklist: {e}"

def force_cache_clear():
    """For√ßa a limpeza completa de todos os caches."""
    try:
        # Limpar cache de dados
        st.cache_data.clear()
        
        # Limpar cache de recursos
        st.cache_resource.clear()
        
        # For√ßar rerun da aplica√ß√£o
        st.rerun()
    except Exception as e:
        st.error(f"Erro ao limpar cache: {e}")

def force_database_sync():
    """For√ßa a sincroniza√ß√£o do banco de dados com o disco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # For√ßar commit
        conn.commit()
        
        # Executar PRAGMA para for√ßar sincroniza√ß√£o
        cursor.execute("PRAGMA wal_checkpoint(FULL)")
        cursor.execute("PRAGMA synchronous=FULL")
        cursor.execute("PRAGMA journal_mode=DELETE")
        
        # For√ßar commit novamente
        conn.commit()
        
        # Verificar se o banco est√° em modo WAL
        cursor.execute("PRAGMA journal_mode")
        journal_mode = cursor.fetchone()[0]
        
        conn.close()
        
        return True, f"Banco sincronizado. Modo journal: {journal_mode}"
    except Exception as e:
        return False, f"Erro ao sincronizar banco: {e}"

def export_database_backup():
    """Exporta todos os dados do banco para um arquivo de backup."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        
        # Obter todas as tabelas
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        backup_data = {}
        
        for table in tables:
            table_name = table[0]
            if table_name != 'sqlite_master':
                # Exportar dados da tabela
                df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
                backup_data[table_name] = df.to_dict('records')
        
        conn.close()
        
        # Converter para JSON
        backup_json = json.dumps(backup_data, default=str, indent=2)
        
        # Criar arquivo de download
        backup_bytes = backup_json.encode('utf-8')
        backup_b64 = base64.b64encode(backup_bytes).decode()
        
        return backup_b64, backup_data
        
    except Exception as e:
        return None, f"Erro ao exportar backup: {e}"

def import_database_backup(backup_data):
    """Importa dados de backup para o banco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        for table_name, records in backup_data.items():
            if records:  # Se a tabela tem dados
                # Limpar tabela existente
                cursor.execute(f"DELETE FROM {table_name}")
                
                # Inserir novos dados
                for record in records:
                    columns = list(record.keys())
                    placeholders = ', '.join(['?' for _ in columns])
                    values = list(record.values())
                    
                    # Converter tipos de dados
                    converted_values = []
                    for value in values:
                        if isinstance(value, str):
                            # Tentar converter para datetime se for uma data
                            try:
                                if 'T' in value or '-' in value:
                                    dt = pd.to_datetime(value)
                                    converted_values.append(dt.strftime('%Y-%m-%d %H:%M:%S'))
                                else:
                                    converted_values.append(value)
                            except:
                                converted_values.append(value)
                        else:
                            converted_values.append(value)
                    
                    cursor.execute(
                        f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})",
                        converted_values
                    )
        
        conn.commit()
        conn.close()
        
        return True, "Backup restaurado com sucesso!"
        
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def save_backup_to_session_state():
    """Salva backup dos dados na sess√£o do Streamlit."""
    try:
        backup_b64, backup_data = export_database_backup()
        if backup_b64:
            st.session_state['database_backup'] = backup_b64
            st.session_state['backup_timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return True, "Backup salvo na sess√£o"
        else:
            return False, "Erro ao criar backup"
    except Exception as e:
        return False, f"Erro ao salvar backup: {e}"

def restore_backup_from_session_state():
    """Restaura backup dos dados da sess√£o do Streamlit."""
    try:
        if 'database_backup' in st.session_state:
            backup_b64 = st.session_state['database_backup']
            backup_bytes = base64.b64decode(backup_b64)
            backup_json = backup_bytes.decode('utf-8')
            backup_data = json.loads(backup_json)
            
            success, message = import_database_backup(backup_data)
            if success:
                # Limpar cache para for√ßar recarregamento
                force_cache_clear()
                return True, message
            else:
                return False, message
        else:
            return False, "Nenhum backup encontrado na sess√£o"
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def auto_restore_backup_on_startup():
    """Tenta restaurar backup automaticamente na inicializa√ß√£o da aplica√ß√£o."""
    try:
        if 'database_backup' in st.session_state:
            # Verificar se o banco est√° vazio
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
            num_tables = cursor.fetchone()[0]
            conn.close()
            
            if num_tables == 0:
                # Banco vazio, tentar restaurar
                success, message = restore_backup_from_session_state()
                if success:
                    st.info("üîÑ Backup restaurado automaticamente na inicializa√ß√£o!")
                    return True
                else:
                    st.warning(f"‚ö†Ô∏è Falha na restaura√ß√£o autom√°tica: {message}")
                    return False
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na restaura√ß√£o autom√°tica: {e}")
        return False

def main():
    
    # Garante tema dark coerente mesmo sem config.toml
    st.markdown(
        """
        <style>
        :root {
            --primary: #10b981;
            --bg: #0f172a;
            --bg2: #111827;
            --text: #e5e7eb;
        }
        body { background: var(--bg); color: var(--text); }
        section.main > div { background: var(--bg); }
        .stApp { background: var(--bg); }
        .st-emotion-cache-1r4qj8v, .st-emotion-cache-13ln4jf { background: var(--bg2) !important; }
        .stButton>button { background: var(--primary); color: #062e24; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    # CSS fino para polir a UI
    st.markdown(
        """
        <style>
        /* Cart√µes/containers */
        .stExpander, .stDataFrame, .stTable { border-radius: 10px !important; }
        .stButton>button { border-radius: 8px; padding: 0.5rem 1rem; }
        .stSelectbox, .stTextInput, .stNumberInput, .stDateInput, .stTextArea { border-radius: 8px !important; }
        /* M√©tricas com mais destaque */
        div[data-testid="stMetric"] { background: rgba(255,255,255,0.04); padding: 10px 14px; border-radius: 12px; }
        /* T√≠tulos com leve gradiente */
        h1, h2, h3 { background: linear-gradient(90deg, #10b981 0%, #06b6d4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        /* Linhas divis√≥rias mais suaves */
        hr { border: none; height: 1px; background: rgba(255,255,255,0.08); }
        /* Subt√≠tulo de marca (opcional) */
        .brand-subtitle { display: none; }
        /* Centralizar e limitar logo na sidebar */
        section[data-testid="stSidebar"] img { display: block; margin: 0.5rem auto 0.75rem; max-width: 140px; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
        st.session_state.role = None
        st.session_state.username = ""

    if not st.session_state.authenticated:
        _ , col_central, _ = st.columns([1, 1.5, 1])
    
        with col_central:
            
            if os.path.exists("logo.png"):
                # Cria 3 sub-colunas dentro da coluna central
                _, logo_col, _ = st.columns([1, 2, 1])
                with logo_col:
                    st.image("logo.png", width=140)
            
            st.title("Bem vindo ao Aplicativo de Controle do PCMA")

            username = st.text_input("Usu√°rio", key="login_user")
            password = st.text_input("Senha", type="password", key="login_pass")

            if st.button("Entrar", use_container_width=True):
                role = check_login_db(username, password)
                if role:
                    st.session_state.authenticated = True
                    st.session_state.role = role
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("Usu√°rio ou Senha incorretos.")
    else:

        # Cabe√ßalho com logo + t√≠tulo
        if os.path.exists("logo.png"):
            col_logo, col_title = st.columns([1, 8])
            with col_logo:
                st.image("logo.png", width=80)
            with col_title:
                st.title("üìä Dashboard de Frotas e Abastecimentos")
        else:
            st.title("üìä Dashboard de Frotas e Abastecimentos")

        # Tentar restaurar backup automaticamente na inicializa√ß√£o
        auto_restore_backup_on_startup()
        
        # Adicionar coluna de tipo de combust√≠vel se n√£o existir
        add_tipo_combustivel_column()
        
        # Setup de esquemas (motoristas, pre√ßos, combust√≠vel)
        ensure_motoristas_schema()
        ensure_precos_combustivel_schema()

        # Passo um fingerprint simples das tabelas para invalidar cache quando necess√°rio
        ver_frotas = int(os.path.getmtime(DB_PATH)) if os.path.exists(DB_PATH) else 0
        df, df_frotas, df_manutencoes, df_comp_regras, df_comp_historico, df_checklist_regras, df_checklist_itens, df_checklist_historico = load_data_from_db(DB_PATH, ver_frotas, ver_frotas, ver_frotas, ver_frotas, ver_frotas)
        

        if 'intervalos_por_classe' not in st.session_state:
            st.session_state.intervalos_por_classe = {}
        classes_operacionais = [c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()]
        for classe in classes_operacionais:
            if classe not in st.session_state.intervalos_por_classe:
                tipo_controle = df_frotas[df_frotas['Classe_Operacional'] == classe]['Tipo_Controle'].iloc[0]
                if tipo_controle == 'HORAS':
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 5.0,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 250},
                            'servico_2': {'nome': 'Revisao A', 'intervalo': 100},
                            'servico_3': {'nome': 'Revisao B', 'intervalo': 300},
                            'servico_4': {'nome': 'Revisao C', 'intervalo': 500}
                        }
                    }
                else: # QUIL√îMETROS
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 2.5,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 5000},
                            'servico_2': {'nome': 'Revisao 5k', 'intervalo': 5000},
                            'servico_3': {'nome': 'Revisao 10k', 'intervalo': 10000},
                            'servico_4': {'nome': 'Revisao 20k', 'intervalo': 20000}
                        }
                    }
                    
        with st.sidebar:
            if os.path.exists("logo.png"):
                st.image("logo.png", width=200)
            st.write(f"Bem-vindo, **{st.session_state.username}**!")
            if st.button("Sair"):
                st.session_state.authenticated = False
                st.session_state.username = "" # Limpa o username ao sair
                st.session_state.role = None
                st.rerun()
            st.markdown("---")

        with st.sidebar:
            st.header("üìÖ Filtros (v√°lidos apenas na aba An√°lise Geral)")

            # Persist√™ncia de per√≠odo
            if 'filtro_data_inicio' not in st.session_state:
                st.session_state['filtro_data_inicio'] = df['Data'].min().date()
            if 'filtro_data_fim' not in st.session_state:
                st.session_state['filtro_data_fim'] = df['Data'].max().date()

            st.subheader("Per√≠odo de An√°lise")
            data_inicio = st.date_input(
                "Data de In√≠cio", 
                st.session_state['filtro_data_inicio'],
                key='data_inicio'
            )
            data_fim = st.date_input(
                "Data de Fim", 
                st.session_state['filtro_data_fim'],
                key='data_fim'
            )
            st.session_state['filtro_data_inicio'] = data_inicio
            st.session_state['filtro_data_fim'] = data_fim

            st.markdown("---")
            st.caption("Desenvolvido por Andr√© Luis")

            with st.expander("Filtrar por Classe Operacional"):
                classe_opts = sorted(list(df["Classe_Operacional"].dropna().unique()))
                sel_classes = st.multiselect(
                    "Selecione as Classes", 
                    classe_opts, 
                    default=classe_opts,
                    key="sel_classes"
                )

            with st.expander("Filtrar por Safra"):
                safra_opts = sorted(list(df["Safra"].dropna().unique()))
                sel_safras = st.multiselect(
                    "Selecione as Safras", 
                    safra_opts, 
                    default=safra_opts,
                    key="sel_safras"
                )

            # S√≥ aplicaremos os filtros na aba "üìà An√°lise Geral" (guardaremos em sess√£o)
            st.session_state['filtro_opts_analise'] = {
                "data_inicio": data_inicio,
                "data_fim": data_fim,
                "classes_op": sel_classes,
                "safras": sel_safras
            }
    
        if tab_analise is not None:
            with tab_analise:
                st.header("üìà An√°lise Geral e Painel de Controle")
                
                # ===== SE√á√ÉO: VIS√ÉO GERAL DA FROTA =====
                st.subheader("üè† Vis√£o Geral da Frota")
                
                # Calcular gasto total com combust√≠vel
                precos_map = get_precos_combustivel_map()
                gasto_total_combustivel = 0
                if precos_map:
                    df_gastos_total = df.copy()
                    # Verificar se a coluna tipo_combustivel existe em df_frotas
                    if 'tipo_combustivel' in df_frotas.columns:
                        df_gastos_total = df_gastos_total.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                        # Verificar se a coluna foi criada ap√≥s o merge
                        if 'tipo_combustivel' in df_gastos_total.columns:
                            df_gastos_total['tipo_combustivel'] = df_gastos_total['tipo_combustivel'].fillna('Diesel S500')
                        else:
                            df_gastos_total['tipo_combustivel'] = 'Diesel S500'
                    else:
                        # Se n√£o existir, criar a coluna com valor padr√£o
                        df_gastos_total['tipo_combustivel'] = 'Diesel S500'
                    
                    df_gastos_total['preco_unit'] = df_gastos_total['tipo_combustivel'].map(precos_map).fillna(0.0)
                    df_gastos_total['custo'] = df_gastos_total['Qtde Litros'].fillna(0.0) * df_gastos_total['preco_unit']
                    gasto_total_combustivel = df_gastos_total['custo'].sum()
                
                # KPIs principais
                kpi1, kpi2, kpi3, kpi4, kpi5 = st.columns(5)
                
                # KPI 1: Frotas Ativas
                total_frotas_ativas = df_frotas[df_frotas['ATIVO'] == 'ATIVO']['Cod_Equip'].nunique()
                kpi1.metric("üöó Frotas Ativas", total_frotas_ativas)
                
                # KPI 2: Frotas com Alerta
                frotas_com_alerta = plan_df[plan_df['Qualquer_Alerta'] == True]['Cod_Equip'].nunique() if not plan_df.empty else 0
                kpi2.metric("‚ö†Ô∏è Frotas com Alerta", frotas_com_alerta)
                
                # KPI 3: Gasto Total com Combust√≠vel
                kpi3.metric("üí∞ Gasto com Combust√≠vel", formatar_brasileiro(gasto_total_combustivel, 'R$ '))
                
                # KPIs 4 e 5: Frotas Mais e Menos Eficientes
                df_sem_filtro = df.copy()
                df_media_geral = df_sem_filtro[(df_sem_filtro['Media'].notna()) & (df_sem_filtro['Media'] > 0)]
                if not df_media_geral.empty:
                    # Agrupa por C√≥digo e Descri√ß√£o para ter acesso a ambos
                    media_por_equip = df_media_geral.groupby(['Cod_Equip', 'DESCRICAO_EQUIPAMENTO'])['Media'].mean().sort_values()
                    
                    if not media_por_equip.empty:
                        # Pega o C√ìDIGO do mais eficiente (primeiro da lista ordenada)
                        cod_mais_eficiente = media_por_equip.index[0][0]
                        media_mais_eficiente = media_por_equip.iloc[0]
                        # Exibe o C√ìDIGO no KPI
                        kpi4.metric("üèÜ Mais Eficiente", f"{cod_mais_eficiente}", f"{formatar_brasileiro(media_mais_eficiente)}")
                
                        # Pega o C√ìDIGO do menos eficiente (√∫ltimo da lista ordenada)
                        cod_menos_eficiente = media_por_equip.index[-1][0]
                        media_menos_eficiente = media_por_equip.iloc[-1]
                        # Exibe o C√ìDIGO no KPI
                        kpi5.metric("üìâ Menos Eficiente", f"{cod_menos_eficiente}", f"{formatar_brasileiro(media_menos_eficiente)}")
                else:
                    # Se n√£o h√° dados de efici√™ncia, mostrar mensagem
                    kpi4.metric("üèÜ Mais Eficiente", "N/A")
                    kpi5.metric("üìâ Menos Eficiente", "N/A")

                st.markdown("---")
                st.subheader("üìà An√°lise Gr√°fica de Consumo")

                # Aplica filtros apenas nesta aba
                opts = st.session_state.get('filtro_opts_analise', None)
                df_f = filtrar_dados(df, opts) if opts else df.copy()

                if not df_f.empty:
                    # KPIs melhorados com an√°lise por tipo de combust√≠vel
                    st.subheader("üìä Indicadores de Consumo por Combust√≠vel")
                    
                    # Obter tipos de combust√≠vel das frotas
                    if 'tipo_combustivel' in df_frotas.columns:
                        # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                        df_f_com_consumo = df_f[df_f['Qtde Litros'] > 0].copy()
                        
                        if not df_f_com_consumo.empty:
                            # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                            equipamentos_com_consumo = df_f_com_consumo['Cod_Equip'].unique()
                            
                            # Filtrar df_frotas para incluir apenas equipamentos com consumo
                            frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                            
                            # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                            if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                            
                            # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                            combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                            
                            # Aplicar o mapeamento apenas aos registros com consumo
                            df_f_com_consumo['tipo_combustivel'] = df_f_com_consumo['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                            
                            # Calcular consumo por tipo de combust√≠vel
                            consumo_por_combustivel = df_f_com_consumo.groupby('tipo_combustivel')['Qtde Litros'].sum().sort_values(ascending=False)
                        else:
                            # Se n√£o h√° registros com consumo, criar um DataFrame vazio
                            consumo_por_combustivel = pd.Series(dtype='float64')
                        
                        # Criar colunas din√¢micas baseadas no n√∫mero de tipos de combust√≠vel
                        num_tipos = len(consumo_por_combustivel)
                        if num_tipos <= 2:
                            cols = st.columns(2)
                        elif num_tipos <= 3:
                            cols = st.columns(3)
                        elif num_tipos <= 4:
                            cols = st.columns(4)
                        else:
                            cols = st.columns(5)
                        
                        # Exibir KPIs por tipo de combust√≠vel
                        for i, (tipo, litros) in enumerate(consumo_por_combustivel.items()):
                            if i < len(cols):
                                with cols[i]:
                                    # Calcular percentual do total
                                    percentual = (litros / df_f["Qtde Litros"].sum()) * 100
                                    
                                    # Definir cor baseada no tipo de combust√≠vel
                                    if 'Diesel S500' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Diesel S10' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Gasolina' in tipo:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    elif 'Etanol' in tipo:
                                        delta_color = "normal"
                                        icon = "üå±"
                                    elif 'Biodiesel' in tipo:
                                        delta_color = "normal"
                                        icon = "üåø"
                                    else:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    
                                    cols[i].metric(
                                        f"{icon} {tipo}",
                                        f"{formatar_brasileiro_int(litros)} L",
                                        f"{percentual:.1f}% do total",
                                        delta_color=delta_color
                                    )
                        
                        # Adicionar linha separadora
                        st.markdown("---")
                        
                        # KPI adicional: Total geral e m√©dia por equipamento
                        k1, k2, k3 = st.columns(3)
                        
                        with k1:
                            total_litros = df_f["Qtde Litros"].sum()
                            k1.metric(
                                "üõ¢Ô∏è Total Geral",
                                f"{formatar_brasileiro_int(total_litros)} L",
                                f"{len(consumo_por_combustivel)} tipos de combust√≠vel"
                            )
                        
                        with k2:
                            if 'Media' in df_f.columns:
                                media_geral = df_f['Media'].mean()
                                k2.metric(
                                    "üìà M√©dia Geral",
                                    f"{formatar_brasileiro(media_geral)}",
                                    "M√©dia de consumo por equipamento"
                                )
                            else:
                                # Calcular m√©dia manual se n√£o existir coluna Media
                                equipamentos_unicos = df_f['Cod_Equip'].nunique()
                                if equipamentos_unicos > 0:
                                    media_manual = total_litros / equipamentos_unicos
                                    k2.metric(
                                        "üìà M√©dia por Equipamento",
                                        f"{formatar_brasileiro(media_manual)} L",
                                        f"{equipamentos_unicos} equipamentos"
                                    )
                                else:
                                    k2.metric("üìà M√©dia por Equipamento", "N/A")
                        
                        with k3:
                            # Calcular efici√™ncia (litros por dia se houver dados de data)
                            if 'Data' in df_f.columns:
                                try:
                                    df_f['Data'] = pd.to_datetime(df_f['Data'])
                                    dias_periodo = (df_f['Data'].max() - df_f['Data'].min()).days + 1
                                    if dias_periodo > 0:
                                        litros_por_dia = total_litros / dias_periodo
                                        k3.metric(
                                            "üìÖ Consumo Di√°rio",
                                            f"{formatar_brasileiro(litros_por_dia)} L/dia",
                                            f"{dias_periodo} dias analisados"
                                        )
                                    else:
                                        k3.metric("üìÖ Consumo Di√°rio", "N/A")
                                except:
                                    k3.metric("üìÖ Consumo Di√°rio", "N/A")
                            else:
                                k3.metric("üìÖ Consumo Di√°rio", "N/A")
                    else:
                        # Fallback se n√£o houver coluna tipo_combustivel
                        k1, k2 = st.columns(2)
                        k1.metric("Litros Consumidos (per√≠odo)", formatar_brasileiro_int(df_f["Qtde Litros"].sum()))
                        if 'Media' in df_f.columns:
                            k2.metric("M√©dia Consumo (per√≠odo)", f"{formatar_brasileiro(df_f['Media'].mean())}")
                        else:
                            equipamentos_unicos = df_f['Cod_Equip'].nunique()
                            if equipamentos_unicos > 0:
                                media_manual = df_f["Qtde Litros"].sum() / equipamentos_unicos
                                k2.metric("M√©dia por Equipamento", f"{formatar_brasileiro(media_manual)} L")
                    st.markdown("---")
                    st.subheader("üìä An√°lise de Consumo por Classe e Equipamentos")
                    c1, c2 = st.columns(2)

                    with c1:
                        st.subheader("Consumo por Classe Operacional")
                        classes_a_excluir = ['VEICULOS LEVES', 'MOTOCICLETA', 'MINI CARREGADEIRA', 'USINA']
                        # Verificar se a coluna Classe_Operacional existe antes de filtrar
                        if 'Classe_Operacional' in df_f.columns:
                            df_consumo_classe = df_f[~df_f['Classe_Operacional'].str.upper().isin(classes_a_excluir)]
                        else:
                            df_consumo_classe = df_f
                        consumo_por_classe = df_consumo_classe.groupby("Classe_Operacional")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()

                        if not consumo_por_classe.empty:
                            consumo_por_classe['texto_formatado'] = consumo_por_classe['Qtde Litros'].apply(formatar_brasileiro_int)
                            fig_classe = px.bar(consumo_por_classe, x='Qtde Litros', y='Classe_Operacional', orientation='h', text='texto_formatado', labels={"x": "Litros Consumidos", "y": "Classe Operacional"})
                            fig_classe.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_classe.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Classe Operacional",
                                height=500,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=12)
                            )
                            st.plotly_chart(fig_classe, use_container_width=True)

                    with c2:
                        st.subheader("Top 10 Equipamentos com Maior Consumo")
                        # Melhorar o gr√°fico com informa√ß√µes mais claras
                        consumo_por_equip = df_f.groupby("Cod_Equip").agg({'Qtde Litros': 'sum'}).dropna()
                        consumo_por_equip = consumo_por_equip[consumo_por_equip.index != 550]
                        consumo_por_equip = consumo_por_equip.sort_values(by="Qtde Litros", ascending=False).head(10)

                        if not consumo_por_equip.empty:
                            # Adicionar informa√ß√µes da frota para melhor identifica√ß√£o
                            consumo_por_equip = consumo_por_equip.reset_index()
                            consumo_por_equip = consumo_por_equip.merge(
                                df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                                on='Cod_Equip', 
                                how='left'
                            )
                            
                            # Criar label mais informativo: C√≥digo - Descri√ß√£o (Placa)
                            consumo_por_equip['label_grafico'] = consumo_por_equip.apply(
                                lambda row: f"{row['Cod_Equip']} - {row['DESCRICAO_EQUIPAMENTO'][:30]}{'...' if len(str(row['DESCRICAO_EQUIPAMENTO'])) > 30 else ''} ({row['PLACA']})", 
                                axis=1
                            )
                            
                            consumo_por_equip['texto_formatado'] = consumo_por_equip['Qtde Litros'].apply(formatar_brasileiro_int)
                            
                            fig_top10 = px.bar(
                                consumo_por_equip, 
                                x='Qtde Litros', 
                                y='label_grafico', 
                                orientation='h', 
                                text='texto_formatado', 
                                labels={"Qtde Litros": "Total Consumido (Litros)", "label_grafico": "Equipamento"},
                                title="Top 10 Equipamentos com Maior Consumo"
                            )
                            fig_top10.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                marker_color='#ff7f0e',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_top10.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Equipamento",
                                height=600,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=11)
                            )
                            st.plotly_chart(fig_top10, use_container_width=True)

                    st.markdown("---")
                    
                    # NOVA SE√á√ÉO: Top 10 de Gastos por Frota e por Classe
                    st.subheader("üí∞ Top 10 de Gastos por Frota e Classe")
                    
                    # Calcular gastos por frota
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        df_gastos = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_gastos = df_gastos.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_gastos.columns:
                                df_gastos['tipo_combustivel'] = df_gastos['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_gastos['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_gastos.columns:
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        df_gastos['preco_unit'] = df_gastos['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_gastos['custo'] = df_gastos['Qtde Litros'].fillna(0.0) * df_gastos['preco_unit']
                        
                        # Adicionar informa√ß√µes da frota para filtro
                        df_gastos_com_info = df_gastos.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA', 'Classe_Operacional']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        
                        # Garantir que a coluna Classe_Operacional existe
                        if 'Classe_Operacional' not in df_gastos_com_info.columns:
                            df_gastos_com_info['Classe_Operacional'] = 'N/A'
                        
                        # Filtro para excluir a frota 550 (usina) por padr√£o
                        mostrar_usinas = st.checkbox("üè≠ Incluir Frota 550 (Usina) no Top 10 de Gastos por Frota", value=False)
                        
                        if not mostrar_usinas:
                            # Excluir a frota 550 (usina) do DataFrame
                            df_gastos_filtrado = df_gastos_com_info[df_gastos_com_info['Cod_Equip'] != 550]
                        else:
                            df_gastos_filtrado = df_gastos_com_info
                        
                        # Top 10 gastos por frota individual (ap√≥s filtro)
                        gastos_por_frota = df_gastos_filtrado.groupby('Cod_Equip').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        
                        # Adicionar informa√ß√µes da frota
                        gastos_por_frota = gastos_por_frota.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        gastos_por_frota['label_frota'] = gastos_por_frota['Cod_Equip'].astype(str)
                        gastos_por_frota['custo_formatado'] = gastos_por_frota['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Top 10 gastos por classe operacional
                        gastos_por_classe = df_gastos.groupby('Classe_Operacional').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        gastos_por_classe['custo_formatado'] = gastos_por_classe['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Criar layout em 2 colunas para os gr√°ficos
                        col_gastos1, col_gastos2 = st.columns(2)
                        
                        with col_gastos1:
                            st.subheader("üè≠ Top 10 Gastos por Frota")
                            
                            # Mostrar informa√ß√£o sobre filtro da frota 550
                            # Coment√°rio removido para manter propor√ß√£o dos gr√°ficos
                            
                            if not gastos_por_frota.empty:
                                # Garantir que os dados est√£o corretos
                                gastos_por_frota['custo'] = gastos_por_frota['custo'].fillna(0)
                                gastos_por_frota = gastos_por_frota[gastos_por_frota['custo'] > 0]
                                
                                if not gastos_por_frota.empty:
                                    # Dados j√° validados e prontos para o gr√°fico
                                    
                                    # Garantir que label_frota √© string e √∫nico
                                    gastos_por_frota['label_frota'] = gastos_por_frota['label_frota'].astype(str)
                                    
                                    # Criar gr√°fico de barras horizontais com dados limpos
                                    fig_gastos_frota = px.bar(
                                        gastos_por_frota,
                                        x='custo',
                                        y='label_frota',
                                        orientation='h',
                                        text='custo_formatado',
                                        title="Gastos por Frota Individual",
                                        labels={'custo': 'Custo (R$)', 'label_frota': 'Frota'},
                                        color='custo',
                                        color_continuous_scale='Reds'
                                    )
                                    fig_gastos_frota.update_traces(
                                        textposition='outside',
                                        texttemplate='%{text}',
                                        textfont=dict(size=11, color='white'),
                                        cliponaxis=False,
                                        marker=dict(line=dict(width=1, color='black'))
                                    )
                                    fig_gastos_frota.update_layout(
                                        yaxis={'categoryorder':'total ascending'},
                                        xaxis_title="Custo Total (R$)",
                                        yaxis_title="Frota",
                                        height=600,
                                        showlegend=False,
                                        margin=dict(l=20, r=20, t=40, b=20),
                                        font=dict(size=12),
                                        bargap=0.3,
                                        bargroupgap=0.1
                                    )
                                    # Configurar eixo Y para mostrar todas as categorias
                                    fig_gastos_frota.update_yaxes(
                                        type='category',
                                        categoryorder='total ascending'
                                    )
                                    st.plotly_chart(fig_gastos_frota, use_container_width=True)
                                    
                                    # Gr√°fico criado com sucesso
                                else:
                                    st.warning("N√£o h√° frotas com gastos maiores que zero.")
                            else:
                                st.info("N√£o h√° dados de gastos por frota.")
                        
                        with col_gastos2:
                            st.subheader("üèóÔ∏è Top 10 Gastos por Classe")
                            if not gastos_por_classe.empty:
                                fig_gastos_classe = px.bar(
                                    gastos_por_classe,
                                    x='custo',
                                    y='Classe_Operacional',
                                    orientation='h',
                                    text='custo_formatado',
                                    title="Gastos por Classe Operacional",
                                    labels={'custo': 'Custo (R$)', 'Classe_Operacional': 'Classe'},
                                    color='custo',
                                    color_continuous_scale='Blues'
                                )
                                fig_gastos_classe.update_traces(
                                    textposition='outside',
                                    texttemplate='%{text}',
                                    textfont=dict(size=11, color='white'),
                                    cliponaxis=False,
                                    marker=dict(line=dict(width=1, color='black'))
                                )
                                fig_gastos_classe.update_layout(
                                    yaxis={'categoryorder':'total ascending'},
                                    xaxis_title="Custo Total (R$)",
                                    yaxis_title="Classe Operacional",
                                    height=600,
                                    showlegend=False,
                                    margin=dict(l=20, r=20, t=40, b=20),
                                    font=dict(size=12),
                                    bargap=0.3,
                                    bargroupgap=0.1
                                )
                                # Configurar eixo Y para mostrar todas as categorias
                                fig_gastos_classe.update_yaxes(
                                    type='category',
                                    categoryorder='total ascending'
                                )
                                st.plotly_chart(fig_gastos_classe, use_container_width=True)
                            else:
                                st.info("N√£o h√° dados de gastos por classe.")
                        
                        # Resumo dos totais
                        st.markdown("---")
                        col_resumo1, col_resumo2, col_resumo3 = st.columns(3)
                        with col_resumo1:
                            st.metric(
                                "Total Gastos (Per√≠odo)", 
                                formatar_brasileiro(df_gastos['custo'].sum(), 'R$ ')
                            )
                        with col_resumo2:
                            if not gastos_por_frota.empty:
                                frota_maior_gasto = gastos_por_frota.iloc[0]
                                st.metric(
                                    "Frota com Maior Gasto", 
                                    f"{frota_maior_gasto['Cod_Equip']}",
                                    f"{frota_maior_gasto['custo_formatado']}"
                                )
                            else:
                                st.metric("Frota com Maior Gasto", "N/A")
                        with col_resumo3:
                            st.metric(
                                "Classe com Maior Gasto", 
                                f"{gastos_por_classe.iloc[0]['Classe_Operacional'] if not gastos_por_classe.empty else 'N/A'}"
                            )
                    else:
                        st.warning("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos para visualizar os gastos.")

                    st.markdown("---")
                    st.subheader("üìà M√©dia de Consumo por Classe Operacional")
                    df_media = df_f[(df_f['Media'].notna()) & (df_f['Media'] > 0)].copy()

                    classes_para_excluir = ['MOTOCICLETA', 'VEICULOS LEVES', 'USINA', 'MINI CARREGADEIRA']

                    # Verificar se a coluna Classe_Operacional existe antes de filtrar
                    if 'Classe_Operacional' in df_media.columns:
                        df_media_filtrado = df_media[~df_media['Classe_Operacional'].str.upper().isin(classes_para_excluir)]
                    else:
                        df_media_filtrado = df_media

                    if not df_media_filtrado.empty: # Usa o novo DataFrame filtrado
                        media_por_classe = df_media_filtrado.groupby('Classe_Operacional')['Media'].mean().sort_values(ascending=True)
                        
                        df_media_grafico = media_por_classe.reset_index()
                        df_media_grafico['texto_formatado'] = df_media_grafico['Media'].apply(
                            lambda x: formatar_brasileiro(x)
                        )
                        
                        # Cria o gr√°fico de barras
                        fig_media_classe = px.bar(
                            df_media_grafico,
                            x='Media',
                            y='Classe_Operacional',
                            orientation='h',
                            title="M√©dia de Consumo (L/h ou Km/L) por Classe",
                            text='texto_formatado'
                        )
                        fig_media_classe.update_traces(
                            textposition='outside',
                            marker_color='#1f77b4'
                        )
                        fig_media_classe.update_layout(
                            yaxis_title="Classe Operacional",
                            xaxis_title="M√©dia de Consumo"
                        )
                        st.plotly_chart(fig_media_classe, use_container_width=True)
                    else:
                        st.info("N√£o h√° dados de consumo m√©dio para exibir com os filtros e exclus√µes aplicadas.")

                    st.markdown("---")
                    st.subheader("üí∞ Total de Gasto por Motorista")
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        # Vincula combust√≠vel por frota e multiplica litros por pre√ßo
                        df_tmp = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_tmp = df_tmp.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_tmp.columns:
                                df_tmp['tipo_combustivel'] = df_tmp['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_tmp['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_tmp.columns:
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        
                        df_tmp['preco_unit'] = df_tmp['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_tmp['custo'] = df_tmp['Qtde Litros'].fillna(0.0) * df_tmp['preco_unit']
                        # Agrupar por matr√≠cula
                        if 'Matricula' in df_tmp.columns:
                            gasto_motorista = df_tmp.groupby('Matricula').agg({'custo':'sum', 'Qtde Litros':'sum'}).sort_values('custo', ascending=False)
                            gasto_motorista = gasto_motorista[gasto_motorista['custo']>0]
                            if not gasto_motorista.empty:
                                gasto_motorista = gasto_motorista.reset_index()
                                gasto_motorista['Custo (R$)'] = gasto_motorista['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                                gasto_motorista['Litros'] = gasto_motorista['Qtde Litros'].apply(formatar_brasileiro_int)
                                st.dataframe(gasto_motorista[['Matricula','Litros','Custo (R$)']])
                                try:
                                    fig_gasto = px.bar(gasto_motorista.head(10), x='custo', y='Matricula', orientation='h', text='Custo (R$)', labels={'custo':'Custo (R$)','Matricula':'Matr√≠cula'})
                                    st.plotly_chart(fig_gasto, use_container_width=True)
                                except Exception:
                                    pass
                            else:
                                st.info("Sem dados suficientes de custo (verifique pre√ßos cadastrados).")
                        else:
                            st.info("N√£o h√° coluna de matr√≠cula nos abastecimentos para calcular o gasto por motorista.")
                    else:
                        st.info("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos.")

                    st.markdown("---")
                    st.subheader("üîÑ An√°lise de Propor√ß√µes por Classe e Combust√≠vel")
                
                with col_grafico2:
                    st.subheader("‚õΩ Consumo por Tipo de Combust√≠vel")
                    if not df_consumo_combustivel.empty:
                        try:
                            # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                            df_consumo_real = df_consumo_combustivel[df_consumo_combustivel['Qtde Litros'] > 0].copy()
                            
                            if not df_consumo_real.empty:
                                # Obter tipos de combust√≠vel apenas das frotas que realmente abasteceram
                                if 'tipo_combustivel' in df_frotas.columns:
                                    # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                                    equipamentos_com_consumo = df_consumo_real['Cod_Equip'].unique()
                                    
                                    # Filtrar df_frotas para incluir apenas equipamentos com consumo
                                    frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                                    
                                    # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                                    if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                        # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                        frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                                    
                                    # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                                    combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                                    
                                    # Aplicar o mapeamento apenas aos registros com consumo
                                    df_consumo_real['tipo_combustivel'] = df_consumo_real['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                                else:
                                    df_consumo_real['tipo_combustivel'] = 'Diesel S500'
                                
                                # Agrupar por tipo de combust√≠vel
                                consumo_por_combustivel = df_consumo_real.groupby("tipo_combustivel")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()
                                
                                if not consumo_por_combustivel.empty:
                                    # Criar gr√°fico de pizza
                                    fig_pizza_combustivel = px.pie(
                                        consumo_por_combustivel, 
                                        values='Qtde Litros', 
                                        names='tipo_combustivel',
                                        title="Propor√ß√£o de Consumo por Combust√≠vel (Apenas Frotas com Hist√≥rico)",
                                        hole=0.3
                                    )
                                    fig_pizza_combustivel.update_traces(textposition='inside', textinfo='percent+label')
                                    fig_pizza_combustivel.update_layout(height=400)
                                    st.plotly_chart(fig_pizza_combustivel, use_container_width=True)
                                    
                                    # Mostrar totais
                                    st.info(f"**Total de tipos de combust√≠vel:** {len(consumo_por_combustivel)}")
                                    st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                                    st.info(f"**Frotas com hist√≥rico de abastecimento:** {len(equipamentos_com_consumo)}")
                                else:
                                    st.warning("N√£o h√° dados de consumo para an√°lise por combust√≠vel.")
                            else:
                                st.warning("N√£o h√° registros com consumo de combust√≠vel.")
                        except Exception as e:
                            st.error(f"Erro ao criar gr√°fico de combust√≠vel: {e}")
                            st.info("Verificando dados dispon√≠veis...")
                            if 'tipo_combustivel' in df_consumo_combustivel.columns:
                                consumo_por_combustivel = df_consumo_combustivel.groupby("tipo_combustivel")["Qtde Litros"].sum().reset_index()
                                st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                            else:
                                st.error("Coluna tipo_combustivel n√£o encontrada")
                    else:
                        st.warning("N√£o h√° dados suficientes para an√°lise por combust√≠vel.")
                
                # Fechar as colunas anteriores e criar nova se√ß√£o com largura total
                st.markdown("---")
                st.subheader("üìä Demonstrativos Detalhados dos Pneus")

                df_pneus_all = get_pneus_historico()
                if not df_pneus_all.empty:
                    # Adicione colunas de status e vida se n√£o existirem
                    if 'status' not in df_pneus_all.columns:
                        df_pneus_all['status'] = 'Ativo'
                    if 'vida_atual' not in df_pneus_all.columns:
                        df_pneus_all['vida_atual'] = 1

                    total_pneus = len(df_pneus_all)
                    ativos = df_pneus_all[df_pneus_all['status'].str.lower() == 'ativo'].shape[0]
                    sucateados = df_pneus_all[df_pneus_all['status'].str.lower() == 'sucateado'].shape[0]
                    reformados = df_pneus_all[df_pneus_all['status'].str.lower() == 'reformado'].shape[0]
                    vidas = df_pneus_all['vida_atual'].value_counts().sort_index()
                    marcas = df_pneus_all['marca'].value_counts()
                    modelos = df_pneus_all['modelo'].value_counts()
                    posicoes = df_pneus_all['posicao'].value_counts()

                    col1, col2, col3, col4 = st.columns(4)
                    col1.metric("Total de Pneus", total_pneus)
                    col2.metric("Ativos", ativos)
                    col3.metric("Sucateados", sucateados)
                    col4.metric("Reformados", reformados)

                    # Gr√°ficos melhorados com r√≥tulos de dados
                    st.markdown("#### üìä Gr√°ficos de Distribui√ß√£o")
                    
                    # Criar DataFrame de status para o gr√°fico
                    status_df = df_pneus_all['status'].value_counts().reset_index()
                    status_df.columns = ["Status", "Quantidade"]
                    
                    # Gr√°fico de Status (Pizza)
                    fig_status = px.pie(status_df, names='Status', values='Quantidade', title='Status dos Pneus')
                    fig_status.update_traces(
                        textposition='inside',
                        textinfo='percent+label',
                        textfont=dict(size=12, color='white')
                    )
                    fig_status.update_layout(
                        height=400,
                        showlegend=True,
                        font=dict(size=12)
                    )
                    st.plotly_chart(fig_status, use_container_width=True)

                    # Gr√°fico de Marcas (Barras)
                    fig_marcas = px.bar(
                        marcas.reset_index(), 
                        x='marca', 
                        y='count', 
                        title='Quantidade por Marca',
                        text='count'
                    )
                    fig_marcas.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_marcas.update_layout(
                        xaxis_title="Marca",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_marcas, use_container_width=True)

                    # Gr√°fico de Modelos (Barras)
                    fig_modelos = px.bar(
                        modelos.reset_index(), 
                        x='modelo', 
                        y='count', 
                        title='Quantidade por Medida',
                        text='count'
                    )
                    fig_modelos.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_modelos.update_layout(
                        xaxis_title="Modelo",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_modelos, use_container_width=True)



                    # Bot√µes de exporta√ß√£o
                    st.markdown("#### üìä Exportar Dados")
                    col_export1, col_export2, col_export3 = st.columns(3)
                    
                    with col_export1:
                        export_dataframe(status_df, "status_pneus", "csv")
                    
                    with col_export2:
                        export_dataframe(marcas.reset_index(), "marcas_pneus", "csv")
                    
                    with col_export3:
                        export_dataframe(modelos.reset_index(), "modelos_pneus", "csv")
                    
                    # Informa√ß√µes adicionais
                    st.markdown("---")
                    st.markdown("""
                    <div class="info-box">
                        <strong>üí° Dicas:</strong><br>
                        ‚Ä¢ Use os filtros para analisar per√≠odos espec√≠ficos<br>
                        ‚Ä¢ Exporte os dados para an√°lises externas<br>
                        ‚Ä¢ Os gr√°ficos s√£o interativos - clique para mais detalhes
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.info("Nenhum pneu cadastrado para demonstrativo.")

                st.markdown("---")
                st.subheader("üõ¢Ô∏è Demonstrativos de Lubrificantes")

                ensure_lubrificantes_schema()
                conn = sqlite3.connect(DB_PATH)
                df_lub = pd.read_sql("SELECT * FROM lubrificantes", conn)
                df_mov = pd.read_sql("SELECT * FROM lubrificantes_movimentacoes", conn)

                st.write("**Estoque Atual de Lubrificantes:**")
                if not df_lub.empty:
                    # Separar por tipo
                    df_oleos = df_lub[df_lub['tipo'].str.lower() == '√≥leo']
                    df_graxas = df_lub[df_lub['tipo'].str.lower() == 'graxa']

                    col_o, col_g = st.columns(2)
                    with col_o:
                        st.markdown("#### Estoque de √ìleos")
                        if not df_oleos.empty:
                            fig_oleos = px.bar(
                                df_oleos,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="√ìleos - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': '√ìleo'}
                            )
                            st.plotly_chart(fig_oleos, use_container_width=True)
                        else:
                            st.info("Nenhum √≥leo cadastrado.")

                    with col_g:
                        st.markdown("#### Estoque de Graxas")
                        if not df_graxas.empty:
                            fig_graxas = px.bar(
                                df_graxas,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="Graxas - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': 'Graxa'}
                            )
                            st.plotly_chart(fig_graxas, use_container_width=True)
                        else:
                            st.info("Nenhuma graxa cadastrada.")

                    # Pizza geral
                    df_lub['tipo'] = df_lub['tipo'].fillna('√≥leo')
                    fig_pizza = px.pie(
                        df_lub,
                        names='tipo',
                        values='quantidade_estoque',
                        title="Propor√ß√£o de Estoque: √ìleos vs Graxas"
                    )
                    st.plotly_chart(fig_pizza, use_container_width=True)

                    st.write("**Movimenta√ß√µes Recentes:**")
                    df_mov['data'] = pd.to_datetime(df_mov['data'], errors='coerce')
                    df_mov = df_mov.sort_values('data', ascending=False)
                    st.dataframe(df_mov.head(20))
                else:
                    st.info("Nenhum lubrificante cadastrado.")

                conn.close()

import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, date, timedelta
import os
import plotly.express as px
import hashlib
import json
import base64
import io
# Configura√ß√£o da p√°gina (deve ser o primeiro comando Streamlit)
st.set_page_config(
    page_title="Dashboard de Frotas - A√ß√∫car Alegre",
    page_icon="üöú",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/projeto-uma',
        'Report a bug': "https://github.com/seu-usuario/projeto-uma/issues",
        'About': "# Dashboard de Frotas\n\nSistema de gest√£o de frotas da A√ß√∫car Alegre\n\nDesenvolvido por Andr√© Luis"
    }
)

# Configura√ß√£o de tema
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark'

# CSS personalizado para tema claro/escuro
def get_theme_css():
    if st.session_state.theme == 'dark':
        return """
        <style>
        .stApp {
            background-color: #0e1117;
            color: #fafafa;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """
    else:
        return """
        <style>
        .stApp {
            background-color: #ffffff;
            color: #262730;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """

# Aplicar CSS do tema
st.markdown(get_theme_css(), unsafe_allow_html=True)

# Fun√ß√£o para alternar tema
def toggle_theme():
    st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
    st.rerun()

# Fun√ß√£o para exportar dados
def export_dataframe(df, filename, file_type='csv'):
    """Exporta DataFrame em diferentes formatos"""
    if file_type == 'csv':
        csv = df.to_csv(index=False, sep=';', decimal=',', encoding='utf-8-sig')
        st.download_button(
            label=f"üì• Download {filename}.csv",
            data=csv,
            file_name=f"{filename}.csv",
            mime="text/csv",
            help=f"Baixar {filename} em formato CSV"
        )
    elif file_type == 'excel':
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        buffer.seek(0)
        st.download_button(
            label=f"üì• Download {filename}.xlsx",
            data=buffer,
            file_name=f"{filename}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help=f"Baixar {filename} em formato Excel"
        )

# Fun√ß√£o para mostrar loading
def show_loading(message="Carregando dados..."):
    """Mostra indicador de carregamento"""
    with st.spinner(message):
        st.info(f"‚è≥ {message}")
        return True

# Fun√ß√£o para tooltip informativo
def info_tooltip(text, help_text):
    """Cria um elemento com tooltip informativo"""
    col1, col2 = st.columns([20, 1])
    with col1:
        st.write(text)
    with col2:
        st.info("‚ÑπÔ∏è", help=help_text)

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "frotas_data.db")

ALERTAS_MANUTENCAO = {
    'HORAS': { 'default': 20 },
    'QUIL√îMETROS': { 'default': 500 }
}

def formatar_brasileiro(valor: float, prefixo='') -> str:
    """Formata um n√∫mero com casas decimais para o padr√£o brasileiro."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{prefixo}{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

@st.cache_data(ttl=300)
def para_csv(df: pd.DataFrame):
    """Converte um DataFrame para CSV para download."""
    return df.to_csv(index=False, sep=';', decimal=',').encode('utf-8-sig')

def formatar_brasileiro_int(valor: float) -> str:
    """Formata um n√∫mero inteiro para o padr√£o brasileiro (ex: 123.456)."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{int(valor):,}".replace(",", ".")

def detect_equipment_type(df_completo: pd.DataFrame) -> pd.DataFrame:
    df = df_completo.copy()
    df['Tipo_Controle'] = df.get('Unid', pd.Series(index=df.index)).map({'HORAS': 'HORAS', 'QUIL√îMETROS': 'QUIL√îMETROS'})
    def inferir_tipo_por_classe(row):
        if pd.notna(row['Tipo_Controle']): return row['Tipo_Controle']
        classe = str(row.get('Classe_Operacional', '')).upper()
        if any(p in classe for p in ['TRATOR', 'COLHEITADEIRA', 'PULVERIZADOR', 'PLANTADEIRA', 'P√Å CARREGADEIRA', 'RETROESCAVADEIRA']): return 'HORAS'
        if any(p in classe for p in ['CAMINH√ÉO', 'CAMINHAO', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']): return 'QUIL√îMETROS'
        return 'HORAS'
    df['Tipo_Controle'] = df.apply(inferir_tipo_por_classe, axis=1)
    return df

def hash_password(password):
    """Gera um hash seguro da palavra-passe."""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login_db(username, password):
    """Verifica as credenciais contra a base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash, role FROM utilizadores WHERE username = ?", (username,))
        result = cursor.fetchone()
        conn.close()
        if result:
            password_hash_db, role = result
            if password_hash_db == hash_password(password):
                return role
        return None
    except Exception as e:
        st.error(f"Erro ao aceder √† base de dados de utilizadores: {e}")
        return None

def get_all_users():
    """Busca todos os utilizadores da base de dados."""
    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
        return pd.read_sql_query("SELECT id, username, role FROM utilizadores", conn)

def add_user(username, password, role):
    """Adiciona um novo utilizador √† base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO utilizadores (username, password_hash, role) VALUES (?, ?, ?)",
            (username, hash_password(password), role)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador adicionado com sucesso!"
    except sqlite3.IntegrityError:
        return False, f"Erro: O nome de utilizador '{username}' j√° existe."
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def update_user(user_id, new_username, new_role):
    """Atualiza o nome e a fun√ß√£o de um utilizador."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE utilizadores SET username = ?, role = ? WHERE id = ?",
            (new_username, new_role, user_id)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador atualizado com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def delete_user(user_id):
    """Remove um utilizador da base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM utilizadores WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        return True, "Utilizador removido com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

    
# APAGUE A SUA FUN√á√ÉO "load_data_from_db" INTEIRA E SUBSTITUA-A POR ESTE BLOCO FINAL

@st.cache_data(show_spinner="Carregando e processando dados...", ttl=300)
def load_data_from_db(db_path: str, ver_frotas: int=None, ver_abast: int=None, ver_manut: int=None, ver_comp: int=None, ver_chk: int=None):
    if not os.path.exists(db_path):
        st.error(f"Arquivo de banco de dados '{db_path}' n√£o encontrado.")
        st.stop()

    try:
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            df_abast = pd.read_sql_query("SELECT rowid, * FROM abastecimentos", conn)
            df_frotas = pd.read_sql_query("SELECT * FROM frotas", conn)
            df_manutencoes = pd.read_sql_query("SELECT rowid, * FROM manutencoes", conn)
            df_comp_regras = pd.read_sql_query("SELECT * FROM componentes_regras", conn)
            df_comp_historico = pd.read_sql_query("SELECT rowid, * FROM componentes_historico", conn)
            df_checklist_regras = pd.read_sql_query("SELECT * FROM checklist_regras", conn)
            df_checklist_itens = pd.read_sql_query("SELECT * FROM checklist_itens", conn)
            df_checklist_historico = pd.read_sql_query("SELECT rowid, * FROM checklist_historico", conn)

        # --- In√≠cio do Processamento Integrado ---
        
        # Renomeia colunas para um padr√£o consistente
        df_abast = df_abast.rename(columns={"C√≥d. Equip.": "Cod_Equip", "Qtde Litros": "Qtde Litros", "M√™s": "Mes", "M√©dia": "Media"}, errors='ignore')
        df_frotas = df_frotas.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip", "Classe Operacional": "Classe_Operacional"}, errors='ignore')

        # Cria o dataframe principal mesclando abastecimentos e frotas
        df_merged = pd.merge(df_abast, df_frotas, on="Cod_Equip", how="left")
        
        # Trata colunas de classe operacional que podem ter vindo da mesclagem
        if 'Classe_Operacional_x' in df_merged.columns:
            df_merged['Classe_Operacional'] = np.where(df_merged['Classe_Operacional_x'].notna(), df_merged['Classe_Operacional_x'], df_merged['Classe_Operacional_y'])
            df_merged.drop(columns=['Classe_Operacional_x', 'Classe_Operacional_y'], inplace=True)
        
        # Converte a coluna de data e cria colunas de tempo
        df_merged["Data"] = pd.to_datetime(df_merged["Data"], errors='coerce')
        df_merged.dropna(subset=["Data"], inplace=True)
        df_merged["Ano"] = df_merged["Data"].dt.year
        df_merged["AnoMes"] = df_merged["Data"].dt.to_period("M").astype(str)
        
        # Limpa e converte colunas num√©ricas
        for col in ["Qtde Litros", "Media", "Hod_Hor_Atual"]:
            if col in df_merged.columns:
                series = df_merged[col].astype(str)
                series = series.str.replace(',', '.', regex=False).str.replace('-', '', regex=False).str.strip()
                df_merged[col] = pd.to_numeric(series, errors='coerce')
        
        # Cria a coluna "label" no dataframe de frotas para uso em seletores
        df_frotas["label"] = df_frotas["Cod_Equip"].astype(str) + " - " + df_frotas.get("DESCRICAO_EQUIPAMENTO", "").fillna("") + " (" + df_frotas.get("PLACA", "").fillna("Sem Placa") + ")"

        # Vincula informa√ß√µes de motorista aos abastecimentos (merge durante o load)
        try:
            with sqlite3.connect(db_path, check_same_thread=False) as conn:
                df_motoristas = pd.read_sql_query("SELECT codigo_pessoa, matricula, nome FROM motoristas", conn)
            if not df_motoristas.empty:
                df_merged = df_merged.merge(
                    df_motoristas.rename(columns={"codigo_pessoa": "Cod_Pessoa", "matricula": "Matricula", "nome": "Nome_Motorista"}),
                    on=["Cod_Pessoa", "Matricula"], how="left"
                )
        except Exception:
            pass
        
        # Garante que a classe operacional em df_frotas est√° atualizada
        classe_map = df_merged.dropna(subset=['Classe_Operacional']).groupby('Cod_Equip')['Classe_Operacional'].first()
        df_frotas['Classe_Operacional'] = df_frotas['Cod_Equip'].map(classe_map).fillna(df_frotas.get('Classe_Operacional'))

        # Adiciona coluna de tipo de combust√≠vel se n√£o existir
        if 'tipo_combustivel' not in df_frotas.columns:
            df_frotas['tipo_combustivel'] = 'Diesel S500'  # Valor padr√£o
        else:
            # Se a coluna existe, apenas preencher valores nulos com padr√£o
            df_frotas['tipo_combustivel'] = df_frotas['tipo_combustivel'].fillna('Diesel S500')

        # Determina o tipo de controle (Horas ou Quil√¥metros) para cada equipamento
        def determinar_tipo_controle(row):
            texto_para_verificar = (
                str(row.get('DESCRICAO_EQUIPAMENTO', '')) + ' ' + 
                str(row.get('Classe_Operacional', ''))
            ).upper()
            km_keywords = ['CAMINH', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']
            if any(p in texto_para_verificar for p in km_keywords):
                return 'QUIL√îMETROS'
            return 'HORAS'
        df_frotas['Tipo_Controle'] = df_frotas.apply(determinar_tipo_controle, axis=1)

        # Retorna todos os dataframes processados
        return (
            df_merged, df_frotas, df_manutencoes,
            df_comp_regras, df_comp_historico,
            df_checklist_regras, df_checklist_itens, df_checklist_historico
        )

    except Exception as e:
        st.error(f"Erro ao ler e processar o banco de dados: {e}")
        st.stop()
        # Retorna dataframes vazios em caso de erro
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(),
                pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

                
    
def inserir_abastecimento(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO abastecimentos (
                "C√≥d. Equip.", Data, "Qtde Litros", Hod_Hor_Atual,
                Safra, "M√™s", "Classe Operacional", Matricula, Cod_Pessoa
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['data'],
            dados['qtde_litros'],
            dados['hod_hor_atual'],
            dados['safra'],
            dados['mes'],
            dados['classe_operacional'],
            dados.get('matricula'),
            dados.get('cod_pessoa')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao inserir dados no banco de dados: {e}")
        return False

def excluir_abastecimento(db_path: str, rowid: int) -> bool:
    """Exclui um registro de abastecimento do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        # Usar rowid √© a forma mais segura de deletar uma linha espec√≠fica
        sql = "DELETE FROM abastecimentos WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir dados do banco de dados: {e}")
        return False

def excluir_manutencao_componente(db_path: str, cod_equip: int, nome_componente: str, data: str, hod_hor: float) -> bool:
    """Exclui um registro de manuten√ß√£o de componente do banco de dados usando uma combina√ß√£o √∫nica de campos."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)
        nome_componente = str(nome_componente)
        data = str(data)
        hod_hor = float(hod_hor)
        
        # Debug: verificar todos os registros na tabela
        cursor.execute("SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico")
        all_records = cursor.fetchall()
        
        # Debug: verificar se h√° registros com valores similares
        cursor.execute(
            "SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico WHERE Cod_Equip = ?", 
            (cod_equip,)
        )
        similar_records = cursor.fetchall()
        
        # Primeiro, vamos verificar se o registro existe
        cursor.execute(
            "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        count = cursor.fetchone()[0]
        
        if count == 0:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - Nome Componente: {nome_componente} (tipo: {type(nome_componente)})
            - Data: {data} (tipo: {type(data)})
            - Hod_Hor: {hod_hor} (tipo: {type(hod_hor)})
            
            Registros similares encontrados (mesmo Cod_Equip):
            {similar_records}
            
            Todos os registros na tabela:
            {all_records}
            """
            st.error(debug_info)
            return False
        
        # Agora vamos excluir
        cursor.execute(
            "DELETE FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute(
                "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
                (cod_equip, nome_componente, data, hod_hor)
            )
            count_after = cursor.fetchone()[0]
            
            if count_after == 0:
                # For√ßar sincroniza√ß√£o do banco
                cursor.execute("PRAGMA wal_checkpoint(FULL)")
                cursor.execute("PRAGMA synchronous=FULL")
                conn.commit()
                
                # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                backup_success, backup_msg = save_backup_to_session_state()
                if backup_success:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Backup salvo: {backup_msg}")
                else:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Aviso: {backup_msg}")
                
                conn.close()
                return True
            else:
                st.error("Erro: Registro ainda existe ap√≥s exclus√£o")
                conn.close()
                return False
        else:
            st.error("Nenhum registro foi exclu√≠do")
            conn.close()
            return False
            
    except Exception as e:
        st.error(f"Erro ao excluir manuten√ß√£o de componente do banco de dados: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def excluir_manutencao(db_path: str, rowid: int) -> bool:
    """Exclui um registro de manuten√ß√£o do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = "DELETE FROM manutencoes WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir manuten√ß√£o do banco de dados: {e}")
        return False

def inserir_manutencao(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = 'INSERT INTO manutencoes (Cod_Equip, Data, Tipo_Servico, Hod_Hor_No_Servico) VALUES (?, ?, ?, ?)'
        params = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'])
        cursor.execute(sql, params)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False

def inserir_frota(db_path: str, dados: dict) -> bool:
    """Insere um novo registro de frota no banco de dados."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO frotas (
                COD_EQUIPAMENTO, DESCRICAO_EQUIPAMENTO, PLACA, 
                "Classe Operacional", ATIVO, tipo_combustivel
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['descricao'],
            dados['placa'],
            dados['classe_op'],
            dados['ativo'],
            dados.get('tipo_combustivel', 'Diesel S500')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False
    

def editar_abastecimento(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de abastecimento existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE abastecimentos SET
                "C√≥d. Equip." = ?, Data = ?, "Qtde Litros" = ?, Hod_Hor_Atual = ?, Safra = ?, Matricula = ?, Cod_Pessoa = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'], dados['data'], dados['qtde_litros'], dados['hod_hor_atual'], dados['safra'],
            dados.get('matricula'), dados.get('cod_pessoa'), rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar abastecimento: {e}")
        return False

def editar_manutencao(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de manuten√ß√£o existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE manutencoes SET
                Cod_Equip = ?, Data = ?, Tipo_Servico = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'], rowid)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar manuten√ß√£o: {e}")
        return False

def editar_manutencao_componente(db_path: str, rowid: int, dados: dict) -> bool:
    """Edita um registro de manuten√ß√£o de componente existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE componentes_historico 
            SET Cod_Equip = ?, nome_componente = ?, Observacoes = ?, Data = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'],
            dados['componente'],
            dados['acao'],
            dados['data'],
            dados['hod_hor_servico'],
            rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao editar manuten√ß√£o de componente no banco de dados: {e}")
        return False

def importar_abastecimentos_de_planilha(db_path: str, arquivo_carregado) -> tuple[int, int, str]:
    """L√™ uma planilha, verifica por duplicados, e insere os novos dados. Aceita opcionalmente as colunas Matricula e Cod_Pessoa."""
    try:
        df_novo = pd.read_excel(arquivo_carregado)
        
        mapa_colunas = {
            "C√≥d. Equip.": "C√≥d. Equip.",
            "Data": "Data",
            "Qtde Litros": "Qtde Litros",
            "Hod. Hor. Atual": "Hod_Hor_Atual",
            "Safra": "Safra",
            "M√™s": "M√™s",
            "Classe Operacional": "Classe Operacional",
            "Matricula": "Matricula",
            "Cod_Pessoa": "Cod_Pessoa",
        }
        df_novo = df_novo.rename(columns={k: v for k, v in mapa_colunas.items() if k in df_novo.columns})

        colunas_necessarias = ["C√≥d. Equip.", "Data", "Qtde Litros", "Hod_Hor_Atual", "Safra", "M√™s", "Classe Operacional"]
        colunas_opcionais = ["Matricula", "Cod_Pessoa"]
        colunas_faltando = [col for col in colunas_necessarias if col not in df_novo.columns]
        if colunas_faltando:
            return 0, 0, f"Erro: Colunas n√£o encontradas: {', '.join(colunas_faltando)}"
        conn = sqlite3.connect(db_path)
        df_existente = pd.read_sql_query("SELECT * FROM abastecimentos", conn)
        
        df_novo['Data'] = pd.to_datetime(df_novo['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')
        df_existente['Data'] = pd.to_datetime(df_existente['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')

        df_novo['chave_unica'] = df_novo['C√≥d. Equip.'].astype(str) + '_' + df_novo['Data'] + '_' + df_novo['Qtde Litros'].astype(str)
        df_existente['chave_unica'] = df_existente['C√≥d. Equip.'].astype(str) + '_' + df_existente['Data'] + '_' + df_existente['Qtde Litros'].astype(str)

        df_para_inserir = df_novo[~df_novo['chave_unica'].isin(df_existente['chave_unica'])]
        
        num_duplicados = len(df_novo) - len(df_para_inserir)

        if df_para_inserir.empty:
            return 0, num_duplicados, "Nenhum registo novo para importar. Todos os registos da planilha j√° existem na base de dados."

        colunas_insert = colunas_necessarias + [c for c in colunas_opcionais if c in df_para_inserir.columns]
        df_para_inserir_final = df_para_inserir[colunas_insert]
        registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
        
        cursor = conn.cursor()
        placeholders = ", ".join(["?"] * len(colunas_insert))
        sql = f"INSERT INTO abastecimentos ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
        cursor.executemany(sql, registros)
        
        conn.commit()
        num_inseridos = cursor.rowcount
        conn.close()
        
        mensagem_sucesso = f"{num_inseridos} registos novos foram importados com sucesso."
        if num_duplicados > 0:
            mensagem_sucesso += f" {num_duplicados} registos duplicados foram ignorados."
            
        return num_inseridos, num_duplicados, mensagem_sucesso

    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o: {e}"

def editar_frota(db_path: str, cod_equip: int, dados: dict) -> bool:
    """Atualiza um registro de frota existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE frotas SET
                DESCRICAO_EQUIPAMENTO = ?, PLACA = ?, "Classe Operacional" = ?, ATIVO = ?, tipo_combustivel = ?
            WHERE COD_EQUIPAMENTO = ?
        """
        valores = (dados['descricao'], dados['placa'], dados['classe_op'], dados['ativo'], dados.get('tipo_combustivel', 'Diesel S500'), cod_equip)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar frota: {e}")
        return False

# COLE ESTE BLOCO DE C√ìDIGO NO LOCAL INDICADO

def get_component_rules():
    """Busca todas as regras de componentes da base de dados."""
    with sqlite3.connect(DB_PATH) as conn:
        return pd.read_sql_query("SELECT * FROM componentes_regras", conn)

def add_component_rule(classe, componente, intervalo):
    """Adiciona uma nova regra de componente √† base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao) VALUES (?, ?, ?)",
                (classe, componente, intervalo)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def add_component_rule_advanced(classe, componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca", capacidade_litros=0.0):
    """Adiciona uma nova regra de componente com informa√ß√µes de lubrificante e tipo de manuten√ß√£o."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, tipo_manutencao, capacidade_litros) VALUES (?, ?, ?, ?, ?, ?)",
                (classe, componente, intervalo, lubrificante_id, tipo_manutencao, capacidade_litros)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def delete_component_rule(rule_id):
    """Remove uma regra de componente da base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM componentes_regras WHERE id_regra = ?", (rule_id,))
            conn.commit()
        return True, "Componente removido com sucesso."
    except Exception as e:
        return False, f"Erro ao remover componente: {e}"

def add_component_service(cod_equip, componente, data, hod_hor, obs):
    """Adiciona um novo registo de servi√ßo de componente ao hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, Observacoes) VALUES (?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def add_component_service_advanced(cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado=None, obs=""):
    """Adiciona um novo registo de servi√ßo de componente com informa√ß√µes detalhadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def get_component_status(cod_equip, componente):
    """Obt√©m o status atual de um componente espec√≠fico de um equipamento."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            # Buscar a √∫ltima manuten√ß√£o do componente
            query = """
            SELECT Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            ORDER BY Data DESC, Hod_Hor_No_Servico DESC
            LIMIT 1
            """
            df_ultima = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            
            # Buscar a regra do componente para obter o intervalo
            query_regra = """
            SELECT intervalo_padrao, lubrificante_id, tipo_manutencao
            FROM componentes_regras cr
            JOIN frotas f ON cr.classe_operacional = f."Classe Operacional"
            WHERE f.COD_EQUIPAMENTO = ? AND cr.nome_componente = ?
            """
            df_regra = pd.read_sql_query(query_regra, conn, params=(cod_equip, componente))
            
            # Buscar o hod√¥metro/hor√≠metro atual do equipamento
            query_hod = """
            SELECT Hod_Hor_Atual FROM abastecimentos 
            WHERE Cod_Equip = ? 
            ORDER BY Data DESC, Hod_Hor_Atual DESC 
            LIMIT 1
            """
            df_hod = pd.read_sql_query(query_hod, conn, params=(cod_equip,))
            
            return df_ultima, df_regra, df_hod
            
    except Exception as e:
        st.error(f"Erro ao obter status do componente: {e}")
        return None, None, None

def get_component_maintenance_count(cod_equip, componente):
    """Obt√©m o n√∫mero total de manuten√ß√µes realizadas em um componente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT COUNT(*) as total_manutencoes,
                   COUNT(CASE WHEN tipo_servico = 'Troca' THEN 1 END) as total_trocas,
                   COUNT(CASE WHEN tipo_servico = 'Remonta' THEN 1 END) as total_remontas
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            """
            df_count = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            return df_count.iloc[0] if not df_count.empty else {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}
            
    except Exception as e:
        st.error(f"Erro ao obter contagem de manuten√ß√µes: {e}")
        return {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}

def editar_manutencao_componente_advanced(DB_PATH, rowid, dados_editados):
    """Edita uma manuten√ß√£o de componente com informa√ß√µes avan√ßadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_historico 
                SET Cod_Equip = ?, nome_componente = ?, Data = ?, Hod_Hor_No_Servico = ?, 
                    Observacoes = ?, tipo_servico = ?, lubrificante_utilizado = ?
                WHERE rowid = ?
            """, (
                dados_editados['cod_equip'],
                dados_editados['componente'],
                dados_editados['data'],
                dados_editados['hod_hor_servico'],
                dados_editados['acao'],
                dados_editados['tipo_servico'],
                dados_editados['lubrificante_utilizado'],
                rowid
            ))
            conn.commit()
        return True, "Manuten√ß√£o de componente atualizada com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar manuten√ß√£o de componente: {e}"

def update_component_rule(rule_id, nome_componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca"):
    """Atualiza uma regra de componente existente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_regras 
                SET nome_componente = ?, intervalo_padrao = ?, lubrificante_id = ?, tipo_manutencao = ?
                WHERE id_regra = ?
            """, (nome_componente, intervalo, lubrificante_id, tipo_manutencao, rule_id))
            conn.commit()
        return True, f"Componente '{nome_componente}' atualizado com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar componente: {e}"

def get_frota_combustivel(cod_equip):
    """Obt√©m o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tipo_combustivel FROM frotas WHERE COD_EQUIPAMENTO = ?", (cod_equip,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        st.error(f"Erro ao obter tipo de combust√≠vel: {e}")
        return None

def update_frota_combustivel(cod_equip, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE COD_EQUIPAMENTO = ?", (tipo_combustivel, cod_equip))
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel: {e}"

def update_classe_combustivel(classe_operacional, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de todas as frotas de uma classe."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE \"Classe Operacional\" = ?", (tipo_combustivel, classe_operacional))
            rows_updated = cursor.rowcount
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel} em {rows_updated} frotas da classe {classe_operacional}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel da classe: {e}"

def add_tipo_combustivel_column():
    """Adiciona a coluna tipo_combustivel √† tabela frotas se ela n√£o existir."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            # Verificar se a coluna existe
            cursor.execute("PRAGMA table_info(frotas)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'tipo_combustivel' not in columns:
                cursor.execute("ALTER TABLE frotas ADD COLUMN tipo_combustivel TEXT DEFAULT 'Diesel S500'")
                conn.commit()
                return True, "Coluna tipo_combustivel adicionada com sucesso"
            else:
                return True, "Coluna tipo_combustivel j√° existe"
    except Exception as e:
        return False, f"Erro ao adicionar coluna tipo_combustivel: {e}"

def ensure_motoristas_schema():
    """Garante a exist√™ncia da tabela de motoristas e das colunas de v√≠nculo em abastecimentos."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS motoristas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    codigo_pessoa TEXT,
                    matricula TEXT UNIQUE,
                    nome TEXT,
                    ativo TEXT DEFAULT 'ATIVO'
                )
                """
            )
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_matricula ON motoristas(matricula)")
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_codigo_pessoa ON motoristas(codigo_pessoa)")

            cursor.execute("PRAGMA table_info(abastecimentos)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'Matricula' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Matricula TEXT")
            if 'Cod_Pessoa' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Cod_Pessoa TEXT")
            conn.commit()
        return True, "Esquema de motoristas verificado"
    except Exception as e:
        return False, f"Erro ao verificar esquema de motoristas: {e}"

def get_all_motoristas() -> pd.DataFrame:
    """Retorna o DataFrame de motoristas."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM motoristas", conn)
    except Exception:
        return pd.DataFrame(columns=['id', 'codigo_pessoa', 'matricula', 'nome', 'ativo'])

def importar_motoristas_de_planilha(db_path: str, arquivo_carregado):
    """Importa motoristas a partir de planilha Excel. Espera colunas: Matricula, Nome e opcional Cod_Pessoa/C√≥digo Pessoa."""
    try:
        df_mot = pd.read_excel(arquivo_carregado)
        df_mot.columns = [c.strip() for c in df_mot.columns]
        renomeios = {
            'Matr√≠cula': 'Matricula', 'matricula': 'Matricula', 'MATRICULA': 'Matricula',
            'Nome': 'Nome', 'nome': 'Nome', 'NOME': 'Nome',
            'Cod_Pessoa': 'Cod_Pessoa', 'C√≥digo Pessoa': 'Cod_Pessoa', 'codigo_pessoa': 'Cod_Pessoa', 'CODIGO_PESSOA': 'Cod_Pessoa'
        }
        df_mot.rename(columns={k: v for k, v in renomeios.items() if k in df_mot.columns}, inplace=True)
        obrig = ['Matricula', 'Nome']
        faltando = [c for c in obrig if c not in df_mot.columns]
        if faltando:
            return 0, 0, f"Erro: Colunas obrigat√≥rias n√£o encontradas: {', '.join(faltando)}"
        if 'Cod_Pessoa' not in df_mot.columns:
            df_mot['Cod_Pessoa'] = None
        df_mot = df_mot.dropna(subset=['Matricula', 'Nome']).copy()
        df_mot['Matricula'] = df_mot['Matricula'].astype(str).str.strip()
        df_mot['Nome'] = df_mot['Nome'].astype(str).str.strip()
        df_mot['Cod_Pessoa'] = df_mot['Cod_Pessoa'].astype(str).str.strip()
        df_mot = df_mot.drop_duplicates(subset=['Matricula'])
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            existentes = pd.read_sql_query("SELECT matricula FROM motoristas", conn)
            set_exist = set(existentes['matricula'].astype(str)) if not existentes.empty else set()
            df_novos = df_mot[~df_mot['Matricula'].isin(set_exist)].copy()
            if df_novos.empty:
                return 0, len(df_mot), "Nenhum motorista novo para importar. Todos j√° existem."
            registros = [
                (row.get('Cod_Pessoa', None), row['Matricula'], row['Nome'], 'ATIVO')
                for _, row in df_novos.iterrows()
            ]
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO motoristas (codigo_pessoa, matricula, nome, ativo) VALUES (?, ?, ?, ?)",
                registros
            )
            conn.commit()
            inseridos = cur.rowcount if cur.rowcount is not None else len(registros)
            duplicados = len(df_mot) - len(df_novos)
            return inseridos, duplicados, f"{inseridos} motoristas importados com sucesso. {duplicados} j√° existiam."
    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o de motoristas: {e}"
    
def ensure_pneus_schema():
    """Garante a exist√™ncia da tabela de hist√≥rico de pneus."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pneus_historico (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    Cod_Equip INTEGER,
                    posicao TEXT,
                    marca TEXT,
                    modelo TEXT,
                    numero_fogo TEXT,
                    data_instalacao TEXT,
                    hodometro_instalacao REAL,
                    
                    observacoes TEXT,
                    status TEXT DEFAULT 'Ativo',
                    vida_atual INTEGER DEFAULT 1
                )
            """)
            # Adiciona colunas se n√£o existirem
            cursor.execute("PRAGMA table_info(pneus_historico)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'status' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN status TEXT DEFAULT 'Ativo'")
            if 'vida_atual' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN vida_atual INTEGER DEFAULT 1")
            if 'numero_fogo' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN numero_fogo TEXT")
            conn.commit()
        return True, "Tabela de pneus verificada"
    except Exception as e:
        return False, f"Erro ao criar tabela de pneus: {e}"

def importar_pneus_de_planilha(db_path: str, arquivo_carregado):
    """Importa hist√≥rico de pneus de uma planilha Excel, verificando duplicatas."""
    try:
        df_pneus = pd.read_excel(arquivo_carregado)
        df_pneus.columns = [c.strip() for c in df_pneus.columns]
        obrig = ['Cod_Equip', 'posicao', 'marca', 'modelo', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao']
        faltando = [c for c in obrig if c not in df_pneus.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
            if 'observacoes' not in df_pneus.columns:
                df_pneus['observacoes'] = ""
            
        
        # Limpar dados e remover linhas com valores nulos obrigat√≥rios
        df_pneus = df_pneus.dropna(subset=['Cod_Equip', 'posicao', 'numero_fogo'])
        
        # Normalizar tipos de dados
        df_pneus['Cod_Equip'] = df_pneus['Cod_Equip'].astype(str)
        df_pneus['posicao'] = df_pneus['posicao'].astype(str).str.strip()
        df_pneus['numero_fogo'] = df_pneus['numero_fogo'].astype(str).str.strip()
        df_pneus['data_instalacao'] = pd.to_datetime(df_pneus['data_instalacao']).dt.strftime('%Y-%m-%d')
        
        # Remover duplicatas na pr√≥pria planilha baseada em chave √∫nica
        df_pneus = df_pneus.drop_duplicates(subset=['Cod_Equip', 'posicao', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Buscar registros existentes para verificar duplicatas
            df_existente = pd.read_sql_query("SELECT Cod_Equip, posicao, numero_fogo, data_instalacao, hodometro_instalacao FROM pneus_historico", conn)
            
            if not df_existente.empty:
                # Normalizar dados existentes para compara√ß√£o
                df_existente['Cod_Equip'] = df_existente['Cod_Equip'].astype(str)
                df_existente['posicao'] = df_existente['posicao'].astype(str).str.strip()
                df_existente['numero_fogo'] = df_existente['numero_fogo'].astype(str).str.strip()
                df_existente['data_instalacao'] = pd.to_datetime(df_existente['data_instalacao']).dt.strftime('%Y-%m-%d')
                
                # Criar chaves √∫nicas para compara√ß√£o
                df_pneus['chave_unica'] = (df_pneus['Cod_Equip'] + '_' + 
                                          df_pneus['posicao'] + '_' + 
                                          df_pneus['numero_fogo'] + '_' + 
                                          df_pneus['data_instalacao'] + '_' + 
                                          df_pneus['hodometro_instalacao'].astype(str))
                
                df_existente['chave_unica'] = (df_existente['Cod_Equip'] + '_' + 
                                              df_existente['posicao'] + '_' + 
                                              df_existente['numero_fogo'] + '_' + 
                                              df_existente['data_instalacao'] + '_' + 
                                              df_existente['hodometro_instalacao'].astype(str))
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_pneus[~df_pneus['chave_unica'].isin(df_existente['chave_unica'])]
            else:
                df_para_inserir = df_pneus
            
            num_duplicados = len(df_pneus) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum pneu novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = obrig + ['observacoes']
            # Garantir que a coluna observacoes exista no DataFrame
            if 'observacoes' not in df_para_inserir.columns:
                df_para_inserir['observacoes'] = ''
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.fillna('').to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO pneus_historico ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} pneus novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar pneus: {e}"

def get_pneus_historico(cod_equip=None):
    """Retorna o hist√≥rico de pneus, opcionalmente filtrando por frota."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            query = "SELECT * FROM pneus_historico"
            params = ()
            if cod_equip:
                query += " WHERE Cod_Equip = ?"
                params = (cod_equip,)
            return pd.read_sql_query(query, conn, params=params)
    except Exception:
        return pd.DataFrame()

def ensure_precos_combustivel_schema():
    """Garante a exist√™ncia da tabela de pre√ßos por tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS precos_combustivel (
                    tipo_combustivel TEXT PRIMARY KEY,
                    preco REAL
                )
                """
            )
            tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
            for t in tipos:
                cur.execute("INSERT OR IGNORE INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?)", (t, NULL))
            conn.commit()
        return True, "Tabela de pre√ßos verificada"
    except Exception as e:
        return False, f"Erro ao verificar tabela de pre√ßos: {e}"

def get_precos_combustivel_map() -> dict:
    """Retorna um dicion√°rio {tipo_combustivel: preco}."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            dfp = pd.read_sql_query("SELECT tipo_combustivel, preco FROM precos_combustivel", conn)
        return {row['tipo_combustivel']: row['preco'] for _, row in dfp.iterrows()}
    except Exception:
        return {}

def upsert_preco_combustivel(tipo: str, preco: float) -> tuple[bool, str]:
    """Cria/atualiza pre√ßo para um tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?) ON CONFLICT(tipo_combustivel) DO UPDATE SET preco=excluded.preco",
                (tipo, preco)
            )
            conn.commit()
        return True, f"Pre√ßo atualizado para {tipo}"
    except Exception as e:
        return False, f"Erro ao atualizar pre√ßo: {e}"
    
def ensure_lubrificantes_schema():
    """Garante a exist√™ncia da tabela de lubrificantes, movimenta√ß√µes e almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            
            # Tabela de lubrificantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT,
                    viscosidade TEXT,
                    quantidade_estoque REAL,
                    unidade TEXT,
                    observacoes TEXT
                )
            """)
            
            # Verificar e adicionar coluna 'tipo' se n√£o existir
            cursor.execute("PRAGMA table_info(lubrificantes)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'tipo' not in cols:
                cursor.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
            
            # Tabela de almoxarifados
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifados (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT NOT NULL,
                    tipo TEXT DEFAULT 'fixo', -- 'fixo' para oficina, 'movel' para caminh√µes
                    localizacao TEXT,
                    responsavel TEXT,
                    observacoes TEXT,
                    ativo BOOLEAN DEFAULT 1
                )
            """)
            
            # Tabela de estoque por almoxarifado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifado_estoque (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_almoxarifado INTEGER,
                    id_lubrificante INTEGER,
                    quantidade_estoque REAL DEFAULT 0,
                    unidade TEXT,
                    data_atualizacao TEXT,
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id),
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    UNIQUE(id_almoxarifado, id_lubrificante)
                )
            """)
            
            # Tabela de movimenta√ß√µes (atualizada para incluir almoxarifado)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes_movimentacoes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_lubrificante INTEGER,
                    id_almoxarifado INTEGER,
                    tipo TEXT, -- 'entrada' ou 'saida'
                    quantidade REAL,
                    data TEXT,
                    cod_equip INTEGER,
                    observacoes TEXT,
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id)
                )
            """)
            
            # Verificar se a coluna id_almoxarifado existe na tabela de movimenta√ß√µes
            cursor.execute("PRAGMA table_info(lubrificantes_movimentacoes)")
            cols_mov = [c[1] for c in cursor.fetchall()]
            if 'id_almoxarifado' not in cols_mov:
                cursor.execute("ALTER TABLE lubrificantes_movimentacoes ADD COLUMN id_almoxarifado INTEGER")
            
            conn.commit()
        return True, "Tabelas de lubrificantes e almoxarifados verificadas"
    except Exception as e:
        return False, f"Erro ao criar tabelas de lubrificantes: {e}"
    
def add_almoxarifado(nome, tipo="fixo", localizacao="", responsavel="", observacoes=""):
    """Adiciona um novo almoxarifado."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO almoxarifados (nome, tipo, localizacao, responsavel, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, tipo, localizacao, responsavel, observacoes)
            )
            conn.commit()
        return True, "Almoxarifado cadastrado com sucesso!"
    except Exception as e:
        return False, f"Erro: {e}"

def get_almoxarifados():
    """Retorna todos os almoxarifados ativos."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            df = pd.read_sql("SELECT * FROM almoxarifados WHERE ativo = 1 ORDER BY nome", conn)
        return df
    except Exception as e:
        return pd.DataFrame()

def get_estoque_por_almoxarifado(id_lubrificante):
    """Retorna o estoque de um lubrificante distribu√≠do por almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT 
                a.nome as almoxarifado,
                a.tipo,
                COALESCE(ae.quantidade_estoque, 0) as quantidade,
                COALESCE(ae.unidade, l.unidade) as unidade,
                a.localizacao,
                a.responsavel
            FROM almoxarifados a
            CROSS JOIN lubrificantes l
            LEFT JOIN almoxarifado_estoque ae ON a.id = ae.id_almoxarifado AND l.id = ae.id_lubrificante
            WHERE l.id = ? AND a.ativo = 1
            ORDER BY a.nome
            """
            df = pd.read_sql(query, conn, params=(id_lubrificante,))
        return df
    except Exception as e:
        return pd.DataFrame()

def atualizar_estoque_almoxarifado(id_almoxarifado, id_lubrificante, quantidade, unidade):
    """Atualiza o estoque de um lubrificante em um almoxarifado espec√≠fico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO almoxarifado_estoque 
                (id_almoxarifado, id_lubrificante, quantidade_estoque, unidade, data_atualizacao) 
                VALUES (?, ?, ?, ?, ?)
            """, (id_almoxarifado, id_lubrificante, quantidade, unidade, date.today().strftime("%Y-%m-%d")))
            conn.commit()
        return True, "Estoque atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao atualizar estoque: {e}"

def add_lubrificante(nome, viscosidade, quantidade, unidade, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes (nome, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, viscosidade, quantidade, unidade, observacoes)
            )
            conn.commit()
        return True, "Lubrificante cadastrado!"
    except Exception as e:
        return False, f"Erro: {e}"

def importar_lubrificantes_de_planilha(db_path: str, arquivo_carregado):
    """Importa lubrificantes de uma planilha Excel, verificando duplicatas."""
    try:
        df_lub = pd.read_excel(arquivo_carregado)
        df_lub.columns = [c.strip() for c in df_lub.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome': 'nome',
            'tipo': 'tipo',
            'viscosidade': 'viscosidade',
            'quantidade_estoque': 'quantidade_estoque',
            'unidade': 'unidade',
            'observacoes': 'observacoes'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_lub.columns:
                df_lub = df_lub.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome']
        faltando = [c for c in obrig if c not in df_lub.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'tipo' not in df_lub.columns:
            df_lub['tipo'] = '√≥leo'
        if 'viscosidade' not in df_lub.columns:
            df_lub['viscosidade'] = ''
        if 'quantidade_estoque' not in df_lub.columns:
            df_lub['quantidade_estoque'] = 0
        if 'unidade' not in df_lub.columns:
            df_lub['unidade'] = 'L'
        if 'observacoes' not in df_lub.columns:
            df_lub['observacoes'] = ''
        
        # Limpar e normalizar dados
        df_lub = df_lub.dropna(subset=['nome'])
        df_lub['nome'] = df_lub['nome'].astype(str).str.strip()
        df_lub['tipo'] = df_lub['tipo'].astype(str).str.strip().fillna('√≥leo')
        df_lub['viscosidade'] = df_lub['viscosidade'].astype(str).str.strip().fillna('')
        df_lub['quantidade_estoque'] = pd.to_numeric(df_lub['quantidade_estoque'], errors='coerce').fillna(0)
        df_lub['unidade'] = df_lub['unidade'].astype(str).str.strip().fillna('L')
        df_lub['observacoes'] = df_lub['observacoes'].astype(str).str.strip().fillna('')
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome
        df_lub = df_lub.drop_duplicates(subset=['nome'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que a tabela existe com a coluna tipo
            ensure_lubrificantes_schema()
            
            # Buscar lubrificantes existentes
            df_existente = pd.read_sql_query("SELECT nome FROM lubrificantes", conn)
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome'] = df_existente['nome'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_lub[~df_lub['nome'].isin(df_existente['nome'])]
            else:
                df_para_inserir = df_lub
            
            num_duplicados = len(df_lub) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum lubrificante novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = ['nome', 'tipo', 'viscosidade', 'quantidade_estoque', 'unidade', 'observacoes']
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO lubrificantes ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} lubrificantes novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar lubrificantes: {e}"

def importar_componentes_de_planilha(db_path: str, arquivo_carregado, classe_operacional: str):
    """Importa componentes de uma planilha Excel, verificando duplicatas e criando lubrificantes se necess√°rio."""
    try:
        df_comp = pd.read_excel(arquivo_carregado)
        df_comp.columns = [c.strip() for c in df_comp.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome_componente': 'nome_componente',
            'componente': 'nome_componente',
            'intervalo_padrao': 'intervalo_padrao',
            'intervalo': 'intervalo_padrao',
            'lubrificante_nome': 'lubrificante_nome',
            'lubrificante': 'lubrificante_nome',
            'capacidade_litros': 'capacidade_litros',
            'capacidade': 'capacidade_litros'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_comp.columns:
                df_comp = df_comp.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome_componente', 'intervalo_padrao']
        faltando = [c for c in obrig if c not in df_comp.columns]
        if faltando:
            return 0, 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'lubrificante_nome' not in df_comp.columns:
            df_comp['lubrificante_nome'] = None
        if 'capacidade_litros' not in df_comp.columns:
            df_comp['capacidade_litros'] = 0.0
        
        # Limpar e normalizar dados
        df_comp = df_comp.dropna(subset=['nome_componente'])
        df_comp['nome_componente'] = df_comp['nome_componente'].astype(str).str.strip()
        df_comp['intervalo_padrao'] = pd.to_numeric(df_comp['intervalo_padrao'], errors='coerce')
        df_comp = df_comp.dropna(subset=['intervalo_padrao'])
        df_comp['lubrificante_nome'] = df_comp['lubrificante_nome'].astype(str).str.strip().replace('nan', None)
        df_comp['capacidade_litros'] = pd.to_numeric(df_comp['capacidade_litros'], errors='coerce').fillna(0.0)
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome do componente
        df_comp = df_comp.drop_duplicates(subset=['nome_componente'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que as tabelas existem
            ensure_lubrificantes_schema()
            
            # Verificar se a tabela componentes_regras tem a coluna capacidade_litros
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'capacidade_litros' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN capacidade_litros REAL DEFAULT 0.0")
            
            # Buscar componentes existentes na classe
            df_existente = pd.read_sql_query(
                "SELECT nome_componente FROM componentes_regras WHERE classe_operacional = ?", 
                conn, params=(classe_operacional,)
            )
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome_componente'] = df_existente['nome_componente'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem na classe
                df_para_inserir = df_comp[~df_comp['nome_componente'].isin(df_existente['nome_componente'])]
            else:
                df_para_inserir = df_comp
            
            num_duplicados = len(df_comp) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, 0, "Nenhum componente novo para importar. Todos os registros da planilha j√° existem na classe selecionada."
            
            # Processar lubrificantes
            lubrificantes_criados = 0
            for _, row in df_para_inserir.iterrows():
                if pd.notna(row['lubrificante_nome']) and row['lubrificante_nome']:
                    # Verificar se o lubrificante existe
                    df_lub_existente = pd.read_sql_query(
                        "SELECT id FROM lubrificantes WHERE nome = ?", 
                        conn, params=(row['lubrificante_nome'],)
                    )
                    
                    if df_lub_existente.empty:
                        # Criar lubrificante automaticamente
                        cur = conn.cursor()
                        cur.execute(
                            "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                            (row['lubrificante_nome'], '√≥leo', '', 0, 'L', f'Criado automaticamente durante importa√ß√£o de componentes')
                        )
                        lubrificantes_criados += 1
                        
                        # Buscar o ID do lubrificante criado
                        lub_id = cur.lastrowid
                    else:
                        lub_id = df_lub_existente.iloc[0]['id']
                else:
                    lub_id = None
                
                # Inserir componente
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, capacidade_litros) VALUES (?, ?, ?, ?, ?)",
                    (classe_operacional, row['nome_componente'], row['intervalo_padrao'], lub_id, row['capacidade_litros'])
                )
            
            conn.commit()
            num_inseridos = len(df_para_inserir)
            
            mensagem_sucesso = f"{num_inseridos} componentes foram importados com sucesso para a classe '{classe_operacional}'."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} componentes duplicados foram ignorados."
            if lubrificantes_criados > 0:
                mensagem_sucesso += f" {lubrificantes_criados} lubrificantes foram criados automaticamente."
            
            return num_inseridos, num_duplicados, lubrificantes_criados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, 0, f"Erro ao importar componentes: {e}"

def movimentar_lubrificante(id_lubrificante, tipo, quantidade, data, cod_equip=None, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes_movimentacoes (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes)
            )
            # Atualiza estoque
            sinal = 1 if tipo == "entrada" else -1
            cur.execute(
                "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque + ? WHERE id = ?",
                (sinal * quantidade, id_lubrificante)
            )
            conn.commit()
        return True, "Movimenta√ß√£o registrada!"
    except Exception as e:
        return False, f"Erro: {e}"

@st.cache_data(ttl=120)
def filtrar_dados(df: pd.DataFrame, opts: dict) -> pd.DataFrame:
    # Garante que a coluna de data √© do tipo datetime
    df['Data'] = pd.to_datetime(df['Data'])
    
    # Filtra por per√≠odo de datas
    df_filtrado = df[
        (df['Data'].dt.date >= opts['data_inicio']) & 
        (df['Data'].dt.date <= opts['data_fim'])
    ]
    
    # Filtra pelas outras sele√ß√µes, se existirem
    if opts.get("classes_op"):
        df_filtrado = df_filtrado[df_filtrado["Classe_Operacional"].isin(opts["classes_op"])]
    
    if opts.get("safras"):
        df_filtrado = df_filtrado[df_filtrado["Safra"].isin(opts["safras"])]
        
    return df_filtrado.copy()

@st.cache_data(show_spinner="Calculando plano de manuten√ß√£o...", ttl=300)
def build_component_maintenance_plan(_df_frotas: pd.DataFrame, _df_abastecimentos: pd.DataFrame, _df_componentes_regras: pd.DataFrame, _df_componentes_historico: pd.DataFrame) -> pd.DataFrame:
    latest_readings = _df_abastecimentos.sort_values('Data').groupby('Cod_Equip')['Hod_Hor_Atual'].last()
    plan_data = []

    for _, frota_row in _df_frotas.iterrows():
        cod_equip = frota_row['Cod_Equip']
        classe_op = frota_row.get('Classe_Operacional')
        hod_hor_atual = latest_readings.get(cod_equip)

        if pd.isna(hod_hor_atual) or not classe_op:
            continue
        
        regras_da_classe = _df_componentes_regras[_df_componentes_regras['classe_operacional'] == classe_op]
        if regras_da_classe.empty:
            continue

        unidade = 'km' if frota_row['Tipo_Controle'] == 'QUIL√îMETROS' else 'h'
        alerta_default = ALERTAS_MANUTENCAO.get(frota_row['Tipo_Controle'], {}).get('default', 500)
        
        record = {
            'Cod_Equip': cod_equip, 
            'Equipamento': frota_row.get('DESCRICAO_EQUIPAMENTO'), 
            'Leitura_Atual': hod_hor_atual, 
            'Unidade': unidade, 
            'Qualquer_Alerta': False, 
            'Alertas': []
        }

        for _, regra in regras_da_classe.iterrows():
            componente = regra['nome_componente']
            intervalo = regra['intervalo_padrao']
            
            historico_componente = _df_componentes_historico[
                (_df_componentes_historico['Cod_Equip'] == cod_equip) &
                (_df_componentes_historico['nome_componente'] == componente)
            ]
            
            ultimo_servico_hod_hor = 0
            if not historico_componente.empty:
                ultimo_servico_hod_hor = historico_componente['Hod_Hor_No_Servico'].max()

            prox_servico = ((ultimo_servico_hod_hor // intervalo) * intervalo) + intervalo
            while prox_servico < hod_hor_atual:
                prox_servico += intervalo

            restante = prox_servico - hod_hor_atual
            
            record[f'Restante_{componente}'] = restante
            
            if restante <= alerta_default:
                record['Qualquer_Alerta'] = True
                record['Alertas'].append(componente)

        plan_data.append(record)

    # üîπ Garante que sempre retorna um DataFrame com as colunas b√°sicas
    if not plan_data:
        return pd.DataFrame(columns=['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Qualquer_Alerta', 'Alertas'])

    return pd.DataFrame(plan_data)

def prever_manutencoes(df_veiculos: pd.DataFrame, df_abastecimentos: pd.DataFrame, plan_df: pd.DataFrame) -> pd.DataFrame:
    """Estima as datas das pr√≥ximas manuten√ß√µes com base no uso m√©dio."""
    if plan_df.empty or 'Leitura_Atual' not in plan_df.columns:
        return pd.DataFrame()

    # Calcula o uso di√°rio m√©dio de cada ve√≠culo
    uso_diario = {}
    for cod_equip in df_abastecimentos['Cod_Equip'].unique():
        dados_equip = df_abastecimentos[df_abastecimentos['Cod_Equip'] == cod_equip].sort_values('Data')
        if len(dados_equip) > 1:
            total_dias = (dados_equip['Data'].max() - dados_equip['Data'].min()).days
            total_uso = dados_equip['Hod_Hor_Atual'].max() - dados_equip['Hod_Hor_Atual'].min()
            if total_dias > 0 and total_uso > 0: # Garante que houve uso e passagem de tempo
                uso_diario[cod_equip] = total_uso / total_dias

    previsoes = []
    servicos_nomes = [col.replace('Restante_', '') for col in plan_df.columns if 'Restante_' in col]

    for _, row in plan_df.iterrows():
        cod_equip = row['Cod_Equip']
        uso = uso_diario.get(cod_equip)
        if uso:
            for nome_servico in servicos_nomes:
                col_restante = f'Restante_{nome_servico}'
                if col_restante in row and pd.notna(row[col_restante]):
                    dias_para_manut = row[col_restante] / uso
                    data_prevista = datetime.now() + pd.Timedelta(days=dias_para_manut)
                    previsoes.append({
                        'Equipamento': row['Equipamento'],
                        'Manuten√ß√£o': nome_servico,
                        'Data Prevista': data_prevista.strftime('%d/%m/%Y'),
                        'Dias Restantes': int(dias_para_manut)
                    })

    if not previsoes:
        return pd.DataFrame()

    df_previsoes = pd.DataFrame(previsoes)
    return df_previsoes.sort_values('Dias Restantes')

# ---------------------------
# Fun√ß√µes para Checklists
# ---------------------------

@st.cache_data(ttl=120)
def get_checklist_rules():
    """Busca todas as regras de checklist do banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM checklist_regras", conn)
    except Exception as e:
        st.error(f"Erro ao buscar regras de checklist: {e}")
        return pd.DataFrame()

@st.cache_data(ttl=120)
def get_checklist_items(id_regra):
    """Busca os itens de checklist para uma determinada regra."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query(
                "SELECT * FROM checklist_itens WHERE id_regra = ?",
                conn,
                params=(id_regra,)
            )
    except Exception as e:
        st.error(f"Erro ao buscar itens de checklist: {e}")
        return pd.DataFrame()

# ---------------------------
# CRUD para Checklists
# ---------------------------

def add_checklist_rule(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra de checklist ao banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
        return True, "Regra de checklist adicionada com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar regra de checklist: {e}"

def add_checklist_rule_and_get_id(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra e devolve o ID criado (ou None em erro).

    Mant√©m a fun√ß√£o "add_checklist_rule" para compatibilidade, mas quando for
    necess√°rio o ID imediatamente ap√≥s a cria√ß√£o, utilize esta fun√ß√£o.
    """
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        st.error(f"Erro ao adicionar regra de checklist: {e}")
        return None

def edit_checklist_rule(id_regra, classe_operacional, titulo_checklist, turno, frequencia):
    """Edita uma regra de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_regras
                SET classe_operacional = ?, titulo_checklist = ?, frequencia = ?, turno = ?
                WHERE id_regra = ?
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno, id_regra)
            )
            conn.commit()
        return True, "Regra de checklist atualizada com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar regra de checklist: {e}"

def delete_checklist_rule(id_regra):
    """Remove uma regra de checklist e seus itens associados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_regra = ?", (id_regra,))
            cursor.execute("DELETE FROM checklist_regras WHERE id_regra = ?", (id_regra,))
            conn.commit()
        return True, "Regra de checklist removida com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover regra de checklist: {e}"

def add_checklist_item(id_regra, nome_item):
    """Adiciona um novo item de checklist a uma regra existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_itens (id_regra, nome_item)
                VALUES (?, ?)
                """ ,
                (id_regra, nome_item)
            )
            conn.commit()
        return True, "Item de checklist adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar item de checklist: {e}"

def edit_checklist_item(id_item, nome_item):
    """Edita um item de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_itens
                SET nome_item = ?
                WHERE id_item = ?
                """ ,
                (nome_item, id_item)
            )
            conn.commit()
        return True, "Item de checklist atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar item de checklist: {e}"

def delete_checklist_item(id_item):
    """Remove um item de checklist."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_item = ?", (id_item,))
            conn.commit()
        return True, "Item de checklist removido com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover item de checklist: {e}"

def save_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno, status_geral):
    """Salva um checklist preenchido no hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_historico 
                (Cod_Equip, titulo_checklist, data_preenchimento, turno, status_geral) 
                VALUES (?, ?, ?, ?, ?)
                """ ,
                (cod_equip, titulo_checklist, data_preenchimento, turno, status_geral)
            )
            conn.commit()
    except Exception as e:
        st.error(f"Erro ao salvar hist√≥rico de checklist: {e}")

def delete_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno):
    """Remove um registro do hist√≥rico de checklists usando uma combina√ß√£o √∫nica de campos."""
    try:
        # Primeira tentativa: usar conex√£o direta
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)  # Converter numpy.int64 para int
        titulo_checklist = str(titulo_checklist)
        data_preenchimento = str(data_preenchimento)
        turno = str(turno)
        
        # Debug: verificar todos os registros na tabela ANTES da exclus√£o
        cursor.execute("SELECT rowid, Cod_Equip, titulo_checklist, data_preenchimento, turno FROM checklist_historico")
        all_records_before = cursor.fetchall()
        
        # Tentar encontrar o registro com diferentes abordagens
        rowid = None
        
        # Primeira tentativa: busca exata
        cursor.execute(
            "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
            (cod_equip, titulo_checklist, data_preenchimento, turno)
        )
        result = cursor.fetchone()
        
        if result:
            rowid = result[0]
        else:
            # Segunda tentativa: buscar apenas por Cod_Equip, t√≠tulo e turno (ignorar data)
            cursor.execute(
                "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND turno = ?", 
                (cod_equip, titulo_checklist, turno)
            )
            result = cursor.fetchone()
            
            if result:
                rowid = result[0]
            else:
                # Terceira tentativa: buscar apenas por Cod_Equip e t√≠tulo
                cursor.execute(
                    "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ?", 
                    (cod_equip, titulo_checklist)
                )
                result = cursor.fetchone()
                
                if result:
                    rowid = result[0]
        
        if rowid is None:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - T√≠tulo: {titulo_checklist} (tipo: {type(titulo_checklist)})
            - Data: {data_preenchimento} (tipo: {type(data_preenchimento)})
            - Turno: {turno} (tipo: {type(turno)})
            
            Todos os registros na tabela ANTES da exclus√£o:
            {all_records_before}
            """
            conn.close()
            return False, debug_info
        
        # Agora vamos excluir usando rowid
        cursor.execute("DELETE FROM checklist_historico WHERE rowid = ?", (rowid,))
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute("SELECT COUNT(*) FROM checklist_historico WHERE rowid = ?", (rowid,))
            count_after = cursor.fetchone()[0]
            
            # Verificar tamb√©m se o registro ainda existe pelos outros campos
            cursor.execute(
                "SELECT COUNT(*) FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
                (cod_equip, titulo_checklist, data_preenchimento, turno)
            )
            count_by_fields = cursor.fetchone()[0]
            
            if count_after == 0 and count_by_fields == 0:
                 # Verificar o total de registros na tabela
                 cursor.execute("SELECT COUNT(*) FROM checklist_historico")
                 total_after = cursor.fetchone()[0]
                 
                 # For√ßar sincroniza√ß√£o do banco
                 cursor.execute("PRAGMA wal_checkpoint(FULL)")
                 cursor.execute("PRAGMA synchronous=FULL")
                 conn.commit()
                 
                 success_msg = f"Checklist exclu√≠do com sucesso! ({rows_deleted} registro(s) removido(s)). Total na tabela: {total_after}"
                 
                 # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                 backup_success, backup_msg = save_backup_to_session_state()
                 if backup_success:
                     success_msg += f" | Backup salvo: {backup_msg}"
                 else:
                     success_msg += f" | Aviso: {backup_msg}"
                 
                 conn.close()
                 return True, success_msg
            else:
                conn.close()
                return False, f"Erro: Registro ainda existe ap√≥s exclus√£o. Count by rowid: {count_after}, Count by fields: {count_by_fields}"
        else:
            conn.close()
            return False, "Nenhum registro foi exclu√≠do"
                
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return False, f"Erro ao excluir checklist: {e}"

def force_cache_clear():
    """For√ßa a limpeza completa de todos os caches."""
    try:
        # Limpar cache de dados
        st.cache_data.clear()
        
        # Limpar cache de recursos
        st.cache_resource.clear()
        
        # For√ßar rerun da aplica√ß√£o
        st.rerun()
    except Exception as e:
        st.error(f"Erro ao limpar cache: {e}")

def force_database_sync():
    """For√ßa a sincroniza√ß√£o do banco de dados com o disco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # For√ßar commit
        conn.commit()
        
        # Executar PRAGMA para for√ßar sincroniza√ß√£o
        cursor.execute("PRAGMA wal_checkpoint(FULL)")
        cursor.execute("PRAGMA synchronous=FULL")
        cursor.execute("PRAGMA journal_mode=DELETE")
        
        # For√ßar commit novamente
        conn.commit()
        
        # Verificar se o banco est√° em modo WAL
        cursor.execute("PRAGMA journal_mode")
        journal_mode = cursor.fetchone()[0]
        
        conn.close()
        
        return True, f"Banco sincronizado. Modo journal: {journal_mode}"
    except Exception as e:
        return False, f"Erro ao sincronizar banco: {e}"

def export_database_backup():
    """Exporta todos os dados do banco para um arquivo de backup."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        
        # Obter todas as tabelas
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        backup_data = {}
        
        for table in tables:
            table_name = table[0]
            if table_name != 'sqlite_master':
                # Exportar dados da tabela
                df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
                backup_data[table_name] = df.to_dict('records')
        
        conn.close()
        
        # Converter para JSON
        backup_json = json.dumps(backup_data, default=str, indent=2)
        
        # Criar arquivo de download
        backup_bytes = backup_json.encode('utf-8')
        backup_b64 = base64.b64encode(backup_bytes).decode()
        
        return backup_b64, backup_data
        
    except Exception as e:
        return None, f"Erro ao exportar backup: {e}"

def import_database_backup(backup_data):
    """Importa dados de backup para o banco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        for table_name, records in backup_data.items():
            if records:  # Se a tabela tem dados
                # Limpar tabela existente
                cursor.execute(f"DELETE FROM {table_name}")
                
                # Inserir novos dados
                for record in records:
                    columns = list(record.keys())
                    placeholders = ', '.join(['?' for _ in columns])
                    values = list(record.values())
                    
                    # Converter tipos de dados
                    converted_values = []
                    for value in values:
                        if isinstance(value, str):
                            # Tentar converter para datetime se for uma data
                            try:
                                if 'T' in value or '-' in value:
                                    dt = pd.to_datetime(value)
                                    converted_values.append(dt.strftime('%Y-%m-%d %H:%M:%S'))
                                else:
                                    converted_values.append(value)
                            except:
                                converted_values.append(value)
                        else:
                            converted_values.append(value)
                    
                    cursor.execute(
                        f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})",
                        converted_values
                    )
        
        conn.commit()
        conn.close()
        
        return True, "Backup restaurado com sucesso!"
        
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def save_backup_to_session_state():
    """Salva backup dos dados na sess√£o do Streamlit."""
    try:
        backup_b64, backup_data = export_database_backup()
        if backup_b64:
            st.session_state['database_backup'] = backup_b64
            st.session_state['backup_timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return True, "Backup salvo na sess√£o"
        else:
            return False, "Erro ao criar backup"
    except Exception as e:
        return False, f"Erro ao salvar backup: {e}"

def restore_backup_from_session_state():
    """Restaura backup dos dados da sess√£o do Streamlit."""
    try:
        if 'database_backup' in st.session_state:
            backup_b64 = st.session_state['database_backup']
            backup_bytes = base64.b64decode(backup_b64)
            backup_json = backup_bytes.decode('utf-8')
            backup_data = json.loads(backup_json)
            
            success, message = import_database_backup(backup_data)
            if success:
                # Limpar cache para for√ßar recarregamento
                force_cache_clear()
                return True, message
            else:
                return False, message
        else:
            return False, "Nenhum backup encontrado na sess√£o"
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def auto_restore_backup_on_startup():
    """Tenta restaurar backup automaticamente na inicializa√ß√£o da aplica√ß√£o."""
    try:
        if 'database_backup' in st.session_state:
            # Verificar se o banco est√° vazio
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
            num_tables = cursor.fetchone()[0]
            conn.close()
            
            if num_tables == 0:
                # Banco vazio, tentar restaurar
                success, message = restore_backup_from_session_state()
                if success:
                    st.info("üîÑ Backup restaurado automaticamente na inicializa√ß√£o!")
                    return True
                else:
                    st.warning(f"‚ö†Ô∏è Falha na restaura√ß√£o autom√°tica: {message}")
                    return False
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na restaura√ß√£o autom√°tica: {e}")
        return False

def main():
    
    # Garante tema dark coerente mesmo sem config.toml
    st.markdown(
        """
        <style>
        :root {
            --primary: #10b981;
            --bg: #0f172a;
            --bg2: #111827;
            --text: #e5e7eb;
        }
        body { background: var(--bg); color: var(--text); }
        section.main > div { background: var(--bg); }
        .stApp { background: var(--bg); }
        .st-emotion-cache-1r4qj8v, .st-emotion-cache-13ln4jf { background: var(--bg2) !important; }
        .stButton>button { background: var(--primary); color: #062e24; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    # CSS fino para polir a UI
    st.markdown(
        """
        <style>
        /* Cart√µes/containers */
        .stExpander, .stDataFrame, .stTable { border-radius: 10px !important; }
        .stButton>button { border-radius: 8px; padding: 0.5rem 1rem; }
        .stSelectbox, .stTextInput, .stNumberInput, .stDateInput, .stTextArea { border-radius: 8px !important; }
        /* M√©tricas com mais destaque */
        div[data-testid="stMetric"] { background: rgba(255,255,255,0.04); padding: 10px 14px; border-radius: 12px; }
        /* T√≠tulos com leve gradiente */
        h1, h2, h3 { background: linear-gradient(90deg, #10b981 0%, #06b6d4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        /* Linhas divis√≥rias mais suaves */
        hr { border: none; height: 1px; background: rgba(255,255,255,0.08); }
        /* Subt√≠tulo de marca (opcional) */
        .brand-subtitle { display: none; }
        /* Centralizar e limitar logo na sidebar */
        section[data-testid="stSidebar"] img { display: block; margin: 0.5rem auto 0.75rem; max-width: 140px; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
        st.session_state.role = None
        st.session_state.username = ""

    if not st.session_state.authenticated:
        _ , col_central, _ = st.columns([1, 1.5, 1])
    
        with col_central:
            
            if os.path.exists("logo.png"):
                # Cria 3 sub-colunas dentro da coluna central
                _, logo_col, _ = st.columns([1, 2, 1])
                with logo_col:
                    st.image("logo.png", width=140)
            
            st.title("Bem vindo ao Aplicativo de Controle do PCMA")

            username = st.text_input("Usu√°rio", key="login_user")
            password = st.text_input("Senha", type="password", key="login_pass")

            if st.button("Entrar", use_container_width=True):
                role = check_login_db(username, password)
                if role:
                    st.session_state.authenticated = True
                    st.session_state.role = role
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("Usu√°rio ou Senha incorretos.")
    else:

        # Cabe√ßalho com logo + t√≠tulo
        if os.path.exists("logo.png"):
            col_logo, col_title = st.columns([1, 8])
            with col_logo:
                st.image("logo.png", width=80)
            with col_title:
                st.title("üìä Dashboard de Frotas e Abastecimentos")
        else:
            st.title("üìä Dashboard de Frotas e Abastecimentos")

        # Tentar restaurar backup automaticamente na inicializa√ß√£o
        auto_restore_backup_on_startup()
        
        # Adicionar coluna de tipo de combust√≠vel se n√£o existir
        add_tipo_combustivel_column()
        
        # Setup de esquemas (motoristas, pre√ßos, combust√≠vel)
        ensure_motoristas_schema()
        ensure_precos_combustivel_schema()

        # Passo um fingerprint simples das tabelas para invalidar cache quando necess√°rio
        ver_frotas = int(os.path.getmtime(DB_PATH)) if os.path.exists(DB_PATH) else 0
        df, df_frotas, df_manutencoes, df_comp_regras, df_comp_historico, df_checklist_regras, df_checklist_itens, df_checklist_historico = load_data_from_db(DB_PATH, ver_frotas, ver_frotas, ver_frotas, ver_frotas, ver_frotas)
        

        if 'intervalos_por_classe' not in st.session_state:
            st.session_state.intervalos_por_classe = {}
        classes_operacionais = [c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()]
        for classe in classes_operacionais:
            if classe not in st.session_state.intervalos_por_classe:
                tipo_controle = df_frotas[df_frotas['Classe_Operacional'] == classe]['Tipo_Controle'].iloc[0]
                if tipo_controle == 'HORAS':
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 5.0,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 250},
                            'servico_2': {'nome': 'Revisao A', 'intervalo': 100},
                            'servico_3': {'nome': 'Revisao B', 'intervalo': 300},
                            'servico_4': {'nome': 'Revisao C', 'intervalo': 500}
                        }
                    }
                else: # QUIL√îMETROS
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 2.5,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 5000},
                            'servico_2': {'nome': 'Revisao 5k', 'intervalo': 5000},
                            'servico_3': {'nome': 'Revisao 10k', 'intervalo': 10000},
                            'servico_4': {'nome': 'Revisao 20k', 'intervalo': 20000}
                        }
                    }
                    
        with st.sidebar:
            if os.path.exists("logo.png"):
                st.image("logo.png", width=200)
            st.write(f"Bem-vindo, **{st.session_state.username}**!")
            if st.button("Sair"):
                st.session_state.authenticated = False
                st.session_state.username = "" # Limpa o username ao sair
                st.session_state.role = None
                st.rerun()
            st.markdown("---")

        with st.sidebar:
            st.header("üìÖ Filtros (v√°lidos apenas na aba An√°lise Geral)")

            # Persist√™ncia de per√≠odo
            if 'filtro_data_inicio' not in st.session_state:
                st.session_state['filtro_data_inicio'] = df['Data'].min().date()
            if 'filtro_data_fim' not in st.session_state:
                st.session_state['filtro_data_fim'] = df['Data'].max().date()

            st.subheader("Per√≠odo de An√°lise")
            data_inicio = st.date_input(
                "Data de In√≠cio", 
                st.session_state['filtro_data_inicio'],
                key='data_inicio'
            )
            data_fim = st.date_input(
                "Data de Fim", 
                st.session_state['filtro_data_fim'],
                key='data_fim'
            )
            st.session_state['filtro_data_inicio'] = data_inicio
            st.session_state['filtro_data_fim'] = data_fim

            st.markdown("---")
            st.caption("Desenvolvido por Andr√© Luis")

            with st.expander("Filtrar por Classe Operacional"):
                classe_opts = sorted(list(df["Classe_Operacional"].dropna().unique()))
                sel_classes = st.multiselect(
                    "Selecione as Classes", 
                    classe_opts, 
                    default=classe_opts,
                    key="sel_classes"
                )

            with st.expander("Filtrar por Safra"):
                safra_opts = sorted(list(df["Safra"].dropna().unique()))
                sel_safras = st.multiselect(
                    "Selecione as Safras", 
                    safra_opts, 
                    default=safra_opts,
                    key="sel_safras"
                )

            # S√≥ aplicaremos os filtros na aba "üìà An√°lise Geral" (guardaremos em sess√£o)
            st.session_state['filtro_opts_analise'] = {
                "data_inicio": data_inicio,
                "data_fim": data_fim,
                "classes_op": sel_classes,
                "safras": sel_safras
            }
    
import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, date, timedelta
import os
import plotly.express as px
import hashlib
import json
import base64
import io
# Configura√ß√£o da p√°gina (deve ser o primeiro comando Streamlit)
st.set_page_config(
    page_title="Dashboard de Frotas - A√ß√∫car Alegre",
    page_icon="üöú",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/projeto-uma',
        'Report a bug': "https://github.com/seu-usuario/projeto-uma/issues",
        'About': "# Dashboard de Frotas\n\nSistema de gest√£o de frotas da A√ß√∫car Alegre\n\nDesenvolvido por Andr√© Luis"
    }
)

# Configura√ß√£o de tema
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark'

# CSS personalizado para tema claro/escuro
def get_theme_css():
    if st.session_state.theme == 'dark':
        return """
        <style>
        .stApp {
            background-color: #0e1117;
            color: #fafafa;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """
    else:
        return """
        <style>
        .stApp {
            background-color: #ffffff;
            color: #262730;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """

# Aplicar CSS do tema
st.markdown(get_theme_css(), unsafe_allow_html=True)

# Fun√ß√£o para alternar tema
def toggle_theme():
    st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
    st.rerun()

# Fun√ß√£o para exportar dados
def export_dataframe(df, filename, file_type='csv'):
    """Exporta DataFrame em diferentes formatos"""
    if file_type == 'csv':
        csv = df.to_csv(index=False, sep=';', decimal=',', encoding='utf-8-sig')
        st.download_button(
            label=f"üì• Download {filename}.csv",
            data=csv,
            file_name=f"{filename}.csv",
            mime="text/csv",
            help=f"Baixar {filename} em formato CSV"
        )
    elif file_type == 'excel':
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        buffer.seek(0)
        st.download_button(
            label=f"üì• Download {filename}.xlsx",
            data=buffer,
            file_name=f"{filename}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help=f"Baixar {filename} em formato Excel"
        )

# Fun√ß√£o para mostrar loading
def show_loading(message="Carregando dados..."):
    """Mostra indicador de carregamento"""
    with st.spinner(message):
        st.info(f"‚è≥ {message}")
        return True

# Fun√ß√£o para tooltip informativo
def info_tooltip(text, help_text):
    """Cria um elemento com tooltip informativo"""
    col1, col2 = st.columns([20, 1])
    with col1:
        st.write(text)
    with col2:
        st.info("‚ÑπÔ∏è", help=help_text)

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "frotas_data.db")

ALERTAS_MANUTENCAO = {
    'HORAS': { 'default': 20 },
    'QUIL√îMETROS': { 'default': 500 }
}

def formatar_brasileiro(valor: float, prefixo='') -> str:
    """Formata um n√∫mero com casas decimais para o padr√£o brasileiro."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{prefixo}{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

@st.cache_data(ttl=300)
def para_csv(df: pd.DataFrame):
    """Converte um DataFrame para CSV para download."""
    return df.to_csv(index=False, sep=';', decimal=',').encode('utf-8-sig')

def formatar_brasileiro_int(valor: float) -> str:
    """Formata um n√∫mero inteiro para o padr√£o brasileiro (ex: 123.456)."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{int(valor):,}".replace(",", ".")

def detect_equipment_type(df_completo: pd.DataFrame) -> pd.DataFrame:
    df = df_completo.copy()
    df['Tipo_Controle'] = df.get('Unid', pd.Series(index=df.index)).map({'HORAS': 'HORAS', 'QUIL√îMETROS': 'QUIL√îMETROS'})
    def inferir_tipo_por_classe(row):
        if pd.notna(row['Tipo_Controle']): return row['Tipo_Controle']
        classe = str(row.get('Classe_Operacional', '')).upper()
        if any(p in classe for p in ['TRATOR', 'COLHEITADEIRA', 'PULVERIZADOR', 'PLANTADEIRA', 'P√Å CARREGADEIRA', 'RETROESCAVADEIRA']): return 'HORAS'
        if any(p in classe for p in ['CAMINH√ÉO', 'CAMINHAO', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']): return 'QUIL√îMETROS'
        return 'HORAS'
    df['Tipo_Controle'] = df.apply(inferir_tipo_por_classe, axis=1)
    return df

def hash_password(password):
    """Gera um hash seguro da palavra-passe."""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login_db(username, password):
    """Verifica as credenciais contra a base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash, role FROM utilizadores WHERE username = ?", (username,))
        result = cursor.fetchone()
        conn.close()
        if result:
            password_hash_db, role = result
            if password_hash_db == hash_password(password):
                return role
        return None
    except Exception as e:
        st.error(f"Erro ao aceder √† base de dados de utilizadores: {e}")
        return None

def get_all_users():
    """Busca todos os utilizadores da base de dados."""
    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
        return pd.read_sql_query("SELECT id, username, role FROM utilizadores", conn)

def add_user(username, password, role):
    """Adiciona um novo utilizador √† base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO utilizadores (username, password_hash, role) VALUES (?, ?, ?)",
            (username, hash_password(password), role)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador adicionado com sucesso!"
    except sqlite3.IntegrityError:
        return False, f"Erro: O nome de utilizador '{username}' j√° existe."
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def update_user(user_id, new_username, new_role):
    """Atualiza o nome e a fun√ß√£o de um utilizador."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE utilizadores SET username = ?, role = ? WHERE id = ?",
            (new_username, new_role, user_id)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador atualizado com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def delete_user(user_id):
    """Remove um utilizador da base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM utilizadores WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        return True, "Utilizador removido com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

    
# APAGUE A SUA FUN√á√ÉO "load_data_from_db" INTEIRA E SUBSTITUA-A POR ESTE BLOCO FINAL

@st.cache_data(show_spinner="Carregando e processando dados...", ttl=300)
def load_data_from_db(db_path: str, ver_frotas: int=None, ver_abast: int=None, ver_manut: int=None, ver_comp: int=None, ver_chk: int=None):
    if not os.path.exists(db_path):
        st.error(f"Arquivo de banco de dados '{db_path}' n√£o encontrado.")
        st.stop()

    try:
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            df_abast = pd.read_sql_query("SELECT rowid, * FROM abastecimentos", conn)
            df_frotas = pd.read_sql_query("SELECT * FROM frotas", conn)
            df_manutencoes = pd.read_sql_query("SELECT rowid, * FROM manutencoes", conn)
            df_comp_regras = pd.read_sql_query("SELECT * FROM componentes_regras", conn)
            df_comp_historico = pd.read_sql_query("SELECT rowid, * FROM componentes_historico", conn)
            df_checklist_regras = pd.read_sql_query("SELECT * FROM checklist_regras", conn)
            df_checklist_itens = pd.read_sql_query("SELECT * FROM checklist_itens", conn)
            df_checklist_historico = pd.read_sql_query("SELECT rowid, * FROM checklist_historico", conn)

        # --- In√≠cio do Processamento Integrado ---
        
        # Renomeia colunas para um padr√£o consistente
        df_abast = df_abast.rename(columns={"C√≥d. Equip.": "Cod_Equip", "Qtde Litros": "Qtde Litros", "M√™s": "Mes", "M√©dia": "Media"}, errors='ignore')
        df_frotas = df_frotas.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip", "Classe Operacional": "Classe_Operacional"}, errors='ignore')

        # Cria o dataframe principal mesclando abastecimentos e frotas
        df_merged = pd.merge(df_abast, df_frotas, on="Cod_Equip", how="left")
        
        # Trata colunas de classe operacional que podem ter vindo da mesclagem
        if 'Classe_Operacional_x' in df_merged.columns:
            df_merged['Classe_Operacional'] = np.where(df_merged['Classe_Operacional_x'].notna(), df_merged['Classe_Operacional_x'], df_merged['Classe_Operacional_y'])
            df_merged.drop(columns=['Classe_Operacional_x', 'Classe_Operacional_y'], inplace=True)
        
        # Converte a coluna de data e cria colunas de tempo
        df_merged["Data"] = pd.to_datetime(df_merged["Data"], errors='coerce')
        df_merged.dropna(subset=["Data"], inplace=True)
        df_merged["Ano"] = df_merged["Data"].dt.year
        df_merged["AnoMes"] = df_merged["Data"].dt.to_period("M").astype(str)
        
        # Limpa e converte colunas num√©ricas
        for col in ["Qtde Litros", "Media", "Hod_Hor_Atual"]:
            if col in df_merged.columns:
                series = df_merged[col].astype(str)
                series = series.str.replace(',', '.', regex=False).str.replace('-', '', regex=False).str.strip()
                df_merged[col] = pd.to_numeric(series, errors='coerce')
        
        # Cria a coluna "label" no dataframe de frotas para uso em seletores
        df_frotas["label"] = df_frotas["Cod_Equip"].astype(str) + " - " + df_frotas.get("DESCRICAO_EQUIPAMENTO", "").fillna("") + " (" + df_frotas.get("PLACA", "").fillna("Sem Placa") + ")"

        # Vincula informa√ß√µes de motorista aos abastecimentos (merge durante o load)
        try:
            with sqlite3.connect(db_path, check_same_thread=False) as conn:
                df_motoristas = pd.read_sql_query("SELECT codigo_pessoa, matricula, nome FROM motoristas", conn)
            if not df_motoristas.empty:
                df_merged = df_merged.merge(
                    df_motoristas.rename(columns={"codigo_pessoa": "Cod_Pessoa", "matricula": "Matricula", "nome": "Nome_Motorista"}),
                    on=["Cod_Pessoa", "Matricula"], how="left"
                )
        except Exception:
            pass
        
        # Garante que a classe operacional em df_frotas est√° atualizada
        classe_map = df_merged.dropna(subset=['Classe_Operacional']).groupby('Cod_Equip')['Classe_Operacional'].first()
        df_frotas['Classe_Operacional'] = df_frotas['Cod_Equip'].map(classe_map).fillna(df_frotas.get('Classe_Operacional'))

        # Adiciona coluna de tipo de combust√≠vel se n√£o existir
        if 'tipo_combustivel' not in df_frotas.columns:
            df_frotas['tipo_combustivel'] = 'Diesel S500'  # Valor padr√£o
        else:
            # Se a coluna existe, apenas preencher valores nulos com padr√£o
            df_frotas['tipo_combustivel'] = df_frotas['tipo_combustivel'].fillna('Diesel S500')

        # Determina o tipo de controle (Horas ou Quil√¥metros) para cada equipamento
        def determinar_tipo_controle(row):
            texto_para_verificar = (
                str(row.get('DESCRICAO_EQUIPAMENTO', '')) + ' ' + 
                str(row.get('Classe_Operacional', ''))
            ).upper()
            km_keywords = ['CAMINH', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']
            if any(p in texto_para_verificar for p in km_keywords):
                return 'QUIL√îMETROS'
            return 'HORAS'
        df_frotas['Tipo_Controle'] = df_frotas.apply(determinar_tipo_controle, axis=1)

        # Retorna todos os dataframes processados
        return (
            df_merged, df_frotas, df_manutencoes,
            df_comp_regras, df_comp_historico,
            df_checklist_regras, df_checklist_itens, df_checklist_historico
        )

    except Exception as e:
        st.error(f"Erro ao ler e processar o banco de dados: {e}")
        st.stop()
        # Retorna dataframes vazios em caso de erro
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(),
                pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

                
    
def inserir_abastecimento(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO abastecimentos (
                "C√≥d. Equip.", Data, "Qtde Litros", Hod_Hor_Atual,
                Safra, "M√™s", "Classe Operacional", Matricula, Cod_Pessoa
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['data'],
            dados['qtde_litros'],
            dados['hod_hor_atual'],
            dados['safra'],
            dados['mes'],
            dados['classe_operacional'],
            dados.get('matricula'),
            dados.get('cod_pessoa')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao inserir dados no banco de dados: {e}")
        return False

def excluir_abastecimento(db_path: str, rowid: int) -> bool:
    """Exclui um registro de abastecimento do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        # Usar rowid √© a forma mais segura de deletar uma linha espec√≠fica
        sql = "DELETE FROM abastecimentos WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir dados do banco de dados: {e}")
        return False

def excluir_manutencao_componente(db_path: str, cod_equip: int, nome_componente: str, data: str, hod_hor: float) -> bool:
    """Exclui um registro de manuten√ß√£o de componente do banco de dados usando uma combina√ß√£o √∫nica de campos."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)
        nome_componente = str(nome_componente)
        data = str(data)
        hod_hor = float(hod_hor)
        
        # Debug: verificar todos os registros na tabela
        cursor.execute("SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico")
        all_records = cursor.fetchall()
        
        # Debug: verificar se h√° registros com valores similares
        cursor.execute(
            "SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico WHERE Cod_Equip = ?", 
            (cod_equip,)
        )
        similar_records = cursor.fetchall()
        
        # Primeiro, vamos verificar se o registro existe
        cursor.execute(
            "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        count = cursor.fetchone()[0]
        
        if count == 0:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - Nome Componente: {nome_componente} (tipo: {type(nome_componente)})
            - Data: {data} (tipo: {type(data)})
            - Hod_Hor: {hod_hor} (tipo: {type(hod_hor)})
            
            Registros similares encontrados (mesmo Cod_Equip):
            {similar_records}
            
            Todos os registros na tabela:
            {all_records}
            """
            st.error(debug_info)
            return False
        
        # Agora vamos excluir
        cursor.execute(
            "DELETE FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute(
                "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
                (cod_equip, nome_componente, data, hod_hor)
            )
            count_after = cursor.fetchone()[0]
            
            if count_after == 0:
                # For√ßar sincroniza√ß√£o do banco
                cursor.execute("PRAGMA wal_checkpoint(FULL)")
                cursor.execute("PRAGMA synchronous=FULL")
                conn.commit()
                
                # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                backup_success, backup_msg = save_backup_to_session_state()
                if backup_success:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Backup salvo: {backup_msg}")
                else:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Aviso: {backup_msg}")
                
                conn.close()
                return True
            else:
                st.error("Erro: Registro ainda existe ap√≥s exclus√£o")
                conn.close()
                return False
        else:
            st.error("Nenhum registro foi exclu√≠do")
            conn.close()
            return False
            
    except Exception as e:
        st.error(f"Erro ao excluir manuten√ß√£o de componente do banco de dados: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def excluir_manutencao(db_path: str, rowid: int) -> bool:
    """Exclui um registro de manuten√ß√£o do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = "DELETE FROM manutencoes WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir manuten√ß√£o do banco de dados: {e}")
        return False

def inserir_manutencao(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = 'INSERT INTO manutencoes (Cod_Equip, Data, Tipo_Servico, Hod_Hor_No_Servico) VALUES (?, ?, ?, ?)'
        params = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'])
        cursor.execute(sql, params)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False

def inserir_frota(db_path: str, dados: dict) -> bool:
    """Insere um novo registro de frota no banco de dados."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO frotas (
                COD_EQUIPAMENTO, DESCRICAO_EQUIPAMENTO, PLACA, 
                "Classe Operacional", ATIVO, tipo_combustivel
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['descricao'],
            dados['placa'],
            dados['classe_op'],
            dados['ativo'],
            dados.get('tipo_combustivel', 'Diesel S500')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False
    

def editar_abastecimento(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de abastecimento existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE abastecimentos SET
                "C√≥d. Equip." = ?, Data = ?, "Qtde Litros" = ?, Hod_Hor_Atual = ?, Safra = ?, Matricula = ?, Cod_Pessoa = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'], dados['data'], dados['qtde_litros'], dados['hod_hor_atual'], dados['safra'],
            dados.get('matricula'), dados.get('cod_pessoa'), rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar abastecimento: {e}")
        return False

def editar_manutencao(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de manuten√ß√£o existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE manutencoes SET
                Cod_Equip = ?, Data = ?, Tipo_Servico = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'], rowid)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar manuten√ß√£o: {e}")
        return False

def editar_manutencao_componente(db_path: str, rowid: int, dados: dict) -> bool:
    """Edita um registro de manuten√ß√£o de componente existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE componentes_historico 
            SET Cod_Equip = ?, nome_componente = ?, Observacoes = ?, Data = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'],
            dados['componente'],
            dados['acao'],
            dados['data'],
            dados['hod_hor_servico'],
            rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao editar manuten√ß√£o de componente no banco de dados: {e}")
        return False

def importar_abastecimentos_de_planilha(db_path: str, arquivo_carregado) -> tuple[int, int, str]:
    """L√™ uma planilha, verifica por duplicados, e insere os novos dados. Aceita opcionalmente as colunas Matricula e Cod_Pessoa."""
    try:
        df_novo = pd.read_excel(arquivo_carregado)
        
        mapa_colunas = {
            "C√≥d. Equip.": "C√≥d. Equip.",
            "Data": "Data",
            "Qtde Litros": "Qtde Litros",
            "Hod. Hor. Atual": "Hod_Hor_Atual",
            "Safra": "Safra",
            "M√™s": "M√™s",
            "Classe Operacional": "Classe Operacional",
            "Matricula": "Matricula",
            "Cod_Pessoa": "Cod_Pessoa",
        }
        df_novo = df_novo.rename(columns={k: v for k, v in mapa_colunas.items() if k in df_novo.columns})

        colunas_necessarias = ["C√≥d. Equip.", "Data", "Qtde Litros", "Hod_Hor_Atual", "Safra", "M√™s", "Classe Operacional"]
        colunas_opcionais = ["Matricula", "Cod_Pessoa"]
        colunas_faltando = [col for col in colunas_necessarias if col not in df_novo.columns]
        if colunas_faltando:
            return 0, 0, f"Erro: Colunas n√£o encontradas: {', '.join(colunas_faltando)}"
        conn = sqlite3.connect(db_path)
        df_existente = pd.read_sql_query("SELECT * FROM abastecimentos", conn)
        
        df_novo['Data'] = pd.to_datetime(df_novo['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')
        df_existente['Data'] = pd.to_datetime(df_existente['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')

        df_novo['chave_unica'] = df_novo['C√≥d. Equip.'].astype(str) + '_' + df_novo['Data'] + '_' + df_novo['Qtde Litros'].astype(str)
        df_existente['chave_unica'] = df_existente['C√≥d. Equip.'].astype(str) + '_' + df_existente['Data'] + '_' + df_existente['Qtde Litros'].astype(str)

        df_para_inserir = df_novo[~df_novo['chave_unica'].isin(df_existente['chave_unica'])]
        
        num_duplicados = len(df_novo) - len(df_para_inserir)

        if df_para_inserir.empty:
            return 0, num_duplicados, "Nenhum registo novo para importar. Todos os registos da planilha j√° existem na base de dados."

        colunas_insert = colunas_necessarias + [c for c in colunas_opcionais if c in df_para_inserir.columns]
        df_para_inserir_final = df_para_inserir[colunas_insert]
        registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
        
        cursor = conn.cursor()
        placeholders = ", ".join(["?"] * len(colunas_insert))
        sql = f"INSERT INTO abastecimentos ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
        cursor.executemany(sql, registros)
        
        conn.commit()
        num_inseridos = cursor.rowcount
        conn.close()
        
        mensagem_sucesso = f"{num_inseridos} registos novos foram importados com sucesso."
        if num_duplicados > 0:
            mensagem_sucesso += f" {num_duplicados} registos duplicados foram ignorados."
            
        return num_inseridos, num_duplicados, mensagem_sucesso

    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o: {e}"

def editar_frota(db_path: str, cod_equip: int, dados: dict) -> bool:
    """Atualiza um registro de frota existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE frotas SET
                DESCRICAO_EQUIPAMENTO = ?, PLACA = ?, "Classe Operacional" = ?, ATIVO = ?, tipo_combustivel = ?
            WHERE COD_EQUIPAMENTO = ?
        """
        valores = (dados['descricao'], dados['placa'], dados['classe_op'], dados['ativo'], dados.get('tipo_combustivel', 'Diesel S500'), cod_equip)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar frota: {e}")
        return False

# COLE ESTE BLOCO DE C√ìDIGO NO LOCAL INDICADO

def get_component_rules():
    """Busca todas as regras de componentes da base de dados."""
    with sqlite3.connect(DB_PATH) as conn:
        return pd.read_sql_query("SELECT * FROM componentes_regras", conn)

def add_component_rule(classe, componente, intervalo):
    """Adiciona uma nova regra de componente √† base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao) VALUES (?, ?, ?)",
                (classe, componente, intervalo)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def add_component_rule_advanced(classe, componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca", capacidade_litros=0.0):
    """Adiciona uma nova regra de componente com informa√ß√µes de lubrificante e tipo de manuten√ß√£o."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, tipo_manutencao, capacidade_litros) VALUES (?, ?, ?, ?, ?, ?)",
                (classe, componente, intervalo, lubrificante_id, tipo_manutencao, capacidade_litros)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def delete_component_rule(rule_id):
    """Remove uma regra de componente da base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM componentes_regras WHERE id_regra = ?", (rule_id,))
            conn.commit()
        return True, "Componente removido com sucesso."
    except Exception as e:
        return False, f"Erro ao remover componente: {e}"

def add_component_service(cod_equip, componente, data, hod_hor, obs):
    """Adiciona um novo registo de servi√ßo de componente ao hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, Observacoes) VALUES (?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def add_component_service_advanced(cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado=None, obs=""):
    """Adiciona um novo registo de servi√ßo de componente com informa√ß√µes detalhadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def get_component_status(cod_equip, componente):
    """Obt√©m o status atual de um componente espec√≠fico de um equipamento."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            # Buscar a √∫ltima manuten√ß√£o do componente
            query = """
            SELECT Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            ORDER BY Data DESC, Hod_Hor_No_Servico DESC
            LIMIT 1
            """
            df_ultima = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            
            # Buscar a regra do componente para obter o intervalo
            query_regra = """
            SELECT intervalo_padrao, lubrificante_id, tipo_manutencao
            FROM componentes_regras cr
            JOIN frotas f ON cr.classe_operacional = f."Classe Operacional"
            WHERE f.COD_EQUIPAMENTO = ? AND cr.nome_componente = ?
            """
            df_regra = pd.read_sql_query(query_regra, conn, params=(cod_equip, componente))
            
            # Buscar o hod√¥metro/hor√≠metro atual do equipamento
            query_hod = """
            SELECT Hod_Hor_Atual FROM abastecimentos 
            WHERE Cod_Equip = ? 
            ORDER BY Data DESC, Hod_Hor_Atual DESC 
            LIMIT 1
            """
            df_hod = pd.read_sql_query(query_hod, conn, params=(cod_equip,))
            
            return df_ultima, df_regra, df_hod
            
    except Exception as e:
        st.error(f"Erro ao obter status do componente: {e}")
        return None, None, None

def get_component_maintenance_count(cod_equip, componente):
    """Obt√©m o n√∫mero total de manuten√ß√µes realizadas em um componente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT COUNT(*) as total_manutencoes,
                   COUNT(CASE WHEN tipo_servico = 'Troca' THEN 1 END) as total_trocas,
                   COUNT(CASE WHEN tipo_servico = 'Remonta' THEN 1 END) as total_remontas
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            """
            df_count = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            return df_count.iloc[0] if not df_count.empty else {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}
            
    except Exception as e:
        st.error(f"Erro ao obter contagem de manuten√ß√µes: {e}")
        return {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}

def editar_manutencao_componente_advanced(DB_PATH, rowid, dados_editados):
    """Edita uma manuten√ß√£o de componente com informa√ß√µes avan√ßadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_historico 
                SET Cod_Equip = ?, nome_componente = ?, Data = ?, Hod_Hor_No_Servico = ?, 
                    Observacoes = ?, tipo_servico = ?, lubrificante_utilizado = ?
                WHERE rowid = ?
            """, (
                dados_editados['cod_equip'],
                dados_editados['componente'],
                dados_editados['data'],
                dados_editados['hod_hor_servico'],
                dados_editados['acao'],
                dados_editados['tipo_servico'],
                dados_editados['lubrificante_utilizado'],
                rowid
            ))
            conn.commit()
        return True, "Manuten√ß√£o de componente atualizada com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar manuten√ß√£o de componente: {e}"

def update_component_rule(rule_id, nome_componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca"):
    """Atualiza uma regra de componente existente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_regras 
                SET nome_componente = ?, intervalo_padrao = ?, lubrificante_id = ?, tipo_manutencao = ?
                WHERE id_regra = ?
            """, (nome_componente, intervalo, lubrificante_id, tipo_manutencao, rule_id))
            conn.commit()
        return True, f"Componente '{nome_componente}' atualizado com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar componente: {e}"

def get_frota_combustivel(cod_equip):
    """Obt√©m o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tipo_combustivel FROM frotas WHERE COD_EQUIPAMENTO = ?", (cod_equip,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        st.error(f"Erro ao obter tipo de combust√≠vel: {e}")
        return None

def update_frota_combustivel(cod_equip, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE COD_EQUIPAMENTO = ?", (tipo_combustivel, cod_equip))
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel: {e}"

def update_classe_combustivel(classe_operacional, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de todas as frotas de uma classe."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE \"Classe Operacional\" = ?", (tipo_combustivel, classe_operacional))
            rows_updated = cursor.rowcount
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel} em {rows_updated} frotas da classe {classe_operacional}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel da classe: {e}"

def add_tipo_combustivel_column():
    """Adiciona a coluna tipo_combustivel √† tabela frotas se ela n√£o existir."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            # Verificar se a coluna existe
            cursor.execute("PRAGMA table_info(frotas)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'tipo_combustivel' not in columns:
                cursor.execute("ALTER TABLE frotas ADD COLUMN tipo_combustivel TEXT DEFAULT 'Diesel S500'")
                conn.commit()
                return True, "Coluna tipo_combustivel adicionada com sucesso"
            else:
                return True, "Coluna tipo_combustivel j√° existe"
    except Exception as e:
        return False, f"Erro ao adicionar coluna tipo_combustivel: {e}"

def ensure_motoristas_schema():
    """Garante a exist√™ncia da tabela de motoristas e das colunas de v√≠nculo em abastecimentos."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS motoristas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    codigo_pessoa TEXT,
                    matricula TEXT UNIQUE,
                    nome TEXT,
                    ativo TEXT DEFAULT 'ATIVO'
                )
                """
            )
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_matricula ON motoristas(matricula)")
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_codigo_pessoa ON motoristas(codigo_pessoa)")

            cursor.execute("PRAGMA table_info(abastecimentos)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'Matricula' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Matricula TEXT")
            if 'Cod_Pessoa' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Cod_Pessoa TEXT")
            conn.commit()
        return True, "Esquema de motoristas verificado"
    except Exception as e:
        return False, f"Erro ao verificar esquema de motoristas: {e}"

def get_all_motoristas() -> pd.DataFrame:
    """Retorna o DataFrame de motoristas."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM motoristas", conn)
    except Exception:
        return pd.DataFrame(columns=['id', 'codigo_pessoa', 'matricula', 'nome', 'ativo'])

def importar_motoristas_de_planilha(db_path: str, arquivo_carregado):
    """Importa motoristas a partir de planilha Excel. Espera colunas: Matricula, Nome e opcional Cod_Pessoa/C√≥digo Pessoa."""
    try:
        df_mot = pd.read_excel(arquivo_carregado)
        df_mot.columns = [c.strip() for c in df_mot.columns]
        renomeios = {
            'Matr√≠cula': 'Matricula', 'matricula': 'Matricula', 'MATRICULA': 'Matricula',
            'Nome': 'Nome', 'nome': 'Nome', 'NOME': 'Nome',
            'Cod_Pessoa': 'Cod_Pessoa', 'C√≥digo Pessoa': 'Cod_Pessoa', 'codigo_pessoa': 'Cod_Pessoa', 'CODIGO_PESSOA': 'Cod_Pessoa'
        }
        df_mot.rename(columns={k: v for k, v in renomeios.items() if k in df_mot.columns}, inplace=True)
        obrig = ['Matricula', 'Nome']
        faltando = [c for c in obrig if c not in df_mot.columns]
        if faltando:
            return 0, 0, f"Erro: Colunas obrigat√≥rias n√£o encontradas: {', '.join(faltando)}"
        if 'Cod_Pessoa' not in df_mot.columns:
            df_mot['Cod_Pessoa'] = None
        df_mot = df_mot.dropna(subset=['Matricula', 'Nome']).copy()
        df_mot['Matricula'] = df_mot['Matricula'].astype(str).str.strip()
        df_mot['Nome'] = df_mot['Nome'].astype(str).str.strip()
        df_mot['Cod_Pessoa'] = df_mot['Cod_Pessoa'].astype(str).str.strip()
        df_mot = df_mot.drop_duplicates(subset=['Matricula'])
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            existentes = pd.read_sql_query("SELECT matricula FROM motoristas", conn)
            set_exist = set(existentes['matricula'].astype(str)) if not existentes.empty else set()
            df_novos = df_mot[~df_mot['Matricula'].isin(set_exist)].copy()
            if df_novos.empty:
                return 0, len(df_mot), "Nenhum motorista novo para importar. Todos j√° existem."
            registros = [
                (row.get('Cod_Pessoa', None), row['Matricula'], row['Nome'], 'ATIVO')
                for _, row in df_novos.iterrows()
            ]
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO motoristas (codigo_pessoa, matricula, nome, ativo) VALUES (?, ?, ?, ?)",
                registros
            )
            conn.commit()
            inseridos = cur.rowcount if cur.rowcount is not None else len(registros)
            duplicados = len(df_mot) - len(df_novos)
            return inseridos, duplicados, f"{inseridos} motoristas importados com sucesso. {duplicados} j√° existiam."
    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o de motoristas: {e}"
    
def ensure_pneus_schema():
    """Garante a exist√™ncia da tabela de hist√≥rico de pneus."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pneus_historico (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    Cod_Equip INTEGER,
                    posicao TEXT,
                    marca TEXT,
                    modelo TEXT,
                    data_instalacao TEXT,
                    hodometro_instalacao REAL,
                    
                    observacoes TEXT,
                    status TEXT DEFAULT 'Ativo',
                    vida_atual INTEGER DEFAULT 1
                )
            """)
            # Adiciona colunas se n√£o existirem
            cursor.execute("PRAGMA table_info(pneus_historico)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'status' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN status TEXT DEFAULT 'Ativo'")
            if 'vida_atual' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN vida_atual INTEGER DEFAULT 1")
            conn.commit()
        return True, "Tabela de pneus verificada"
    except Exception as e:
        return False, f"Erro ao criar tabela de pneus: {e}"

def importar_pneus_de_planilha(db_path: str, arquivo_carregado):
    """Importa hist√≥rico de pneus de uma planilha Excel, verificando duplicatas."""
    try:
        df_pneus = pd.read_excel(arquivo_carregado)
        df_pneus.columns = [c.strip() for c in df_pneus.columns]
        obrig = ['Cod_Equip', 'posicao', 'marca', 'modelo', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao']
        faltando = [c for c in obrig if c not in df_pneus.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        if 'observacoes' not in df_pneus.columns:
            df_pneus['observacoes'] = ""
        
        
        # Limpar dados e remover linhas com valores nulos obrigat√≥rios
        df_pneus = df_pneus.dropna(subset=['Cod_Equip', 'posicao', 'numero_fogo'])
        
        # Normalizar tipos de dados
        df_pneus['Cod_Equip'] = df_pneus['Cod_Equip'].astype(str)
        df_pneus['posicao'] = df_pneus['posicao'].astype(str).str.strip()
        df_pneus['numero_fogo'] = df_pneus['numero_fogo'].astype(str).str.strip()
        df_pneus['data_instalacao'] = pd.to_datetime(df_pneus['data_instalacao']).dt.strftime('%Y-%m-%d')
        
        # Remover duplicatas na pr√≥pria planilha baseada em chave √∫nica
        df_pneus = df_pneus.drop_duplicates(subset=['Cod_Equip', 'posicao', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Buscar registros existentes para verificar duplicatas
            df_existente = pd.read_sql_query("SELECT Cod_Equip, posicao, numero_fogo, data_instalacao, hodometro_instalacao FROM pneus_historico", conn)
            
            if not df_existente.empty:
                # Normalizar dados existentes para compara√ß√£o
                df_existente['Cod_Equip'] = df_existente['Cod_Equip'].astype(str)
                df_existente['posicao'] = df_existente['posicao'].astype(str).str.strip()
                df_existente['numero_fogo'] = df_existente['numero_fogo'].astype(str).str.strip()
                df_existente['data_instalacao'] = pd.to_datetime(df_existente['data_instalacao']).dt.strftime('%Y-%m-%d')
                
                # Criar chaves √∫nicas para compara√ß√£o
                df_pneus['chave_unica'] = (df_pneus['Cod_Equip'] + '_' + 
                                          df_pneus['posicao'] + '_' + 
                                          df_pneus['numero_fogo'] + '_' + 
                                          df_pneus['data_instalacao'] + '_' + 
                                          df_pneus['hodometro_instalacao'].astype(str))
                
                df_existente['chave_unica'] = (df_existente['Cod_Equip'] + '_' + 
                                              df_existente['posicao'] + '_' + 
                                              df_existente['numero_fogo'] + '_' + 
                                              df_existente['data_instalacao'] + '_' + 
                                              df_existente['hodometro_instalacao'].astype(str))
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_pneus[~df_pneus['chave_unica'].isin(df_existente['chave_unica'])]
            else:
                df_para_inserir = df_pneus
            
            num_duplicados = len(df_pneus) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum pneu novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = obrig + ['observacoes']
            # Garantir que a coluna observacoes exista no DataFrame
            if 'observacoes' not in df_para_inserir.columns:
                df_para_inserir['observacoes'] = ''
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.fillna('').to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO pneus_historico ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} pneus novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar pneus: {e}"

def get_pneus_historico(cod_equip=None):
    """Retorna o hist√≥rico de pneus, opcionalmente filtrando por frota."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            query = "SELECT * FROM pneus_historico"
            params = ()
            if cod_equip:
                query += " WHERE Cod_Equip = ?"
                params = (cod_equip,)
            return pd.read_sql_query(query, conn, params=params)
    except Exception:
        return pd.DataFrame()

def ensure_precos_combustivel_schema():
    """Garante a exist√™ncia da tabela de pre√ßos por tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS precos_combustivel (
                    tipo_combustivel TEXT PRIMARY KEY,
                    preco REAL
                )
                """
            )
            tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
            for t in tipos:
                cur.execute("INSERT OR IGNORE INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?)", (t, NULL))
            conn.commit()
        return True, "Tabela de pre√ßos verificada"
    except Exception as e:
        return False, f"Erro ao verificar tabela de pre√ßos: {e}"

def get_precos_combustivel_map() -> dict:
    """Retorna um dicion√°rio {tipo_combustivel: preco}."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            dfp = pd.read_sql_query("SELECT tipo_combustivel, preco FROM precos_combustivel", conn)
        return {row['tipo_combustivel']: row['preco'] for _, row in dfp.iterrows()}
    except Exception:
        return {}

def upsert_preco_combustivel(tipo: str, preco: float) -> tuple[bool, str]:
    """Cria/atualiza pre√ßo para um tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?) ON CONFLICT(tipo_combustivel) DO UPDATE SET preco=excluded.preco",
                (tipo, preco)
            )
            conn.commit()
        return True, f"Pre√ßo atualizado para {tipo}"
    except Exception as e:
        return False, f"Erro ao atualizar pre√ßo: {e}"
    
def ensure_lubrificantes_schema():
    """Garante a exist√™ncia da tabela de lubrificantes, movimenta√ß√µes e almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            
            # Tabela de lubrificantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT,
                    viscosidade TEXT,
                    quantidade_estoque REAL,
                    unidade TEXT,
                    observacoes TEXT
                )
            """)
            
            # Verificar e adicionar coluna 'tipo' se n√£o existir
            cursor.execute("PRAGMA table_info(lubrificantes)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'tipo' not in cols:
                cursor.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
            
            # Tabela de almoxarifados
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifados (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT NOT NULL,
                    tipo TEXT DEFAULT 'fixo', -- 'fixo' para oficina, 'movel' para caminh√µes
                    localizacao TEXT,
                    responsavel TEXT,
                    observacoes TEXT,
                    ativo BOOLEAN DEFAULT 1
                )
            """)
            
            # Tabela de estoque por almoxarifado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifado_estoque (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_almoxarifado INTEGER,
                    id_lubrificante INTEGER,
                    quantidade_estoque REAL DEFAULT 0,
                    unidade TEXT,
                    data_atualizacao TEXT,
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id),
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    UNIQUE(id_almoxarifado, id_lubrificante)
                )
            """)
            
            # Tabela de movimenta√ß√µes (atualizada para incluir almoxarifado)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes_movimentacoes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_lubrificante INTEGER,
                    id_almoxarifado INTEGER,
                    tipo TEXT, -- 'entrada' ou 'saida'
                    quantidade REAL,
                    data TEXT,
                    cod_equip INTEGER,
                    observacoes TEXT,
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id)
                )
            """)
            
            # Verificar se a coluna id_almoxarifado existe na tabela de movimenta√ß√µes
            cursor.execute("PRAGMA table_info(lubrificantes_movimentacoes)")
            cols_mov = [c[1] for c in cursor.fetchall()]
            if 'id_almoxarifado' not in cols_mov:
                cursor.execute("ALTER TABLE lubrificantes_movimentacoes ADD COLUMN id_almoxarifado INTEGER")
            
            conn.commit()
        return True, "Tabelas de lubrificantes e almoxarifados verificadas"
    except Exception as e:
        return False, f"Erro ao criar tabelas de lubrificantes: {e}"
    
def add_almoxarifado(nome, tipo="fixo", localizacao="", responsavel="", observacoes=""):
    """Adiciona um novo almoxarifado."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO almoxarifados (nome, tipo, localizacao, responsavel, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, tipo, localizacao, responsavel, observacoes)
            )
            conn.commit()
        return True, "Almoxarifado cadastrado com sucesso!"
    except Exception as e:
        return False, f"Erro: {e}"

def get_almoxarifados():
    """Retorna todos os almoxarifados ativos."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            df = pd.read_sql("SELECT * FROM almoxarifados WHERE ativo = 1 ORDER BY nome", conn)
        return df
    except Exception as e:
        return pd.DataFrame()

def get_estoque_por_almoxarifado(id_lubrificante):
    """Retorna o estoque de um lubrificante distribu√≠do por almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT 
                a.nome as almoxarifado,
                a.tipo,
                COALESCE(ae.quantidade_estoque, 0) as quantidade,
                COALESCE(ae.unidade, l.unidade) as unidade,
                a.localizacao,
                a.responsavel
            FROM almoxarifados a
            CROSS JOIN lubrificantes l
            LEFT JOIN almoxarifado_estoque ae ON a.id = ae.id_almoxarifado AND l.id = ae.id_lubrificante
            WHERE l.id = ? AND a.ativo = 1
            ORDER BY a.nome
            """
            df = pd.read_sql(query, conn, params=(id_lubrificante,))
        return df
    except Exception as e:
        return pd.DataFrame()

def atualizar_estoque_almoxarifado(id_almoxarifado, id_lubrificante, quantidade, unidade):
    """Atualiza o estoque de um lubrificante em um almoxarifado espec√≠fico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO almoxarifado_estoque 
                (id_almoxarifado, id_lubrificante, quantidade_estoque, unidade, data_atualizacao) 
                VALUES (?, ?, ?, ?, ?)
            """, (id_almoxarifado, id_lubrificante, quantidade, unidade, date.today().strftime("%Y-%m-%d")))
            conn.commit()
        return True, "Estoque atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao atualizar estoque: {e}"

def add_lubrificante(nome, viscosidade, quantidade, unidade, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes (nome, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, viscosidade, quantidade, unidade, observacoes)
            )
            conn.commit()
        return True, "Lubrificante cadastrado!"
    except Exception as e:
        return False, f"Erro: {e}"

def importar_lubrificantes_de_planilha(db_path: str, arquivo_carregado):
    """Importa lubrificantes de uma planilha Excel, verificando duplicatas."""
    try:
        df_lub = pd.read_excel(arquivo_carregado)
        df_lub.columns = [c.strip() for c in df_lub.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome': 'nome',
            'tipo': 'tipo',
            'viscosidade': 'viscosidade',
            'quantidade_estoque': 'quantidade_estoque',
            'unidade': 'unidade',
            'observacoes': 'observacoes'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_lub.columns:
                df_lub = df_lub.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome']
        faltando = [c for c in obrig if c not in df_lub.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'tipo' not in df_lub.columns:
            df_lub['tipo'] = '√≥leo'
        if 'viscosidade' not in df_lub.columns:
            df_lub['viscosidade'] = ''
        if 'quantidade_estoque' not in df_lub.columns:
            df_lub['quantidade_estoque'] = 0
        if 'unidade' not in df_lub.columns:
            df_lub['unidade'] = 'L'
        if 'observacoes' not in df_lub.columns:
            df_lub['observacoes'] = ''
        
        # Limpar e normalizar dados
        df_lub = df_lub.dropna(subset=['nome'])
        df_lub['nome'] = df_lub['nome'].astype(str).str.strip()
        df_lub['tipo'] = df_lub['tipo'].astype(str).str.strip().fillna('√≥leo')
        df_lub['viscosidade'] = df_lub['viscosidade'].astype(str).str.strip().fillna('')
        df_lub['quantidade_estoque'] = pd.to_numeric(df_lub['quantidade_estoque'], errors='coerce').fillna(0)
        df_lub['unidade'] = df_lub['unidade'].astype(str).str.strip().fillna('L')
        df_lub['observacoes'] = df_lub['observacoes'].astype(str).str.strip().fillna('')
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome
        df_lub = df_lub.drop_duplicates(subset=['nome'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que a tabela existe com a coluna tipo
            ensure_lubrificantes_schema()
            
            # Buscar lubrificantes existentes
            df_existente = pd.read_sql_query("SELECT nome FROM lubrificantes", conn)
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome'] = df_existente['nome'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_lub[~df_lub['nome'].isin(df_existente['nome'])]
            else:
                df_para_inserir = df_lub
            
            num_duplicados = len(df_lub) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum lubrificante novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = ['nome', 'tipo', 'viscosidade', 'quantidade_estoque', 'unidade', 'observacoes']
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO lubrificantes ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} lubrificantes novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar lubrificantes: {e}"

def importar_componentes_de_planilha(db_path: str, arquivo_carregado, classe_operacional: str):
    """Importa componentes de uma planilha Excel, verificando duplicatas e criando lubrificantes se necess√°rio."""
    try:
        df_comp = pd.read_excel(arquivo_carregado)
        df_comp.columns = [c.strip() for c in df_comp.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome_componente': 'nome_componente',
            'componente': 'nome_componente',
            'intervalo_padrao': 'intervalo_padrao',
            'intervalo': 'intervalo_padrao',
            'lubrificante_nome': 'lubrificante_nome',
            'lubrificante': 'lubrificante_nome',
            'capacidade_litros': 'capacidade_litros',
            'capacidade': 'capacidade_litros'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_comp.columns:
                df_comp = df_comp.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome_componente', 'intervalo_padrao']
        faltando = [c for c in obrig if c not in df_comp.columns]
        if faltando:
            return 0, 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'lubrificante_nome' not in df_comp.columns:
            df_comp['lubrificante_nome'] = None
        if 'capacidade_litros' not in df_comp.columns:
            df_comp['capacidade_litros'] = 0.0
        
        # Limpar e normalizar dados
        df_comp = df_comp.dropna(subset=['nome_componente'])
        df_comp['nome_componente'] = df_comp['nome_componente'].astype(str).str.strip()
        df_comp['intervalo_padrao'] = pd.to_numeric(df_comp['intervalo_padrao'], errors='coerce')
        df_comp = df_comp.dropna(subset=['intervalo_padrao'])
        df_comp['lubrificante_nome'] = df_comp['lubrificante_nome'].astype(str).str.strip().replace('nan', None)
        df_comp['capacidade_litros'] = pd.to_numeric(df_comp['capacidade_litros'], errors='coerce').fillna(0.0)
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome do componente
        df_comp = df_comp.drop_duplicates(subset=['nome_componente'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que as tabelas existem
            ensure_lubrificantes_schema()
            
            # Verificar se a tabela componentes_regras tem a coluna capacidade_litros
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'capacidade_litros' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN capacidade_litros REAL DEFAULT 0.0")
            
            # Buscar componentes existentes na classe
            df_existente = pd.read_sql_query(
                "SELECT nome_componente FROM componentes_regras WHERE classe_operacional = ?", 
                conn, params=(classe_operacional,)
            )
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome_componente'] = df_existente['nome_componente'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem na classe
                df_para_inserir = df_comp[~df_comp['nome_componente'].isin(df_existente['nome_componente'])]
            else:
                df_para_inserir = df_comp
            
            num_duplicados = len(df_comp) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, 0, "Nenhum componente novo para importar. Todos os registros da planilha j√° existem na classe selecionada."
            
            # Processar lubrificantes
            lubrificantes_criados = 0
            for _, row in df_para_inserir.iterrows():
                if pd.notna(row['lubrificante_nome']) and row['lubrificante_nome']:
                    # Verificar se o lubrificante existe
                    df_lub_existente = pd.read_sql_query(
                        "SELECT id FROM lubrificantes WHERE nome = ?", 
                        conn, params=(row['lubrificante_nome'],)
                    )
                    
                    if df_lub_existente.empty:
                        # Criar lubrificante automaticamente
                        cur = conn.cursor()
                        cur.execute(
                            "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                            (row['lubrificante_nome'], '√≥leo', '', 0, 'L', f'Criado automaticamente durante importa√ß√£o de componentes')
                        )
                        lubrificantes_criados += 1
                        
                        # Buscar o ID do lubrificante criado
                        lub_id = cur.lastrowid
                    else:
                        lub_id = df_lub_existente.iloc[0]['id']
                else:
                    lub_id = None
                
                # Inserir componente
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, capacidade_litros) VALUES (?, ?, ?, ?, ?)",
                    (classe_operacional, row['nome_componente'], row['intervalo_padrao'], lub_id, row['capacidade_litros'])
                )
            
            conn.commit()
            num_inseridos = len(df_para_inserir)
            
            mensagem_sucesso = f"{num_inseridos} componentes foram importados com sucesso para a classe '{classe_operacional}'."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} componentes duplicados foram ignorados."
            if lubrificantes_criados > 0:
                mensagem_sucesso += f" {lubrificantes_criados} lubrificantes foram criados automaticamente."
            
            return num_inseridos, num_duplicados, lubrificantes_criados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, 0, f"Erro ao importar componentes: {e}"

def movimentar_lubrificante(id_lubrificante, tipo, quantidade, data, cod_equip=None, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes_movimentacoes (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes)
            )
            # Atualiza estoque
            sinal = 1 if tipo == "entrada" else -1
            cur.execute(
                "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque + ? WHERE id = ?",
                (sinal * quantidade, id_lubrificante)
            )
            conn.commit()
        return True, "Movimenta√ß√£o registrada!"
    except Exception as e:
        return False, f"Erro: {e}"

@st.cache_data(ttl=120)
def filtrar_dados(df: pd.DataFrame, opts: dict) -> pd.DataFrame:
    # Garante que a coluna de data √© do tipo datetime
    df['Data'] = pd.to_datetime(df['Data'])
    
    # Filtra por per√≠odo de datas
    df_filtrado = df[
        (df['Data'].dt.date >= opts['data_inicio']) & 
        (df['Data'].dt.date <= opts['data_fim'])
    ]
    
    # Filtra pelas outras sele√ß√µes, se existirem
    if opts.get("classes_op"):
        df_filtrado = df_filtrado[df_filtrado["Classe_Operacional"].isin(opts["classes_op"])]
    
    if opts.get("safras"):
        df_filtrado = df_filtrado[df_filtrado["Safra"].isin(opts["safras"])]
        
    return df_filtrado.copy()

@st.cache_data(show_spinner="Calculando plano de manuten√ß√£o...", ttl=300)
def build_component_maintenance_plan(_df_frotas: pd.DataFrame, _df_abastecimentos: pd.DataFrame, _df_componentes_regras: pd.DataFrame, _df_componentes_historico: pd.DataFrame) -> pd.DataFrame:
    latest_readings = _df_abastecimentos.sort_values('Data').groupby('Cod_Equip')['Hod_Hor_Atual'].last()
    plan_data = []

    for _, frota_row in _df_frotas.iterrows():
        cod_equip = frota_row['Cod_Equip']
        classe_op = frota_row.get('Classe_Operacional')
        hod_hor_atual = latest_readings.get(cod_equip)

        if pd.isna(hod_hor_atual) or not classe_op:
            continue
        
        regras_da_classe = _df_componentes_regras[_df_componentes_regras['classe_operacional'] == classe_op]
        if regras_da_classe.empty:
            continue

        unidade = 'km' if frota_row['Tipo_Controle'] == 'QUIL√îMETROS' else 'h'
        alerta_default = ALERTAS_MANUTENCAO.get(frota_row['Tipo_Controle'], {}).get('default', 500)
        
        record = {
            'Cod_Equip': cod_equip, 
            'Equipamento': frota_row.get('DESCRICAO_EQUIPAMENTO'), 
            'Leitura_Atual': hod_hor_atual, 
            'Unidade': unidade, 
            'Qualquer_Alerta': False, 
            'Alertas': []
        }

        for _, regra in regras_da_classe.iterrows():
            componente = regra['nome_componente']
            intervalo = regra['intervalo_padrao']
            
            historico_componente = _df_componentes_historico[
                (_df_componentes_historico['Cod_Equip'] == cod_equip) &
                (_df_componentes_historico['nome_componente'] == componente)
            ]
            
            ultimo_servico_hod_hor = 0
            if not historico_componente.empty:
                ultimo_servico_hod_hor = historico_componente['Hod_Hor_No_Servico'].max()

            prox_servico = ((ultimo_servico_hod_hor // intervalo) * intervalo) + intervalo
            while prox_servico < hod_hor_atual:
                prox_servico += intervalo

            restante = prox_servico - hod_hor_atual
            
            record[f'Restante_{componente}'] = restante
            
            if restante <= alerta_default:
                record['Qualquer_Alerta'] = True
                record['Alertas'].append(componente)

        plan_data.append(record)

    # üîπ Garante que sempre retorna um DataFrame com as colunas b√°sicas
    if not plan_data:
        return pd.DataFrame(columns=['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Qualquer_Alerta', 'Alertas'])

    return pd.DataFrame(plan_data)

def prever_manutencoes(df_veiculos: pd.DataFrame, df_abastecimentos: pd.DataFrame, plan_df: pd.DataFrame) -> pd.DataFrame:
    """Estima as datas das pr√≥ximas manuten√ß√µes com base no uso m√©dio."""
    if plan_df.empty or 'Leitura_Atual' not in plan_df.columns:
        return pd.DataFrame()

    # Calcula o uso di√°rio m√©dio de cada ve√≠culo
    uso_diario = {}
    for cod_equip in df_abastecimentos['Cod_Equip'].unique():
        dados_equip = df_abastecimentos[df_abastecimentos['Cod_Equip'] == cod_equip].sort_values('Data')
        if len(dados_equip) > 1:
            total_dias = (dados_equip['Data'].max() - dados_equip['Data'].min()).days
            total_uso = dados_equip['Hod_Hor_Atual'].max() - dados_equip['Hod_Hor_Atual'].min()
            if total_dias > 0 and total_uso > 0: # Garante que houve uso e passagem de tempo
                uso_diario[cod_equip] = total_uso / total_dias

    previsoes = []
    servicos_nomes = [col.replace('Restante_', '') for col in plan_df.columns if 'Restante_' in col]

    for _, row in plan_df.iterrows():
        cod_equip = row['Cod_Equip']
        uso = uso_diario.get(cod_equip)
        if uso:
            for nome_servico in servicos_nomes:
                col_restante = f'Restante_{nome_servico}'
                if col_restante in row and pd.notna(row[col_restante]):
                    dias_para_manut = row[col_restante] / uso
                    data_prevista = datetime.now() + pd.Timedelta(days=dias_para_manut)
                    previsoes.append({
                        'Equipamento': row['Equipamento'],
                        'Manuten√ß√£o': nome_servico,
                        'Data Prevista': data_prevista.strftime('%d/%m/%Y'),
                        'Dias Restantes': int(dias_para_manut)
                    })

    if not previsoes:
        return pd.DataFrame()

    df_previsoes = pd.DataFrame(previsoes)
    return df_previsoes.sort_values('Dias Restantes')

# ---------------------------
# Fun√ß√µes para Checklists
# ---------------------------

@st.cache_data(ttl=120)
def get_checklist_rules():
    """Busca todas as regras de checklist do banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM checklist_regras", conn)
    except Exception as e:
        st.error(f"Erro ao buscar regras de checklist: {e}")
        return pd.DataFrame()

@st.cache_data(ttl=120)
def get_checklist_items(id_regra):
    """Busca os itens de checklist para uma determinada regra."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query(
                "SELECT * FROM checklist_itens WHERE id_regra = ?",
                conn,
                params=(id_regra,)
            )
    except Exception as e:
        st.error(f"Erro ao buscar itens de checklist: {e}")
        return pd.DataFrame()

# ---------------------------
# CRUD para Checklists
# ---------------------------

def add_checklist_rule(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra de checklist ao banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
        return True, "Regra de checklist adicionada com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar regra de checklist: {e}"

def add_checklist_rule_and_get_id(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra e devolve o ID criado (ou None em erro).

    Mant√©m a fun√ß√£o "add_checklist_rule" para compatibilidade, mas quando for
    necess√°rio o ID imediatamente ap√≥s a cria√ß√£o, utilize esta fun√ß√£o.
    """
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        st.error(f"Erro ao adicionar regra de checklist: {e}")
        return None

def edit_checklist_rule(id_regra, classe_operacional, titulo_checklist, turno, frequencia):
    """Edita uma regra de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_regras
                SET classe_operacional = ?, titulo_checklist = ?, frequencia = ?, turno = ?
                WHERE id_regra = ?
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno, id_regra)
            )
            conn.commit()
        return True, "Regra de checklist atualizada com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar regra de checklist: {e}"

def delete_checklist_rule(id_regra):
    """Remove uma regra de checklist e seus itens associados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_regra = ?", (id_regra,))
            cursor.execute("DELETE FROM checklist_regras WHERE id_regra = ?", (id_regra,))
            conn.commit()
        return True, "Regra de checklist removida com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover regra de checklist: {e}"

def add_checklist_item(id_regra, nome_item):
    """Adiciona um novo item de checklist a uma regra existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_itens (id_regra, nome_item)
                VALUES (?, ?)
                """ ,
                (id_regra, nome_item)
            )
            conn.commit()
        return True, "Item de checklist adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar item de checklist: {e}"

def edit_checklist_item(id_item, nome_item):
    """Edita um item de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_itens
                SET nome_item = ?
                WHERE id_item = ?
                """ ,
                (nome_item, id_item)
            )
            conn.commit()
        return True, "Item de checklist atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar item de checklist: {e}"

def delete_checklist_item(id_item):
    """Remove um item de checklist."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_item = ?", (id_item,))
            conn.commit()
        return True, "Item de checklist removido com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover item de checklist: {e}"

def save_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno, status_geral):
    """Salva um checklist preenchido no hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_historico 
                (Cod_Equip, titulo_checklist, data_preenchimento, turno, status_geral) 
                VALUES (?, ?, ?, ?, ?)
                """ ,
                (cod_equip, titulo_checklist, data_preenchimento, turno, status_geral)
            )
            conn.commit()
    except Exception as e:
        st.error(f"Erro ao salvar hist√≥rico de checklist: {e}")

def delete_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno):
    """Remove um registro do hist√≥rico de checklists usando uma combina√ß√£o √∫nica de campos."""
    try:
        # Primeira tentativa: usar conex√£o direta
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)  # Converter numpy.int64 para int
        titulo_checklist = str(titulo_checklist)
        data_preenchimento = str(data_preenchimento)
        turno = str(turno)
        
        # Debug: verificar todos os registros na tabela ANTES da exclus√£o
        cursor.execute("SELECT rowid, Cod_Equip, titulo_checklist, data_preenchimento, turno FROM checklist_historico")
        all_records_before = cursor.fetchall()
        
        # Tentar encontrar o registro com diferentes abordagens
        rowid = None
        
        # Primeira tentativa: busca exata
        cursor.execute(
            "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
            (cod_equip, titulo_checklist, data_preenchimento, turno)
        )
        result = cursor.fetchone()
        
        if result:
            rowid = result[0]
        else:
            # Segunda tentativa: buscar apenas por Cod_Equip, t√≠tulo e turno (ignorar data)
            cursor.execute(
                "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND turno = ?", 
                (cod_equip, titulo_checklist, turno)
            )
            result = cursor.fetchone()
            
            if result:
                rowid = result[0]
            else:
                # Terceira tentativa: buscar apenas por Cod_Equip e t√≠tulo
                cursor.execute(
                    "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ?", 
                    (cod_equip, titulo_checklist)
                )
                result = cursor.fetchone()
                
                if result:
                    rowid = result[0]
        
        if rowid is None:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - T√≠tulo: {titulo_checklist} (tipo: {type(titulo_checklist)})
            - Data: {data_preenchimento} (tipo: {type(data_preenchimento)})
            - Turno: {turno} (tipo: {type(turno)})
            
            Todos os registros na tabela ANTES da exclus√£o:
            {all_records_before}
            """
            conn.close()
            return False, debug_info
        
        # Agora vamos excluir usando rowid
        cursor.execute("DELETE FROM checklist_historico WHERE rowid = ?", (rowid,))
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute("SELECT COUNT(*) FROM checklist_historico WHERE rowid = ?", (rowid,))
            count_after = cursor.fetchone()[0]
            
            # Verificar tamb√©m se o registro ainda existe pelos outros campos
            cursor.execute(
                "SELECT COUNT(*) FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
                (cod_equip, titulo_checklist, data_preenchimento, turno)
            )
            count_by_fields = cursor.fetchone()[0]
            
            if count_after == 0 and count_by_fields == 0:
                 # Verificar o total de registros na tabela
                 cursor.execute("SELECT COUNT(*) FROM checklist_historico")
                 total_after = cursor.fetchone()[0]
                 
                 # For√ßar sincroniza√ß√£o do banco
                 cursor.execute("PRAGMA wal_checkpoint(FULL)")
                 cursor.execute("PRAGMA synchronous=FULL")
                 conn.commit()
                 
                 success_msg = f"Checklist exclu√≠do com sucesso! ({rows_deleted} registro(s) removido(s)). Total na tabela: {total_after}"
                 
                 # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                 backup_success, backup_msg = save_backup_to_session_state()
                 if backup_success:
                     success_msg += f" | Backup salvo: {backup_msg}"
                 else:
                     success_msg += f" | Aviso: {backup_msg}"
                 
                 conn.close()
                 return True, success_msg
            else:
                conn.close()
                return False, f"Erro: Registro ainda existe ap√≥s exclus√£o. Count by rowid: {count_after}, Count by fields: {count_by_fields}"
        else:
            conn.close()
            return False, "Nenhum registro foi exclu√≠do"
                
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return False, f"Erro ao excluir checklist: {e}"

def force_cache_clear():
    """For√ßa a limpeza completa de todos os caches."""
    try:
        # Limpar cache de dados
        st.cache_data.clear()
        
        # Limpar cache de recursos
        st.cache_resource.clear()
        
        # For√ßar rerun da aplica√ß√£o
        st.rerun()
    except Exception as e:
        st.error(f"Erro ao limpar cache: {e}")

def force_database_sync():
    """For√ßa a sincroniza√ß√£o do banco de dados com o disco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # For√ßar commit
        conn.commit()
        
        # Executar PRAGMA para for√ßar sincroniza√ß√£o
        cursor.execute("PRAGMA wal_checkpoint(FULL)")
        cursor.execute("PRAGMA synchronous=FULL")
        cursor.execute("PRAGMA journal_mode=DELETE")
        
        # For√ßar commit novamente
        conn.commit()
        
        # Verificar se o banco est√° em modo WAL
        cursor.execute("PRAGMA journal_mode")
        journal_mode = cursor.fetchone()[0]
        
        conn.close()
        
        return True, f"Banco sincronizado. Modo journal: {journal_mode}"
    except Exception as e:
        return False, f"Erro ao sincronizar banco: {e}"

def export_database_backup():
    """Exporta todos os dados do banco para um arquivo de backup."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        
        # Obter todas as tabelas
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        backup_data = {}
        
        for table in tables:
            table_name = table[0]
            if table_name != 'sqlite_master':
                # Exportar dados da tabela
                df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
                backup_data[table_name] = df.to_dict('records')
        
        conn.close()
        
        # Converter para JSON
        backup_json = json.dumps(backup_data, default=str, indent=2)
        
        # Criar arquivo de download
        backup_bytes = backup_json.encode('utf-8')
        backup_b64 = base64.b64encode(backup_bytes).decode()
        
        return backup_b64, backup_data
        
    except Exception as e:
        return None, f"Erro ao exportar backup: {e}"

def import_database_backup(backup_data):
    """Importa dados de backup para o banco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        for table_name, records in backup_data.items():
            if records:  # Se a tabela tem dados
                # Limpar tabela existente
                cursor.execute(f"DELETE FROM {table_name}")
                
                # Inserir novos dados
                for record in records:
                    columns = list(record.keys())
                    placeholders = ', '.join(['?' for _ in columns])
                    values = list(record.values())
                    
                    # Converter tipos de dados
                    converted_values = []
                    for value in values:
                        if isinstance(value, str):
                            # Tentar converter para datetime se for uma data
                            try:
                                if 'T' in value or '-' in value:
                                    dt = pd.to_datetime(value)
                                    converted_values.append(dt.strftime('%Y-%m-%d %H:%M:%S'))
                                else:
                                    converted_values.append(value)
                            except:
                                converted_values.append(value)
                        else:
                            converted_values.append(value)
                    
                    cursor.execute(
                        f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})",
                        converted_values
                    )
        
        conn.commit()
        conn.close()
        
        return True, "Backup restaurado com sucesso!"
        
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def save_backup_to_session_state():
    """Salva backup dos dados na sess√£o do Streamlit."""
    try:
        backup_b64, backup_data = export_database_backup()
        if backup_b64:
            st.session_state['database_backup'] = backup_b64
            st.session_state['backup_timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return True, "Backup salvo na sess√£o"
        else:
            return False, "Erro ao criar backup"
    except Exception as e:
        return False, f"Erro ao salvar backup: {e}"

def restore_backup_from_session_state():
    """Restaura backup dos dados da sess√£o do Streamlit."""
    try:
        if 'database_backup' in st.session_state:
            backup_b64 = st.session_state['database_backup']
            backup_bytes = base64.b64decode(backup_b64)
            backup_json = backup_bytes.decode('utf-8')
            backup_data = json.loads(backup_json)
            
            success, message = import_database_backup(backup_data)
            if success:
                # Limpar cache para for√ßar recarregamento
                force_cache_clear()
                return True, message
            else:
                return False, message
        else:
            return False, "Nenhum backup encontrado na sess√£o"
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def auto_restore_backup_on_startup():
    """Tenta restaurar backup automaticamente na inicializa√ß√£o da aplica√ß√£o."""
    try:
        if 'database_backup' in st.session_state:
            # Verificar se o banco est√° vazio
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
            num_tables = cursor.fetchone()[0]
            conn.close()
            
            if num_tables == 0:
                # Banco vazio, tentar restaurar
                success, message = restore_backup_from_session_state()
                if success:
                    st.info("üîÑ Backup restaurado automaticamente na inicializa√ß√£o!")
                    return True
                else:
                    st.warning(f"‚ö†Ô∏è Falha na restaura√ß√£o autom√°tica: {message}")
                    return False
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na restaura√ß√£o autom√°tica: {e}")
        return False

def main():
    
    # Garante tema dark coerente mesmo sem config.toml
    st.markdown(
        """
        <style>
        :root {
            --primary: #10b981;
            --bg: #0f172a;
            --bg2: #111827;
            --text: #e5e7eb;
        }
        body { background: var(--bg); color: var(--text); }
        section.main > div { background: var(--bg); }
        .stApp { background: var(--bg); }
        .st-emotion-cache-1r4qj8v, .st-emotion-cache-13ln4jf { background: var(--bg2) !important; }
        .stButton>button { background: var(--primary); color: #062e24; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    # CSS fino para polir a UI
    st.markdown(
        """
        <style>
        /* Cart√µes/containers */
        .stExpander, .stDataFrame, .stTable { border-radius: 10px !important; }
        .stButton>button { border-radius: 8px; padding: 0.5rem 1rem; }
        .stSelectbox, .stTextInput, .stNumberInput, .stDateInput, .stTextArea { border-radius: 8px !important; }
        /* M√©tricas com mais destaque */
        div[data-testid="stMetric"] { background: rgba(255,255,255,0.04); padding: 10px 14px; border-radius: 12px; }
        /* T√≠tulos com leve gradiente */
        h1, h2, h3 { background: linear-gradient(90deg, #10b981 0%, #06b6d4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        /* Linhas divis√≥rias mais suaves */
        hr { border: none; height: 1px; background: rgba(255,255,255,0.08); }
        /* Subt√≠tulo de marca (opcional) */
        .brand-subtitle { display: none; }
        /* Centralizar e limitar logo na sidebar */
        section[data-testid="stSidebar"] img { display: block; margin: 0.5rem auto 0.75rem; max-width: 140px; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
        st.session_state.role = None
        st.session_state.username = ""

    if not st.session_state.authenticated:
        _ , col_central, _ = st.columns([1, 1.5, 1])
    
        with col_central:
            
            if os.path.exists("logo.png"):
                # Cria 3 sub-colunas dentro da coluna central
                _, logo_col, _ = st.columns([1, 2, 1])
                with logo_col:
                    st.image("logo.png", width=140)
            
            st.title("Bem vindo ao Aplicativo de Controle do PCMA")

            username = st.text_input("Usu√°rio", key="login_user")
            password = st.text_input("Senha", type="password", key="login_pass")

            if st.button("Entrar", use_container_width=True):
                role = check_login_db(username, password)
                if role:
                    st.session_state.authenticated = True
                    st.session_state.role = role
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("Usu√°rio ou Senha incorretos.")
    else:

        # Cabe√ßalho com logo + t√≠tulo
        if os.path.exists("logo.png"):
            col_logo, col_title = st.columns([1, 8])
            with col_logo:
                st.image("logo.png", width=80)
            with col_title:
                st.title("üìä Dashboard de Frotas e Abastecimentos")
        else:
            st.title("üìä Dashboard de Frotas e Abastecimentos")

        # Tentar restaurar backup automaticamente na inicializa√ß√£o
        auto_restore_backup_on_startup()
        
        # Adicionar coluna de tipo de combust√≠vel se n√£o existir
        add_tipo_combustivel_column()
        
        # Setup de esquemas (motoristas, pre√ßos, combust√≠vel)
        ensure_motoristas_schema()
        ensure_precos_combustivel_schema()

        # Passo um fingerprint simples das tabelas para invalidar cache quando necess√°rio
        ver_frotas = int(os.path.getmtime(DB_PATH)) if os.path.exists(DB_PATH) else 0
        df, df_frotas, df_manutencoes, df_comp_regras, df_comp_historico, df_checklist_regras, df_checklist_itens, df_checklist_historico = load_data_from_db(DB_PATH, ver_frotas, ver_frotas, ver_frotas, ver_frotas, ver_frotas)
        

        if 'intervalos_por_classe' not in st.session_state:
            st.session_state.intervalos_por_classe = {}
        classes_operacionais = [c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()]
        for classe in classes_operacionais:
            if classe not in st.session_state.intervalos_por_classe:
                tipo_controle = df_frotas[df_frotas['Classe_Operacional'] == classe]['Tipo_Controle'].iloc[0]
                if tipo_controle == 'HORAS':
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 5.0,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 250},
                            'servico_2': {'nome': 'Revisao A', 'intervalo': 100},
                            'servico_3': {'nome': 'Revisao B', 'intervalo': 300},
                            'servico_4': {'nome': 'Revisao C', 'intervalo': 500}
                        }
                    }
                else: # QUIL√îMETROS
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 2.5,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 5000},
                            'servico_2': {'nome': 'Revisao 5k', 'intervalo': 5000},
                            'servico_3': {'nome': 'Revisao 10k', 'intervalo': 10000},
                            'servico_4': {'nome': 'Revisao 20k', 'intervalo': 20000}
                        }
                    }
                    
        with st.sidebar:
            if os.path.exists("logo.png"):
                st.image("logo.png", width=200)
            st.write(f"Bem-vindo, **{st.session_state.username}**!")
            if st.button("Sair"):
                st.session_state.authenticated = False
                st.session_state.username = "" # Limpa o username ao sair
                st.session_state.role = None
                st.rerun()
            st.markdown("---")

        with st.sidebar:
            st.header("üìÖ Filtros (v√°lidos apenas na aba An√°lise Geral)")

            # Persist√™ncia de per√≠odo
            if 'filtro_data_inicio' not in st.session_state:
                st.session_state['filtro_data_inicio'] = df['Data'].min().date()
            if 'filtro_data_fim' not in st.session_state:
                st.session_state['filtro_data_fim'] = df['Data'].max().date()

            st.subheader("Per√≠odo de An√°lise")
            data_inicio = st.date_input(
                "Data de In√≠cio", 
                st.session_state['filtro_data_inicio'],
                key='data_inicio'
            )
            data_fim = st.date_input(
                "Data de Fim", 
                st.session_state['filtro_data_fim'],
                key='data_fim'
            )
            st.session_state['filtro_data_inicio'] = data_inicio
            st.session_state['filtro_data_fim'] = data_fim

            st.markdown("---")
            st.caption("Desenvolvido por Andr√© Luis")

            with st.expander("Filtrar por Classe Operacional"):
                classe_opts = sorted(list(df["Classe_Operacional"].dropna().unique()))
                sel_classes = st.multiselect(
                    "Selecione as Classes", 
                    classe_opts, 
                    default=classe_opts,
                    key="sel_classes"
                )

            with st.expander("Filtrar por Safra"):
                safra_opts = sorted(list(df["Safra"].dropna().unique()))
                sel_safras = st.multiselect(
                    "Selecione as Safras", 
                    safra_opts, 
                    default=safra_opts,
                    key="sel_safras"
                )

            # S√≥ aplicaremos os filtros na aba "üìà An√°lise Geral" (guardaremos em sess√£o)
            st.session_state['filtro_opts_analise'] = {
                "data_inicio": data_inicio,
                "data_fim": data_fim,
                "classes_op": sel_classes,
                "safras": sel_safras
            }
    #----------------------------------------------------- aba principal --------------------------------------
        # df_f ser√° calculado apenas para a aba An√°lise Geral
        df_f = None
        plan_df = build_component_maintenance_plan(df_frotas, df, df_comp_regras, df_comp_historico)

        # CSS para barra de rolagem horizontal nas abas com design moderno
        st.markdown("""
        <style>
        .stTabs [data-baseweb="tab-list"] {
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: #00D4AA #E8F5F2;
            padding: 8px 0;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar {
            height: 12px;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-track {
            background: linear-gradient(90deg, #F0F2F6 0%, #E8F5F2 100%);
            border-radius: 8px;
            border: 1px solid #E0E6ED;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #00D4AA 0%, #00B8A9 100%);
            border-radius: 8px;
            border: 1px solid #00A896;
            box-shadow: 0 2px 4px rgba(0,212,170,0.3);
            transition: all 0.3s ease;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #00B8A9 0%, #00A896 100%);
            box-shadow: 0 3px 6px rgba(0,212,170,0.4);
            transform: translateY(-1px);
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb:active {
            background: linear-gradient(90deg, #00A896 0%, #009688 100%);
            box-shadow: 0 1px 3px rgba(0,212,170,0.5);
        }
        
        .stTabs [data-baseweb="tab-list"] > div {
            flex-shrink: 0;
            transition: all 0.2s ease;
        }
        
        /* Melhorar apar√™ncia das abas */
        .stTabs [data-baseweb="tab"] {
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .stTabs [data-baseweb="tab"]:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        /* Estilo para abas ativas */
        .stTabs [data-baseweb="tab"][aria-selected="true"] {
            background: linear-gradient(135deg, #00D4AA 0%, #00B8A9 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,212,170,0.3);
        }
        </style>
        """, unsafe_allow_html=True)
        
        # Defini√ß√£o dos grupos de abas
        abas_pagina_inicial = ["üìà An√°lise Geral", "üõ†Ô∏è Controle de Manuten√ß√£o", "üîé Consulta Individual", "‚úÖ Checklists Di√°rios"]
        abas_gerir = ["‚öôÔ∏è Gerir Lan√ßamentos", "üõ¢Ô∏è Gest√£o de Lubrificantes", "‚öôÔ∏è Gerir Frotas", "‚úÖ Gerir Checklists"]
        abas_dados = ["üì§ Importar Dados", "‚öïÔ∏è Sa√∫de dos Dados", "üíæ Backup", "üë§ Gerir Utilizadores", "‚öôÔ∏è Configura√ß√µes"]

        # Sistema de navega√ß√£o por grupos
        st.markdown("### üéØ Navega√ß√£o por Grupos")
        
        # Mostrar informa√ß√µes sobre os grupos dispon√≠veis
        if st.session_state.role == 'admin':
            st.info("""
            **üè† P√°gina Inicial:** Visualiza√ß√µes, an√°lises e consultas principais | 
            **‚öôÔ∏è Gerir:** Gest√£o de lan√ßamentos, frotas e checklists | 
            **üìä Dados:** Importa√ß√µes, backup e sa√∫de dos dados
            """)
        else:
            st.info("**üè† P√°gina Inicial:** Visualiza√ß√µes, an√°lises e consultas principais")
        
        # CSS para os bot√µes de grupo
        st.markdown("""
        <style>
        .group-nav-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102,126,234,0.3);
            margin: 4px;
            cursor: pointer;
        }
        
        .group-nav-button:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102,126,234,0.4);
        }
        
        .group-nav-button.active {
            background: linear-gradient(135deg, #00D4AA 0%, #00B8A9 100%);
            box-shadow: 0 4px 12px rgba(0,212,170,0.3);
        }
        
        .group-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 16px;
            margin: 8px 0;
            border: 1px solid #dee2e6;
        }
        </style>
        """, unsafe_allow_html=True)

        # Bot√µes de navega√ß√£o por grupos
        col1, col2, col3 = st.columns(3)
        
        # Determinar grupo ativo
        active_group = st.session_state.get('active_group', 'pagina_inicial').strip().lower()

        with col1:
            if st.button("üè† P√°gina Inicial", key="nav_pagina_inicial", help="Visualiza√ß√µes e an√°lises principais"):
                st.session_state['active_group'] = 'pagina_inicial'
                st.session_state['active_tab_index'] = 0
                st.rerun()
        
        if st.session_state.role == 'admin':
            with col2:
                if st.button("‚öôÔ∏è Gerir", key="nav_gerir", help="Gest√£o de lan√ßamentos, frotas e checklists"):
                    st.session_state['active_group'] = 'gerir'
                    st.session_state['active_tab_index'] = 0
                    st.rerun()
            
            with col3:
                if st.button("üìä Dados", key="nav_dados", help="Importa√ß√µes, backup e sa√∫de dos dados"):
                    st.session_state['active_group'] = 'dados'
                    st.session_state['active_tab_index'] = 0
                    st.rerun()

        # Determinar quais abas mostrar baseado no grupo ativo
        if st.session_state.role == 'admin':
            if active_group == 'pagina_inicial':
                tabs_para_mostrar = abas_pagina_inicial
            elif active_group == 'gerir':
                tabs_para_mostrar = abas_gerir
            elif active_group == 'dados':
                tabs_para_mostrar = abas_dados
            else:
                tabs_para_mostrar = abas_pagina_inicial
        else:
            # Para usu√°rios comuns, mostrar apenas p√°gina inicial
            tabs_para_mostrar = abas_pagina_inicial

        # Determinar √≠ndice ativo
        active_idx = st.session_state.get('active_tab_index', 0)
        active_idx = max(0, min(active_idx, len(tabs_para_mostrar) - 1))
        
        # Criar as abas
        try:
            abas = st.tabs(tabs_para_mostrar, default_index=active_idx)
        except TypeError:
            abas = st.tabs(tabs_para_mostrar)

        # Atribuir as abas baseado no grupo ativo
        if st.session_state.role == 'admin':
            if active_group == 'pagina_inicial':
                tab_analise, tab_manut, tab_consulta, tab_checklists = abas
                # Criar vari√°veis vazias para as outras abas
                tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
                tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None
            elif active_group == 'gerir':
                tab_gerir_lanc, tab_gerir_lub, tab_gerir_frotas, tab_gerir_checklists = abas
                # Criar vari√°veis vazias para as outras abas
                tab_analise = tab_manut = tab_consulta = tab_checklists = None
                tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None
            elif active_group == 'dados':
                tab_importar, tab_saude, tab_backup, tab_gerir_users, tab_config = abas
                # Criar vari√°veis vazias para as outras abas
                tab_analise = tab_manut = tab_consulta = tab_checklists = None
                tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
                

        else:
            tab_analise, tab_manut, tab_consulta, tab_checklists = abas
            # Criar vari√°veis vazias para as outras abas
            tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
            tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None

        def rerun_keep_tab(tab_title: str, clear_cache: bool = True):
            if clear_cache:
                st.cache_data.clear()
            try:
                st.session_state['active_tab_index'] = tabs_para_mostrar.index(tab_title)
            except Exception:
                pass
            st.rerun()
    
        if tab_analise is not None:
            with tab_analise:
                st.header("üìà An√°lise Geral e Painel de Controle")
                
                # ===== SE√á√ÉO: VIS√ÉO GERAL DA FROTA =====
                st.subheader("üè† Vis√£o Geral da Frota")
                
                # Calcular gasto total com combust√≠vel
                precos_map = get_precos_combustivel_map()
                gasto_total_combustivel = 0
                if precos_map:
                    df_gastos_total = df.copy()
                    # Verificar se a coluna tipo_combustivel existe em df_frotas
                    if 'tipo_combustivel' in df_frotas.columns:
                        df_gastos_total = df_gastos_total.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                        # Verificar se a coluna foi criada ap√≥s o merge
                        if 'tipo_combustivel' in df_gastos_total.columns:
                            df_gastos_total['tipo_combustivel'] = df_gastos_total['tipo_combustivel'].fillna('Diesel S500')
                        else:
                            df_gastos_total['tipo_combustivel'] = 'Diesel S500'
                    else:
                        # Se n√£o existir, criar a coluna com valor padr√£o
                        df_gastos_total['tipo_combustivel'] = 'Diesel S500'
                    
                    df_gastos_total['preco_unit'] = df_gastos_total['tipo_combustivel'].map(precos_map).fillna(0.0)
                    df_gastos_total['custo'] = df_gastos_total['Qtde Litros'].fillna(0.0) * df_gastos_total['preco_unit']
                    gasto_total_combustivel = df_gastos_total['custo'].sum()
                
                # KPIs principais
                kpi1, kpi2, kpi3, kpi4, kpi5 = st.columns(5)
                
                # KPI 1: Frotas Ativas
                total_frotas_ativas = df_frotas[df_frotas['ATIVO'] == 'ATIVO']['Cod_Equip'].nunique()
                kpi1.metric("üöó Frotas Ativas", total_frotas_ativas)
                
                # KPI 2: Frotas com Alerta
                frotas_com_alerta = plan_df[plan_df['Qualquer_Alerta'] == True]['Cod_Equip'].nunique() if not plan_df.empty else 0
                kpi2.metric("‚ö†Ô∏è Frotas com Alerta", frotas_com_alerta)
                
                # KPI 3: Gasto Total com Combust√≠vel
                kpi3.metric("üí∞ Gasto com Combust√≠vel", formatar_brasileiro(gasto_total_combustivel, 'R$ '))
                
                # KPIs 4 e 5: Frotas Mais e Menos Eficientes
                df_sem_filtro = df.copy()
                df_media_geral = df_sem_filtro[(df_sem_filtro['Media'].notna()) & (df_sem_filtro['Media'] > 0)]
                if not df_media_geral.empty:
                    # Agrupa por C√≥digo e Descri√ß√£o para ter acesso a ambos
                    media_por_equip = df_media_geral.groupby(['Cod_Equip', 'DESCRICAO_EQUIPAMENTO'])['Media'].mean().sort_values()
                    
                    if not media_por_equip.empty:
                        # Pega o C√ìDIGO do mais eficiente (primeiro da lista ordenada)
                        cod_mais_eficiente = media_por_equip.index[0][0]
                        media_mais_eficiente = media_por_equip.iloc[0]
                        # Exibe o C√ìDIGO no KPI
                        kpi4.metric("üèÜ Mais Eficiente", f"{cod_mais_eficiente}", f"{formatar_brasileiro(media_mais_eficiente)}")
                
                        # Pega o C√ìDIGO do menos eficiente (√∫ltimo da lista ordenada)
                        cod_menos_eficiente = media_por_equip.index[-1][0]
                        media_menos_eficiente = media_por_equip.iloc[-1]
                        # Exibe o C√ìDIGO no KPI
                        kpi5.metric("üìâ Menos Eficiente", f"{cod_menos_eficiente}", f"{formatar_brasileiro(media_menos_eficiente)}")
                else:
                    # Se n√£o h√° dados de efici√™ncia, mostrar mensagem
                    kpi4.metric("üèÜ Mais Eficiente", "N/A")
                    kpi5.metric("üìâ Menos Eficiente", "N/A")

                st.markdown("---")
                st.subheader("üìà An√°lise Gr√°fica de Consumo")

                # Aplica filtros apenas nesta aba
                opts = st.session_state.get('filtro_opts_analise', None)
                df_f = filtrar_dados(df, opts) if opts else df.copy()

                if not df_f.empty:
                    # KPIs melhorados com an√°lise por tipo de combust√≠vel
                    st.subheader("üìä Indicadores de Consumo por Combust√≠vel")
                    
                    # Obter tipos de combust√≠vel das frotas
                    if 'tipo_combustivel' in df_frotas.columns:
                        # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                        df_f_com_consumo = df_f[df_f['Qtde Litros'] > 0].copy()
                        
                        if not df_f_com_consumo.empty:
                            # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                            equipamentos_com_consumo = df_f_com_consumo['Cod_Equip'].unique()
                            
                            # Filtrar df_frotas para incluir apenas equipamentos com consumo
                            frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                            
                            # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                            if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                            
                            # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                            combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                            
                            # Aplicar o mapeamento apenas aos registros com consumo
                            df_f_com_consumo['tipo_combustivel'] = df_f_com_consumo['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                            
                            # Calcular consumo por tipo de combust√≠vel
                            consumo_por_combustivel = df_f_com_consumo.groupby('tipo_combustivel')['Qtde Litros'].sum().sort_values(ascending=False)
                        else:
                            # Se n√£o h√° registros com consumo, criar um DataFrame vazio
                            consumo_por_combustivel = pd.Series(dtype='float64')
                        
                        # Criar colunas din√¢micas baseadas no n√∫mero de tipos de combust√≠vel
                        num_tipos = len(consumo_por_combustivel)
                        if num_tipos <= 2:
                            cols = st.columns(2)
                        elif num_tipos <= 3:
                            cols = st.columns(3)
                        elif num_tipos <= 4:
                            cols = st.columns(4)
                        else:
                            cols = st.columns(5)
                        
                        # Exibir KPIs por tipo de combust√≠vel
                        for i, (tipo, litros) in enumerate(consumo_por_combustivel.items()):
                            if i < len(cols):
                                with cols[i]:
                                    # Calcular percentual do total
                                    percentual = (litros / df_f["Qtde Litros"].sum()) * 100
                                    
                                    # Definir cor baseada no tipo de combust√≠vel
                                    if 'Diesel S500' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Diesel S10' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Gasolina' in tipo:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    elif 'Etanol' in tipo:
                                        delta_color = "normal"
                                        icon = "üå±"
                                    elif 'Biodiesel' in tipo:
                                        delta_color = "normal"
                                        icon = "üåø"
                                    else:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    
                                    cols[i].metric(
                                        f"{icon} {tipo}",
                                        f"{formatar_brasileiro_int(litros)} L",
                                        f"{percentual:.1f}% do total",
                                        delta_color=delta_color
                                    )
                        
                        # Adicionar linha separadora
                        st.markdown("---")
                        
                        # KPI adicional: Total geral e m√©dia por equipamento
                        k1, k2, k3 = st.columns(3)
                        
                        with k1:
                            total_litros = df_f["Qtde Litros"].sum()
                            k1.metric(
                                "üõ¢Ô∏è Total Geral",
                                f"{formatar_brasileiro_int(total_litros)} L",
                                f"{len(consumo_por_combustivel)} tipos de combust√≠vel"
                            )
                        
                        with k2:
                            if 'Media' in df_f.columns:
                                media_geral = df_f['Media'].mean()
                                k2.metric(
                                    "üìà M√©dia Geral",
                                    f"{formatar_brasileiro(media_geral)}",
                                    "M√©dia de consumo por equipamento"
                                )
                            else:
                                # Calcular m√©dia manual se n√£o existir coluna Media
                                equipamentos_unicos = df_f['Cod_Equip'].nunique()
                                if equipamentos_unicos > 0:
                                    media_manual = total_litros / equipamentos_unicos
                                    k2.metric(
                                        "üìà M√©dia por Equipamento",
                                        f"{formatar_brasileiro(media_manual)} L",
                                        f"{equipamentos_unicos} equipamentos"
                                    )
                                else:
                                    k2.metric("üìà M√©dia por Equipamento", "N/A")
                        
                        with k3:
                            # Calcular efici√™ncia (litros por dia se houver dados de data)
                            if 'Data' in df_f.columns:
                                try:
                                    df_f['Data'] = pd.to_datetime(df_f['Data'])
                                    dias_periodo = (df_f['Data'].max() - df_f['Data'].min()).days + 1
                                    if dias_periodo > 0:
                                        litros_por_dia = total_litros / dias_periodo
                                        k3.metric(
                                            "üìÖ Consumo Di√°rio",
                                            f"{formatar_brasileiro(litros_por_dia)} L/dia",
                                            f"{dias_periodo} dias analisados"
                                        )
                                    else:
                                        k3.metric("üìÖ Consumo Di√°rio", "N/A")
                                except:
                                    k3.metric("üìÖ Consumo Di√°rio", "N/A")
                            else:
                                k3.metric("üìÖ Consumo Di√°rio", "N/A")
                    else:
                        # Fallback se n√£o houver coluna tipo_combustivel
                        k1, k2 = st.columns(2)
                        k1.metric("Litros Consumidos (per√≠odo)", formatar_brasileiro_int(df_f["Qtde Litros"].sum()))
                        if 'Media' in df_f.columns:
                            k2.metric("M√©dia Consumo (per√≠odo)", f"{formatar_brasileiro(df_f['Media'].mean())}")
                        else:
                            equipamentos_unicos = df_f['Cod_Equip'].nunique()
                            if equipamentos_unicos > 0:
                                media_manual = df_f["Qtde Litros"].sum() / equipamentos_unicos
                                k2.metric("M√©dia por Equipamento", f"{formatar_brasileiro(media_manual)} L")
                    st.markdown("---")
                    st.subheader("üìä An√°lise de Consumo por Classe e Equipamentos")
                    c1, c2 = st.columns(2)

                    with c1:
                        st.subheader("Consumo por Classe Operacional")
                        classes_a_excluir = ['VEICULOS LEVES', 'MOTOCICLETA', 'MINI CARREGADEIRA', 'USINA']
                        # Verificar se a coluna Classe_Operacional existe antes de filtrar
                        if 'Classe_Operacional' in df_f.columns:
                            df_consumo_classe = df_f[~df_f['Classe_Operacional'].str.upper().isin(classes_a_excluir)]
                        else:
                            df_consumo_classe = df_f
                        consumo_por_classe = df_consumo_classe.groupby("Classe_Operacional")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()

                        if not consumo_por_classe.empty:
                            consumo_por_classe['texto_formatado'] = consumo_por_classe['Qtde Litros'].apply(formatar_brasileiro_int)
                            fig_classe = px.bar(consumo_por_classe, x='Qtde Litros', y='Classe_Operacional', orientation='h', text='texto_formatado', labels={"x": "Litros Consumidos", "y": "Classe Operacional"})
                            fig_classe.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_classe.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Classe Operacional",
                                height=500,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=12)
                            )
                            st.plotly_chart(fig_classe, use_container_width=True)

                    with c2:
                        st.subheader("Top 10 Equipamentos com Maior Consumo")
                        # Melhorar o gr√°fico com informa√ß√µes mais claras
                        consumo_por_equip = df_f.groupby("Cod_Equip").agg({'Qtde Litros': 'sum'}).dropna()
                        consumo_por_equip = consumo_por_equip[consumo_por_equip.index != 550]
                        consumo_por_equip = consumo_por_equip.sort_values(by="Qtde Litros", ascending=False).head(10)

                        if not consumo_por_equip.empty:
                            # Adicionar informa√ß√µes da frota para melhor identifica√ß√£o
                            consumo_por_equip = consumo_por_equip.reset_index()
                            consumo_por_equip = consumo_por_equip.merge(
                                df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                                on='Cod_Equip', 
                                how='left'
                            )
                            
                            # Criar label mais informativo: C√≥digo - Descri√ß√£o (Placa)
                            consumo_por_equip['label_grafico'] = consumo_por_equip.apply(
                                lambda row: f"{row['Cod_Equip']} - {row['DESCRICAO_EQUIPAMENTO'][:30]}{'...' if len(str(row['DESCRICAO_EQUIPAMENTO'])) > 30 else ''} ({row['PLACA']})", 
                                axis=1
                            )
                            
                            consumo_por_equip['texto_formatado'] = consumo_por_equip['Qtde Litros'].apply(formatar_brasileiro_int)
                            
                            fig_top10 = px.bar(
                                consumo_por_equip, 
                                x='Qtde Litros', 
                                y='label_grafico', 
                                orientation='h', 
                                text='texto_formatado', 
                                labels={"Qtde Litros": "Total Consumido (Litros)", "label_grafico": "Equipamento"},
                                title="Top 10 Equipamentos com Maior Consumo"
                            )
                            fig_top10.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                marker_color='#ff7f0e',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_top10.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Equipamento",
                                height=600,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=11)
                            )
                            st.plotly_chart(fig_top10, use_container_width=True)

                    st.markdown("---")
                    
                    # NOVA SE√á√ÉO: Top 10 de Gastos por Frota e por Classe
                    st.subheader("üí∞ Top 10 de Gastos por Frota e Classe")
                    
                    # Calcular gastos por frota
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        df_gastos = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_gastos = df_gastos.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_gastos.columns:
                                df_gastos['tipo_combustivel'] = df_gastos['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_gastos['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_gastos.columns:
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        df_gastos['preco_unit'] = df_gastos['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_gastos['custo'] = df_gastos['Qtde Litros'].fillna(0.0) * df_gastos['preco_unit']
                        
                        # Adicionar informa√ß√µes da frota para filtro
                        df_gastos_com_info = df_gastos.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA', 'Classe_Operacional']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        
                        # Garantir que a coluna Classe_Operacional existe
                        if 'Classe_Operacional' not in df_gastos_com_info.columns:
                            df_gastos_com_info['Classe_Operacional'] = 'N/A'
                        
                        # Filtro para excluir a frota 550 (usina) por padr√£o
                        mostrar_usinas = st.checkbox("üè≠ Incluir Frota 550 (Usina) no Top 10 de Gastos por Frota", value=False)
                        
                        if not mostrar_usinas:
                            # Excluir a frota 550 (usina) do DataFrame
                            df_gastos_filtrado = df_gastos_com_info[df_gastos_com_info['Cod_Equip'] != 550]
                        else:
                            df_gastos_filtrado = df_gastos_com_info
                        
                        # Top 10 gastos por frota individual (ap√≥s filtro)
                        gastos_por_frota = df_gastos_filtrado.groupby('Cod_Equip').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        
                        # Adicionar informa√ß√µes da frota
                        gastos_por_frota = gastos_por_frota.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        gastos_por_frota['label_frota'] = gastos_por_frota['Cod_Equip'].astype(str)
                        gastos_por_frota['custo_formatado'] = gastos_por_frota['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Top 10 gastos por classe operacional
                        gastos_por_classe = df_gastos.groupby('Classe_Operacional').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        gastos_por_classe['custo_formatado'] = gastos_por_classe['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Criar layout em 2 colunas para os gr√°ficos
                        col_gastos1, col_gastos2 = st.columns(2)
                        
                        with col_gastos1:
                            st.subheader("üè≠ Top 10 Gastos por Frota")
                            
                            # Mostrar informa√ß√£o sobre filtro da frota 550
                            # Coment√°rio removido para manter propor√ß√£o dos gr√°ficos
                            
                            if not gastos_por_frota.empty:
                                # Garantir que os dados est√£o corretos
                                gastos_por_frota['custo'] = gastos_por_frota['custo'].fillna(0)
                                gastos_por_frota = gastos_por_frota[gastos_por_frota['custo'] > 0]
                                
                                if not gastos_por_frota.empty:
                                    # Dados j√° validados e prontos para o gr√°fico
                                    
                                    # Garantir que label_frota √© string e √∫nico
                                    gastos_por_frota['label_frota'] = gastos_por_frota['label_frota'].astype(str)
                                    
                                    # Criar gr√°fico de barras horizontais com dados limpos
                                    fig_gastos_frota = px.bar(
                                        gastos_por_frota,
                                        x='custo',
                                        y='label_frota',
                                        orientation='h',
                                        text='custo_formatado',
                                        title="Gastos por Frota Individual",
                                        labels={'custo': 'Custo (R$)', 'label_frota': 'Frota'},
                                        color='custo',
                                        color_continuous_scale='Reds'
                                    )
                                    fig_gastos_frota.update_traces(
                                        textposition='outside',
                                        texttemplate='%{text}',
                                        textfont=dict(size=11, color='white'),
                                        cliponaxis=False,
                                        marker=dict(line=dict(width=1, color='black'))
                                    )
                                    fig_gastos_frota.update_layout(
                                        yaxis={'categoryorder':'total ascending'},
                                        xaxis_title="Custo Total (R$)",
                                        yaxis_title="Frota",
                                        height=600,
                                        showlegend=False,
                                        margin=dict(l=20, r=20, t=40, b=20),
                                        font=dict(size=12),
                                        bargap=0.3,
                                        bargroupgap=0.1
                                    )
                                    # Configurar eixo Y para mostrar todas as categorias
                                    fig_gastos_frota.update_yaxes(
                                        type='category',
                                        categoryorder='total ascending'
                                    )
                                    st.plotly_chart(fig_gastos_frota, use_container_width=True)
                                    
                                    # Gr√°fico criado com sucesso
                                else:
                                    st.warning("N√£o h√° frotas com gastos maiores que zero.")
                            else:
                                st.info("N√£o h√° dados de gastos por frota.")
                        
                        with col_gastos2:
                            st.subheader("üèóÔ∏è Top 10 Gastos por Classe")
                            if not gastos_por_classe.empty:
                                fig_gastos_classe = px.bar(
                                    gastos_por_classe,
                                    x='custo',
                                    y='Classe_Operacional',
                                    orientation='h',
                                    text='custo_formatado',
                                    title="Gastos por Classe Operacional",
                                    labels={'custo': 'Custo (R$)', 'Classe_Operacional': 'Classe'},
                                    color='custo',
                                    color_continuous_scale='Blues'
                                )
                                fig_gastos_classe.update_traces(
                                    textposition='outside',
                                    texttemplate='%{text}',
                                    textfont=dict(size=11, color='white'),
                                    cliponaxis=False,
                                    marker=dict(line=dict(width=1, color='black'))
                                )
                                fig_gastos_classe.update_layout(
                                    yaxis={'categoryorder':'total ascending'},
                                    xaxis_title="Custo Total (R$)",
                                    yaxis_title="Classe Operacional",
                                    height=600,
                                    showlegend=False,
                                    margin=dict(l=20, r=20, t=40, b=20),
                                    font=dict(size=12),
                                    bargap=0.3,
                                    bargroupgap=0.1
                                )
                                # Configurar eixo Y para mostrar todas as categorias
                                fig_gastos_classe.update_yaxes(
                                    type='category',
                                    categoryorder='total ascending'
                                )
                                st.plotly_chart(fig_gastos_classe, use_container_width=True)
                            else:
                                st.info("N√£o h√° dados de gastos por classe.")
                        
                        # Resumo dos totais
                        st.markdown("---")
                        col_resumo1, col_resumo2, col_resumo3 = st.columns(3)
                        with col_resumo1:
                            st.metric(
                                "Total Gastos (Per√≠odo)", 
                                formatar_brasileiro(df_gastos['custo'].sum(), 'R$ ')
                            )
                        with col_resumo2:
                            if not gastos_por_frota.empty:
                                frota_maior_gasto = gastos_por_frota.iloc[0]
                                st.metric(
                                    "Frota com Maior Gasto", 
                                    f"{frota_maior_gasto['Cod_Equip']}",
                                    f"{frota_maior_gasto['custo_formatado']}"
                                )
                            else:
                                st.metric("Frota com Maior Gasto", "N/A")
                        with col_resumo3:
                            st.metric(
                                "Classe com Maior Gasto", 
                                f"{gastos_por_classe.iloc[0]['Classe_Operacional'] if not gastos_por_classe.empty else 'N/A'}"
                            )
                    else:
                        st.warning("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos para visualizar os gastos.")

                    st.markdown("---")
                    st.subheader("üìà M√©dia de Consumo por Classe Operacional")
                    df_media = df_f[(df_f['Media'].notna()) & (df_f['Media'] > 0)].copy()

                    classes_para_excluir = ['MOTOCICLETA', 'VEICULOS LEVES', 'USINA', 'MINI CARREGADEIRA']

                    # Verificar se a coluna Classe_Operacional existe antes de filtrar
                    if 'Classe_Operacional' in df_media.columns:
                        df_media_filtrado = df_media[~df_media['Classe_Operacional'].str.upper().isin(classes_para_excluir)]
                    else:
                        df_media_filtrado = df_media

                    if not df_media_filtrado.empty: # Usa o novo DataFrame filtrado
                        media_por_classe = df_media_filtrado.groupby('Classe_Operacional')['Media'].mean().sort_values(ascending=True)
                        
                        df_media_grafico = media_por_classe.reset_index()
                        df_media_grafico['texto_formatado'] = df_media_grafico['Media'].apply(
                            lambda x: formatar_brasileiro(x)
                        )
                        
                        # Cria o gr√°fico de barras
                        fig_media_classe = px.bar(
                            df_media_grafico,
                            x='Media',
                            y='Classe_Operacional',
                            orientation='h',
                            title="M√©dia de Consumo (L/h ou Km/L) por Classe",
                            text='texto_formatado'
                        )
                        fig_media_classe.update_traces(
                            textposition='outside',
                            marker_color='#1f77b4'
                        )
                        fig_media_classe.update_layout(
                            yaxis_title="Classe Operacional",
                            xaxis_title="M√©dia de Consumo"
                        )
                        st.plotly_chart(fig_media_classe, use_container_width=True)
                    else:
                        st.info("N√£o h√° dados de consumo m√©dio para exibir com os filtros e exclus√µes aplicadas.")

                    st.markdown("---")
                    st.subheader("üí∞ Total de Gasto por Motorista")
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        # Vincula combust√≠vel por frota e multiplica litros por pre√ßo
                        df_tmp = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_tmp = df_tmp.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_tmp.columns:
                                df_tmp['tipo_combustivel'] = df_tmp['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_tmp['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_tmp.columns:
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        
                        df_tmp['preco_unit'] = df_tmp['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_tmp['custo'] = df_tmp['Qtde Litros'].fillna(0.0) * df_tmp['preco_unit']
                        # Agrupar por matr√≠cula
                        if 'Matricula' in df_tmp.columns:
                            gasto_motorista = df_tmp.groupby('Matricula').agg({'custo':'sum', 'Qtde Litros':'sum'}).sort_values('custo', ascending=False)
                            gasto_motorista = gasto_motorista[gasto_motorista['custo']>0]
                            if not gasto_motorista.empty:
                                gasto_motorista = gasto_motorista.reset_index()
                                gasto_motorista['Custo (R$)'] = gasto_motorista['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                                gasto_motorista['Litros'] = gasto_motorista['Qtde Litros'].apply(formatar_brasileiro_int)
                                st.dataframe(gasto_motorista[['Matricula','Litros','Custo (R$)']])
                                try:
                                    fig_gasto = px.bar(gasto_motorista.head(10), x='custo', y='Matricula', orientation='h', text='Custo (R$)', labels={'custo':'Custo (R$)','Matricula':'Matr√≠cula'})
                                    st.plotly_chart(fig_gasto, use_container_width=True)
                                except Exception:
                                    pass
                            else:
                                st.info("Sem dados suficientes de custo (verifique pre√ßos cadastrados).")
                        else:
                            st.info("N√£o h√° coluna de matr√≠cula nos abastecimentos para calcular o gasto por motorista.")
                    else:
                        st.info("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos.")

                    st.markdown("---")
                    st.subheader("üîÑ An√°lise de Propor√ß√µes por Classe e Combust√≠vel")
                
                # Criar DataFrame com informa√ß√µes de combust√≠vel
                df_consumo_combustivel = df.copy()
                
                # Verificar se a coluna tipo_combustivel existe em df_frotas
                if 'tipo_combustivel' in df_frotas.columns:
                    try:
                        # Renomear a coluna COD_EQUIPAMENTO para Cod_Equip em df_frotas
                        df_frotas_temp = df_frotas.copy()
                        df_frotas_temp = df_frotas_temp.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip"}, errors='ignore')
                        
                        frotas_combustivel = df_frotas_temp[['Cod_Equip', 'tipo_combustivel']].copy()
                        frotas_combustivel['tipo_combustivel'] = frotas_combustivel['tipo_combustivel'].fillna('Diesel S500')
                        
                        # Renomear a coluna "C√≥d. Equip." para "Cod_Equip" em df_consumo_combustivel
                        df_consumo_combustivel = df_consumo_combustivel.rename(columns={"C√≥d. Equip.": "Cod_Equip"}, errors='ignore')
                        
                        df_consumo_combustivel = df_consumo_combustivel.merge(
                            frotas_combustivel, 
                            on='Cod_Equip', 
                            how='left'
                        )
                        # Verificar se a coluna foi criada ap√≥s o merge
                        if 'tipo_combustivel' not in df_consumo_combustivel.columns:
                            df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                    except Exception:
                        df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                else:
                    df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                
                # Garantir que a coluna tipo_combustivel existe
                if 'tipo_combustivel' not in df_consumo_combustivel.columns:
                    df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                
                col_grafico1, col_grafico2 = st.columns(2)
                
                with col_grafico1:
                    st.subheader("üìä Consumo por Classe (Vis√£o Macro)")
                    # Excluir "Usina" e frotas sem classe, usar Classe_Operacional
                    classes_a_excluir_macro = ['USINA', 'USINA MOBILE', 'USINA FIXA']
                    # Verificar se a coluna Classe_Operacional existe antes de filtrar
                    if 'Classe_Operacional' in df_consumo_combustivel.columns:
                        df_consumo_classe_macro = df_consumo_combustivel[
                            (df_consumo_combustivel['Classe_Operacional'].notna()) & 
                            (~df_consumo_combustivel['Classe_Operacional'].str.upper().isin(classes_a_excluir_macro))
                        ]
                    else:
                        df_consumo_classe_macro = df_consumo_combustivel
                    
                    if not df_consumo_classe_macro.empty:
                        try:
                            consumo_por_classe_macro = df_consumo_classe_macro.groupby("Classe_Operacional")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()
                            
                            # Criar gr√°fico de pizza
                            fig_pizza_classe = px.pie(
                                consumo_por_classe_macro, 
                                values='Qtde Litros', 
                                names='Classe_Operacional',
                                title="Propor√ß√£o de Consumo por Classe",
                                hole=0.3
                            )
                            fig_pizza_classe.update_traces(textposition='inside', textinfo='percent+label')
                            fig_pizza_classe.update_layout(height=400)
                            st.plotly_chart(fig_pizza_classe, use_container_width=True)
                            
                            # Mostrar totais
                            st.info(f"**Total de classes analisadas:** {len(consumo_por_classe_macro)}")
                            st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_classe_macro['Qtde Litros'].sum())} L")
                        except Exception as e:
                            st.error(f"Erro ao criar gr√°fico de classe: {e}")
                    else:
                        st.warning("N√£o h√° dados suficientes para an√°lise por classe.")
                
                with col_grafico2:
                    st.subheader("‚õΩ Consumo por Tipo de Combust√≠vel")
                    if not df_consumo_combustivel.empty:
                        try:
                            # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                            df_consumo_real = df_consumo_combustivel[df_consumo_combustivel['Qtde Litros'] > 0].copy()
                            
                            if not df_consumo_real.empty:
                                # Obter tipos de combust√≠vel apenas das frotas que realmente abasteceram
                                if 'tipo_combustivel' in df_frotas.columns:
                                    # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                                    equipamentos_com_consumo = df_consumo_real['Cod_Equip'].unique()
                                    
                                    # Filtrar df_frotas para incluir apenas equipamentos com consumo
                                    frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                                    
                                    # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                                    if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                        # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                        frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                                    
                                    # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                                    combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                                    
                                    # Aplicar o mapeamento apenas aos registros com consumo
                                    df_consumo_real['tipo_combustivel'] = df_consumo_real['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                                else:
                                    df_consumo_real['tipo_combustivel'] = 'Diesel S500'
                                
                                # Agrupar por tipo de combust√≠vel
                                consumo_por_combustivel = df_consumo_real.groupby("tipo_combustivel")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()
                                
                                if not consumo_por_combustivel.empty:
                                    # Criar gr√°fico de pizza
                                    fig_pizza_combustivel = px.pie(
                                        consumo_por_combustivel, 
                                        values='Qtde Litros', 
                                        names='tipo_combustivel',
                                        title="Propor√ß√£o de Consumo por Combust√≠vel (Apenas Frotas com Hist√≥rico)",
                                        hole=0.3
                                    )
                                    fig_pizza_combustivel.update_traces(textposition='inside', textinfo='percent+label')
                                    fig_pizza_combustivel.update_layout(height=400)
                                    st.plotly_chart(fig_pizza_combustivel, use_container_width=True)
                                    
                                    # Mostrar totais
                                    st.info(f"**Total de tipos de combust√≠vel:** {len(consumo_por_combustivel)}")
                                    st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                                    st.info(f"**Frotas com hist√≥rico de abastecimento:** {len(equipamentos_com_consumo)}")
                                else:
                                    st.warning("N√£o h√° dados de consumo para an√°lise por combust√≠vel.")
                            else:
                                st.warning("N√£o h√° registros com consumo de combust√≠vel.")
                        except Exception as e:
                            st.error(f"Erro ao criar gr√°fico de combust√≠vel: {e}")
                            st.info("Verificando dados dispon√≠veis...")
                            if 'tipo_combustivel' in df_consumo_combustivel.columns:
                                consumo_por_combustivel = df_consumo_combustivel.groupby("tipo_combustivel")["Qtde Litros"].sum().reset_index()
                                st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                            else:
                                st.error("Coluna tipo_combustivel n√£o encontrada")
                    else:
                        st.warning("N√£o h√° dados suficientes para an√°lise por combust√≠vel.")
                
                # Fechar as colunas anteriores e criar nova se√ß√£o com largura total
                st.markdown("---")
                st.subheader("üìä Demonstrativos Detalhados dos Pneus")

                df_pneus_all = get_pneus_historico()
                if not df_pneus_all.empty:
                    # Adicione colunas de status e vida se n√£o existirem
                    if 'status' not in df_pneus_all.columns:
                        df_pneus_all['status'] = 'Ativo'
                    if 'vida_atual' not in df_pneus_all.columns:
                        df_pneus_all['vida_atual'] = 1

                    total_pneus = len(df_pneus_all)
                    ativos = df_pneus_all[df_pneus_all['status'].str.lower() == 'ativo'].shape[0]
                    sucateados = df_pneus_all[df_pneus_all['status'].str.lower() == 'sucateado'].shape[0]
                    reformados = df_pneus_all[df_pneus_all['status'].str.lower() == 'reformado'].shape[0]
                    vidas = df_pneus_all['vida_atual'].value_counts().sort_index()
                    marcas = df_pneus_all['marca'].value_counts()
                    modelos = df_pneus_all['modelo'].value_counts()
                    posicoes = df_pneus_all['posicao'].value_counts()

                    col1, col2, col3, col4 = st.columns(4)
                    col1.metric("Total de Pneus", total_pneus)
                    col2.metric("Ativos", ativos)
                    col3.metric("Sucateados", sucateados)
                    col4.metric("Reformados", reformados)

                    # Gr√°ficos melhorados com r√≥tulos de dados
                    st.markdown("#### üìä Gr√°ficos de Distribui√ß√£o")
                    
                    # Criar DataFrame de status para o gr√°fico
                    status_df = df_pneus_all['status'].value_counts().reset_index()
                    status_df.columns = ["Status", "Quantidade"]
                    
                    # Gr√°fico de Status (Pizza)
                    fig_status = px.pie(status_df, names='Status', values='Quantidade', title='Status dos Pneus')
                    fig_status.update_traces(
                        textposition='inside',
                        textinfo='percent+label',
                        textfont=dict(size=12, color='white')
                    )
                    fig_status.update_layout(
                        height=400,
                        showlegend=True,
                        font=dict(size=12)
                    )
                    st.plotly_chart(fig_status, use_container_width=True)

                    # Gr√°fico de Marcas (Barras)
                    fig_marcas = px.bar(
                        marcas.reset_index(), 
                        x='marca', 
                        y='count', 
                        title='Quantidade por Marca',
                        text='count'
                    )
                    fig_marcas.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_marcas.update_layout(
                        xaxis_title="Marca",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_marcas, use_container_width=True)

                    # Gr√°fico de Modelos (Barras)
                    fig_modelos = px.bar(
                        modelos.reset_index(), 
                        x='modelo', 
                        y='count', 
                        title='Quantidade por Medida',
                        text='count'
                    )
                    fig_modelos.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_modelos.update_layout(
                        xaxis_title="Modelo",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_modelos, use_container_width=True)



                    # Bot√µes de exporta√ß√£o
                    st.markdown("#### üìä Exportar Dados")
                    col_export1, col_export2, col_export3 = st.columns(3)
                    
                    with col_export1:
                        export_dataframe(status_df, "status_pneus", "csv")
                    
                    with col_export2:
                        export_dataframe(marcas.reset_index(), "marcas_pneus", "csv")
                    
                    with col_export3:
                        export_dataframe(modelos.reset_index(), "modelos_pneus", "csv")
                    
                    # Informa√ß√µes adicionais
                    st.markdown("---")
                    st.markdown("""
                    <div class="info-box">
                        <strong>üí° Dicas:</strong><br>
                        ‚Ä¢ Use os filtros para analisar per√≠odos espec√≠ficos<br>
                        ‚Ä¢ Exporte os dados para an√°lises externas<br>
                        ‚Ä¢ Os gr√°ficos s√£o interativos - clique para mais detalhes
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.info("Nenhum pneu cadastrado para demonstrativo.")

                st.markdown("---")
                st.subheader("üõ¢Ô∏è Demonstrativos de Lubrificantes")

                ensure_lubrificantes_schema()
                conn = sqlite3.connect(DB_PATH)
                df_lub = pd.read_sql("SELECT * FROM lubrificantes", conn)
                df_mov = pd.read_sql("SELECT * FROM lubrificantes_movimentacoes", conn)

                st.write("**Estoque Atual de Lubrificantes:**")
                if not df_lub.empty:
                    # Separar por tipo
                    df_oleos = df_lub[df_lub['tipo'].str.lower() == '√≥leo']
                    df_graxas = df_lub[df_lub['tipo'].str.lower() == 'graxa']

                    col_o, col_g = st.columns(2)
                    with col_o:
                        st.markdown("#### Estoque de √ìleos")
                        if not df_oleos.empty:
                            fig_oleos = px.bar(
                                df_oleos,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="√ìleos - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': '√ìleo'}
                            )
                            st.plotly_chart(fig_oleos, use_container_width=True)
                        else:
                            st.info("Nenhum √≥leo cadastrado.")

                    with col_g:
                        st.markdown("#### Estoque de Graxas")
                        if not df_graxas.empty:
                            fig_graxas = px.bar(
                                df_graxas,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="Graxas - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': 'Graxa'}
                            )
                            st.plotly_chart(fig_graxas, use_container_width=True)
                        else:
                            st.info("Nenhuma graxa cadastrada.")

                    # Pizza geral
                    df_lub['tipo'] = df_lub['tipo'].fillna('√≥leo')
                    fig_pizza = px.pie(
                        df_lub,
                        names='tipo',
                        values='quantidade_estoque',
                        title="Propor√ß√£o de Estoque: √ìleos vs Graxas"
                    )
                    st.plotly_chart(fig_pizza, use_container_width=True)

                    st.write("**Movimenta√ß√µes Recentes:**")
                    df_mov['data'] = pd.to_datetime(df_mov['data'], errors='coerce')
                    df_mov = df_mov.sort_values('data', ascending=False)
                    st.dataframe(df_mov.head(20))
                else:
                    st.info("Nenhum lubrificante cadastrado.")

                conn.close()
            
import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, date, timedelta
import os
import plotly.express as px
import hashlib
import json
import base64
import io
# Configura√ß√£o da p√°gina (deve ser o primeiro comando Streamlit)
st.set_page_config(
    page_title="Dashboard de Frotas - A√ß√∫car Alegre",
    page_icon="üöú",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/projeto-uma',
        'Report a bug': "https://github.com/seu-usuario/projeto-uma/issues",
        'About': "# Dashboard de Frotas\n\nSistema de gest√£o de frotas da A√ß√∫car Alegre\n\nDesenvolvido por Andr√© Luis"
    }
)

# Configura√ß√£o de tema
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark'

# CSS personalizado para tema claro/escuro
def get_theme_css():
    if st.session_state.theme == 'dark':
        return """
        <style>
        .stApp {
            background-color: #0e1117;
            color: #fafafa;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """
    else:
        return """
        <style>
        .stApp {
            background-color: #ffffff;
            color: #262730;
        }
        .stButton > button {
            background-color: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-weight: 600;
        }
        .stButton > button:hover {
            background-color: #00cc6a;
            color: #000;
        }
        .metric-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        </style>
        """

# Aplicar CSS do tema
st.markdown(get_theme_css(), unsafe_allow_html=True)

# Fun√ß√£o para alternar tema
def toggle_theme():
    st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
    st.rerun()

# Fun√ß√£o para exportar dados
def export_dataframe(df, filename, file_type='csv'):
    """Exporta DataFrame em diferentes formatos"""
    if file_type == 'csv':
        csv = df.to_csv(index=False, sep=';', decimal=',', encoding='utf-8-sig')
        st.download_button(
            label=f"üì• Download {filename}.csv",
            data=csv,
            file_name=f"{filename}.csv",
            mime="text/csv",
            help=f"Baixar {filename} em formato CSV"
        )
    elif file_type == 'excel':
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        buffer.seek(0)
        st.download_button(
            label=f"üì• Download {filename}.xlsx",
            data=buffer,
            file_name=f"{filename}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help=f"Baixar {filename} em formato Excel"
        )

# Fun√ß√£o para mostrar loading
def show_loading(message="Carregando dados..."):
    """Mostra indicador de carregamento"""
    with st.spinner(message):
        st.info(f"‚è≥ {message}")
        return True

# Fun√ß√£o para tooltip informativo
def info_tooltip(text, help_text):
    """Cria um elemento com tooltip informativo"""
    col1, col2 = st.columns([20, 1])
    with col1:
        st.write(text)
    with col2:
        st.info("‚ÑπÔ∏è", help=help_text)

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "frotas_data.db")

ALERTAS_MANUTENCAO = {
    'HORAS': { 'default': 20 },
    'QUIL√îMETROS': { 'default': 500 }
}

def formatar_brasileiro(valor: float, prefixo='') -> str:
    """Formata um n√∫mero com casas decimais para o padr√£o brasileiro."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{prefixo}{valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

@st.cache_data(ttl=300)
def para_csv(df: pd.DataFrame):
    """Converte um DataFrame para CSV para download."""
    return df.to_csv(index=False, sep=';', decimal=',').encode('utf-8-sig')

def formatar_brasileiro_int(valor: float) -> str:
    """Formata um n√∫mero inteiro para o padr√£o brasileiro (ex: 123.456)."""
    if pd.isna(valor) or not np.isfinite(valor):
        return "‚Äì"
    return f"{int(valor):,}".replace(",", ".")

def detect_equipment_type(df_completo: pd.DataFrame) -> pd.DataFrame:
    df = df_completo.copy()
    df['Tipo_Controle'] = df.get('Unid', pd.Series(index=df.index)).map({'HORAS': 'HORAS', 'QUIL√îMETROS': 'QUIL√îMETROS'})
    def inferir_tipo_por_classe(row):
        if pd.notna(row['Tipo_Controle']): return row['Tipo_Controle']
        classe = str(row.get('Classe_Operacional', '')).upper()
        if any(p in classe for p in ['TRATOR', 'COLHEITADEIRA', 'PULVERIZADOR', 'PLANTADEIRA', 'P√Å CARREGADEIRA', 'RETROESCAVADEIRA']): return 'HORAS'
        if any(p in classe for p in ['CAMINH√ÉO', 'CAMINHAO', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']): return 'QUIL√îMETROS'
        return 'HORAS'
    df['Tipo_Controle'] = df.apply(inferir_tipo_por_classe, axis=1)
    return df

def hash_password(password):
    """Gera um hash seguro da palavra-passe."""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login_db(username, password):
    """Verifica as credenciais contra a base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash, role FROM utilizadores WHERE username = ?", (username,))
        result = cursor.fetchone()
        conn.close()
        if result:
            password_hash_db, role = result
            if password_hash_db == hash_password(password):
                return role
        return None
    except Exception as e:
        st.error(f"Erro ao aceder √† base de dados de utilizadores: {e}")
        return None

def get_all_users():
    """Busca todos os utilizadores da base de dados."""
    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
        return pd.read_sql_query("SELECT id, username, role FROM utilizadores", conn)

def add_user(username, password, role):
    """Adiciona um novo utilizador √† base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO utilizadores (username, password_hash, role) VALUES (?, ?, ?)",
            (username, hash_password(password), role)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador adicionado com sucesso!"
    except sqlite3.IntegrityError:
        return False, f"Erro: O nome de utilizador '{username}' j√° existe."
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def update_user(user_id, new_username, new_role):
    """Atualiza o nome e a fun√ß√£o de um utilizador."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE utilizadores SET username = ?, role = ? WHERE id = ?",
            (new_username, new_role, user_id)
        )
        conn.commit()
        conn.close()
        return True, "Utilizador atualizado com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

def delete_user(user_id):
    """Remove um utilizador da base de dados."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM utilizadores WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        return True, "Utilizador removido com sucesso!"
    except Exception as e:
        return False, f"Ocorreu um erro: {e}"

    
# APAGUE A SUA FUN√á√ÉO "load_data_from_db" INTEIRA E SUBSTITUA-A POR ESTE BLOCO FINAL

@st.cache_data(show_spinner="Carregando e processando dados...", ttl=300)
def load_data_from_db(db_path: str, ver_frotas: int=None, ver_abast: int=None, ver_manut: int=None, ver_comp: int=None, ver_chk: int=None):
    if not os.path.exists(db_path):
        st.error(f"Arquivo de banco de dados '{db_path}' n√£o encontrado.")
        st.stop()

    try:
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            df_abast = pd.read_sql_query("SELECT rowid, * FROM abastecimentos", conn)
            df_frotas = pd.read_sql_query("SELECT * FROM frotas", conn)
            df_manutencoes = pd.read_sql_query("SELECT rowid, * FROM manutencoes", conn)
            df_comp_regras = pd.read_sql_query("SELECT * FROM componentes_regras", conn)
            df_comp_historico = pd.read_sql_query("SELECT rowid, * FROM componentes_historico", conn)
            df_checklist_regras = pd.read_sql_query("SELECT * FROM checklist_regras", conn)
            df_checklist_itens = pd.read_sql_query("SELECT * FROM checklist_itens", conn)
            df_checklist_historico = pd.read_sql_query("SELECT rowid, * FROM checklist_historico", conn)

        # --- In√≠cio do Processamento Integrado ---
        
        # Renomeia colunas para um padr√£o consistente
        df_abast = df_abast.rename(columns={"C√≥d. Equip.": "Cod_Equip", "Qtde Litros": "Qtde Litros", "M√™s": "Mes", "M√©dia": "Media"}, errors='ignore')
        df_frotas = df_frotas.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip", "Classe Operacional": "Classe_Operacional"}, errors='ignore')

        # Cria o dataframe principal mesclando abastecimentos e frotas
        df_merged = pd.merge(df_abast, df_frotas, on="Cod_Equip", how="left")
        
        # Trata colunas de classe operacional que podem ter vindo da mesclagem
        if 'Classe_Operacional_x' in df_merged.columns:
            df_merged['Classe_Operacional'] = np.where(df_merged['Classe_Operacional_x'].notna(), df_merged['Classe_Operacional_x'], df_merged['Classe_Operacional_y'])
            df_merged.drop(columns=['Classe_Operacional_x', 'Classe_Operacional_y'], inplace=True)
        
        # Converte a coluna de data e cria colunas de tempo
        df_merged["Data"] = pd.to_datetime(df_merged["Data"], errors='coerce')
        df_merged.dropna(subset=["Data"], inplace=True)
        df_merged["Ano"] = df_merged["Data"].dt.year
        df_merged["AnoMes"] = df_merged["Data"].dt.to_period("M").astype(str)
        
        # Limpa e converte colunas num√©ricas
        for col in ["Qtde Litros", "Media", "Hod_Hor_Atual"]:
            if col in df_merged.columns:
                series = df_merged[col].astype(str)
                series = series.str.replace(',', '.', regex=False).str.replace('-', '', regex=False).str.strip()
                df_merged[col] = pd.to_numeric(series, errors='coerce')
        
        # Cria a coluna "label" no dataframe de frotas para uso em seletores
        df_frotas["label"] = df_frotas["Cod_Equip"].astype(str) + " - " + df_frotas.get("DESCRICAO_EQUIPAMENTO", "").fillna("") + " (" + df_frotas.get("PLACA", "").fillna("Sem Placa") + ")"

        # Vincula informa√ß√µes de motorista aos abastecimentos (merge durante o load)
        try:
            with sqlite3.connect(db_path, check_same_thread=False) as conn:
                df_motoristas = pd.read_sql_query("SELECT codigo_pessoa, matricula, nome FROM motoristas", conn)
            if not df_motoristas.empty:
                df_merged = df_merged.merge(
                    df_motoristas.rename(columns={"codigo_pessoa": "Cod_Pessoa", "matricula": "Matricula", "nome": "Nome_Motorista"}),
                    on=["Cod_Pessoa", "Matricula"], how="left"
                )
        except Exception:
            pass
        
        # Garante que a classe operacional em df_frotas est√° atualizada
        classe_map = df_merged.dropna(subset=['Classe_Operacional']).groupby('Cod_Equip')['Classe_Operacional'].first()
        df_frotas['Classe_Operacional'] = df_frotas['Cod_Equip'].map(classe_map).fillna(df_frotas.get('Classe_Operacional'))

        # Adiciona coluna de tipo de combust√≠vel se n√£o existir
        if 'tipo_combustivel' not in df_frotas.columns:
            df_frotas['tipo_combustivel'] = 'Diesel S500'  # Valor padr√£o
        else:
            # Se a coluna existe, apenas preencher valores nulos com padr√£o
            df_frotas['tipo_combustivel'] = df_frotas['tipo_combustivel'].fillna('Diesel S500')

        # Determina o tipo de controle (Horas ou Quil√¥metros) para cada equipamento
        def determinar_tipo_controle(row):
            texto_para_verificar = (
                str(row.get('DESCRICAO_EQUIPAMENTO', '')) + ' ' + 
                str(row.get('Classe_Operacional', ''))
            ).upper()
            km_keywords = ['CAMINH', 'VEICULO', 'PICKUP', 'CAVALO MECANICO']
            if any(p in texto_para_verificar for p in km_keywords):
                return 'QUIL√îMETROS'
            return 'HORAS'
        df_frotas['Tipo_Controle'] = df_frotas.apply(determinar_tipo_controle, axis=1)

        # Retorna todos os dataframes processados
        return (
            df_merged, df_frotas, df_manutencoes,
            df_comp_regras, df_comp_historico,
            df_checklist_regras, df_checklist_itens, df_checklist_historico
        )

    except Exception as e:
        st.error(f"Erro ao ler e processar o banco de dados: {e}")
        st.stop()
        # Retorna dataframes vazios em caso de erro
        return (pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(),
                pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame())

                
    
def inserir_abastecimento(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO abastecimentos (
                "C√≥d. Equip.", Data, "Qtde Litros", Hod_Hor_Atual,
                Safra, "M√™s", "Classe Operacional", Matricula, Cod_Pessoa
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['data'],
            dados['qtde_litros'],
            dados['hod_hor_atual'],
            dados['safra'],
            dados['mes'],
            dados['classe_operacional'],
            dados.get('matricula'),
            dados.get('cod_pessoa')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao inserir dados no banco de dados: {e}")
        return False

def excluir_abastecimento(db_path: str, rowid: int) -> bool:
    """Exclui um registro de abastecimento do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        # Usar rowid √© a forma mais segura de deletar uma linha espec√≠fica
        sql = "DELETE FROM abastecimentos WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir dados do banco de dados: {e}")
        return False

def excluir_manutencao_componente(db_path: str, cod_equip: int, nome_componente: str, data: str, hod_hor: float) -> bool:
    """Exclui um registro de manuten√ß√£o de componente do banco de dados usando uma combina√ß√£o √∫nica de campos."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)
        nome_componente = str(nome_componente)
        data = str(data)
        hod_hor = float(hod_hor)
        
        # Debug: verificar todos os registros na tabela
        cursor.execute("SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico")
        all_records = cursor.fetchall()
        
        # Debug: verificar se h√° registros com valores similares
        cursor.execute(
            "SELECT rowid, Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico FROM componentes_historico WHERE Cod_Equip = ?", 
            (cod_equip,)
        )
        similar_records = cursor.fetchall()
        
        # Primeiro, vamos verificar se o registro existe
        cursor.execute(
            "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        count = cursor.fetchone()[0]
        
        if count == 0:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - Nome Componente: {nome_componente} (tipo: {type(nome_componente)})
            - Data: {data} (tipo: {type(data)})
            - Hod_Hor: {hod_hor} (tipo: {type(hod_hor)})
            
            Registros similares encontrados (mesmo Cod_Equip):
            {similar_records}
            
            Todos os registros na tabela:
            {all_records}
            """
            st.error(debug_info)
            return False
        
        # Agora vamos excluir
        cursor.execute(
            "DELETE FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
            (cod_equip, nome_componente, data, hod_hor)
        )
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute(
                "SELECT COUNT(*) FROM componentes_historico WHERE Cod_Equip = ? AND nome_componente = ? AND Data = ? AND Hod_Hor_No_Servico = ?", 
                (cod_equip, nome_componente, data, hod_hor)
            )
            count_after = cursor.fetchone()[0]
            
            if count_after == 0:
                # For√ßar sincroniza√ß√£o do banco
                cursor.execute("PRAGMA wal_checkpoint(FULL)")
                cursor.execute("PRAGMA synchronous=FULL")
                conn.commit()
                
                # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                backup_success, backup_msg = save_backup_to_session_state()
                if backup_success:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Backup salvo: {backup_msg}")
                else:
                    st.success(f"Manuten√ß√£o de componente exclu√≠da com sucesso! ({rows_deleted} registro(s) removido(s)) | Aviso: {backup_msg}")
                
                conn.close()
                return True
            else:
                st.error("Erro: Registro ainda existe ap√≥s exclus√£o")
                conn.close()
                return False
        else:
            st.error("Nenhum registro foi exclu√≠do")
            conn.close()
            return False
            
    except Exception as e:
        st.error(f"Erro ao excluir manuten√ß√£o de componente do banco de dados: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def excluir_manutencao(db_path: str, rowid: int) -> bool:
    """Exclui um registro de manuten√ß√£o do banco de dados usando seu rowid."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = "DELETE FROM manutencoes WHERE rowid = ?"
        cursor.execute(sql, (rowid,))
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao excluir manuten√ß√£o do banco de dados: {e}")
        return False

def inserir_manutencao(db_path: str, dados: dict) -> bool:
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = 'INSERT INTO manutencoes (Cod_Equip, Data, Tipo_Servico, Hod_Hor_No_Servico) VALUES (?, ?, ?, ?)'
        params = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'])
        cursor.execute(sql, params)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False

def inserir_frota(db_path: str, dados: dict) -> bool:
    """Insere um novo registro de frota no banco de dados."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            INSERT INTO frotas (
                COD_EQUIPAMENTO, DESCRICAO_EQUIPAMENTO, PLACA, 
                "Classe Operacional", ATIVO, tipo_combustivel
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        valores = (
            dados['cod_equip'],
            dados['descricao'],
            dados['placa'],
            dados['classe_op'],
            dados['ativo'],
            dados.get('tipo_combustivel', 'Diesel S500')
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return False
    

def editar_abastecimento(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de abastecimento existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE abastecimentos SET
                "C√≥d. Equip." = ?, Data = ?, "Qtde Litros" = ?, Hod_Hor_Atual = ?, Safra = ?, Matricula = ?, Cod_Pessoa = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'], dados['data'], dados['qtde_litros'], dados['hod_hor_atual'], dados['safra'],
            dados.get('matricula'), dados.get('cod_pessoa'), rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar abastecimento: {e}")
        return False

def editar_manutencao(db_path: str, rowid: int, dados: dict) -> bool:
    """Atualiza um registro de manuten√ß√£o existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE manutencoes SET
                Cod_Equip = ?, Data = ?, Tipo_Servico = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (dados['cod_equip'], dados['data'], dados['tipo_servico'], dados['hod_hor_servico'], rowid)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar manuten√ß√£o: {e}")
        return False

def editar_manutencao_componente(db_path: str, rowid: int, dados: dict) -> bool:
    """Edita um registro de manuten√ß√£o de componente existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE componentes_historico 
            SET Cod_Equip = ?, nome_componente = ?, Observacoes = ?, Data = ?, Hod_Hor_No_Servico = ?
            WHERE rowid = ?
        """
        valores = (
            dados['cod_equip'],
            dados['componente'],
            dados['acao'],
            dados['data'],
            dados['hod_hor_servico'],
            rowid
        )
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao editar manuten√ß√£o de componente no banco de dados: {e}")
        return False

def importar_abastecimentos_de_planilha(db_path: str, arquivo_carregado) -> tuple[int, int, str]:
    """L√™ uma planilha, verifica por duplicados, e insere os novos dados. Aceita opcionalmente as colunas Matricula e Cod_Pessoa."""
    try:
        df_novo = pd.read_excel(arquivo_carregado)
        
        mapa_colunas = {
            "C√≥d. Equip.": "C√≥d. Equip.",
            "Data": "Data",
            "Qtde Litros": "Qtde Litros",
            "Hod. Hor. Atual": "Hod_Hor_Atual",
            "Safra": "Safra",
            "M√™s": "M√™s",
            "Classe Operacional": "Classe Operacional",
            "Matricula": "Matricula",
            "Cod_Pessoa": "Cod_Pessoa",
        }
        df_novo = df_novo.rename(columns={k: v for k, v in mapa_colunas.items() if k in df_novo.columns})

        colunas_necessarias = ["C√≥d. Equip.", "Data", "Qtde Litros", "Hod_Hor_Atual", "Safra", "M√™s", "Classe Operacional"]
        colunas_opcionais = ["Matricula", "Cod_Pessoa"]
        colunas_faltando = [col for col in colunas_necessarias if col not in df_novo.columns]
        if colunas_faltando:
            return 0, 0, f"Erro: Colunas n√£o encontradas: {', '.join(colunas_faltando)}"
        conn = sqlite3.connect(db_path)
        df_existente = pd.read_sql_query("SELECT * FROM abastecimentos", conn)
        
        df_novo['Data'] = pd.to_datetime(df_novo['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')
        df_existente['Data'] = pd.to_datetime(df_existente['Data']).dt.strftime('%Y-%m-%d %H:%M:%S')

        df_novo['chave_unica'] = df_novo['C√≥d. Equip.'].astype(str) + '_' + df_novo['Data'] + '_' + df_novo['Qtde Litros'].astype(str)
        df_existente['chave_unica'] = df_existente['C√≥d. Equip.'].astype(str) + '_' + df_existente['Data'] + '_' + df_existente['Qtde Litros'].astype(str)

        df_para_inserir = df_novo[~df_novo['chave_unica'].isin(df_existente['chave_unica'])]
        
        num_duplicados = len(df_novo) - len(df_para_inserir)

        if df_para_inserir.empty:
            return 0, num_duplicados, "Nenhum registo novo para importar. Todos os registos da planilha j√° existem na base de dados."

        colunas_insert = colunas_necessarias + [c for c in colunas_opcionais if c in df_para_inserir.columns]
        df_para_inserir_final = df_para_inserir[colunas_insert]
        registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
        
        cursor = conn.cursor()
        placeholders = ", ".join(["?"] * len(colunas_insert))
        sql = f"INSERT INTO abastecimentos ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
        cursor.executemany(sql, registros)
        
        conn.commit()
        num_inseridos = cursor.rowcount
        conn.close()
        
        mensagem_sucesso = f"{num_inseridos} registos novos foram importados com sucesso."
        if num_duplicados > 0:
            mensagem_sucesso += f" {num_duplicados} registos duplicados foram ignorados."
            
        return num_inseridos, num_duplicados, mensagem_sucesso

    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o: {e}"

def editar_frota(db_path: str, cod_equip: int, dados: dict) -> bool:
    """Atualiza um registro de frota existente."""
    try:
        conn = sqlite3.connect(db_path, check_same_thread=False)
        cursor = conn.cursor()
        sql = """
            UPDATE frotas SET
                DESCRICAO_EQUIPAMENTO = ?, PLACA = ?, "Classe Operacional" = ?, ATIVO = ?, tipo_combustivel = ?
            WHERE COD_EQUIPAMENTO = ?
        """
        valores = (dados['descricao'], dados['placa'], dados['classe_op'], dados['ativo'], dados.get('tipo_combustivel', 'Diesel S500'), cod_equip)
        cursor.execute(sql, valores)
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        st.error(f"Erro ao atualizar frota: {e}")
        return False

# COLE ESTE BLOCO DE C√ìDIGO NO LOCAL INDICADO

def get_component_rules():
    """Busca todas as regras de componentes da base de dados."""
    with sqlite3.connect(DB_PATH) as conn:
        return pd.read_sql_query("SELECT * FROM componentes_regras", conn)

def add_component_rule(classe, componente, intervalo):
    """Adiciona uma nova regra de componente √† base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao) VALUES (?, ?, ?)",
                (classe, componente, intervalo)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def add_component_rule_advanced(classe, componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca", capacidade_litros=0.0):
    """Adiciona uma nova regra de componente com informa√ß√µes de lubrificante e tipo de manuten√ß√£o."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            cursor.execute(
                "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, tipo_manutencao, capacidade_litros) VALUES (?, ?, ?, ?, ?, ?)",
                (classe, componente, intervalo, lubrificante_id, tipo_manutencao, capacidade_litros)
            )
            conn.commit()
        return True, f"Componente '{componente}' adicionado com sucesso √† classe '{classe}'."
    except Exception as e:
        return False, f"Erro ao adicionar componente: {e}"

def delete_component_rule(rule_id):
    """Remove uma regra de componente da base de dados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM componentes_regras WHERE id_regra = ?", (rule_id,))
            conn.commit()
        return True, "Componente removido com sucesso."
    except Exception as e:
        return False, f"Erro ao remover componente: {e}"

def add_component_service(cod_equip, componente, data, hod_hor, obs):
    """Adiciona um novo registo de servi√ßo de componente ao hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, Observacoes) VALUES (?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def add_component_service_advanced(cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado=None, obs=""):
    """Adiciona um novo registo de servi√ßo de componente com informa√ß√µes detalhadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            cursor.execute(
                "INSERT INTO componentes_historico (Cod_Equip, nome_componente, Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (cod_equip, componente, data, hod_hor, tipo_servico, lubrificante_utilizado, obs)
            )
            conn.commit()
        return True, "Servi√ßo de componente registado com sucesso."
    except Exception as e:
        return False, f"Erro ao registar servi√ßo: {e}"

def get_component_status(cod_equip, componente):
    """Obt√©m o status atual de um componente espec√≠fico de um equipamento."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            # Buscar a √∫ltima manuten√ß√£o do componente
            query = """
            SELECT Data, Hod_Hor_No_Servico, tipo_servico, lubrificante_utilizado, Observacoes
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            ORDER BY Data DESC, Hod_Hor_No_Servico DESC
            LIMIT 1
            """
            df_ultima = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            
            # Buscar a regra do componente para obter o intervalo
            query_regra = """
            SELECT intervalo_padrao, lubrificante_id, tipo_manutencao
            FROM componentes_regras cr
            JOIN frotas f ON cr.classe_operacional = f."Classe Operacional"
            WHERE f.COD_EQUIPAMENTO = ? AND cr.nome_componente = ?
            """
            df_regra = pd.read_sql_query(query_regra, conn, params=(cod_equip, componente))
            
            # Buscar o hod√¥metro/hor√≠metro atual do equipamento
            query_hod = """
            SELECT Hod_Hor_Atual FROM abastecimentos 
            WHERE Cod_Equip = ? 
            ORDER BY Data DESC, Hod_Hor_Atual DESC 
            LIMIT 1
            """
            df_hod = pd.read_sql_query(query_hod, conn, params=(cod_equip,))
            
            return df_ultima, df_regra, df_hod
            
    except Exception as e:
        st.error(f"Erro ao obter status do componente: {e}")
        return None, None, None

def get_component_maintenance_count(cod_equip, componente):
    """Obt√©m o n√∫mero total de manuten√ß√µes realizadas em um componente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT COUNT(*) as total_manutencoes,
                   COUNT(CASE WHEN tipo_servico = 'Troca' THEN 1 END) as total_trocas,
                   COUNT(CASE WHEN tipo_servico = 'Remonta' THEN 1 END) as total_remontas
            FROM componentes_historico 
            WHERE Cod_Equip = ? AND nome_componente = ?
            """
            df_count = pd.read_sql_query(query, conn, params=(cod_equip, componente))
            return df_count.iloc[0] if not df_count.empty else {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}
            
    except Exception as e:
        st.error(f"Erro ao obter contagem de manuten√ß√µes: {e}")
        return {'total_manutencoes': 0, 'total_trocas': 0, 'total_remontas': 0}

def editar_manutencao_componente_advanced(DB_PATH, rowid, dados_editados):
    """Edita uma manuten√ß√£o de componente com informa√ß√µes avan√ßadas."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_historico)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'tipo_servico' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN tipo_servico TEXT DEFAULT 'Troca'")
            if 'lubrificante_utilizado' not in columns:
                cursor.execute("ALTER TABLE componentes_historico ADD COLUMN lubrificante_utilizado TEXT")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_historico 
                SET Cod_Equip = ?, nome_componente = ?, Data = ?, Hod_Hor_No_Servico = ?, 
                    Observacoes = ?, tipo_servico = ?, lubrificante_utilizado = ?
                WHERE rowid = ?
            """, (
                dados_editados['cod_equip'],
                dados_editados['componente'],
                dados_editados['data'],
                dados_editados['hod_hor_servico'],
                dados_editados['acao'],
                dados_editados['tipo_servico'],
                dados_editados['lubrificante_utilizado'],
                rowid
            ))
            conn.commit()
        return True, "Manuten√ß√£o de componente atualizada com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar manuten√ß√£o de componente: {e}"

def update_component_rule(rule_id, nome_componente, intervalo, lubrificante_id=None, tipo_manutencao="Troca"):
    """Atualiza uma regra de componente existente."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # Verificar se a tabela tem as colunas necess√°rias
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            # Adicionar colunas se n√£o existirem
            if 'lubrificante_id' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN lubrificante_id INTEGER")
            if 'tipo_manutencao' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN tipo_manutencao TEXT DEFAULT 'Troca'")
            
            # Atualizar os dados
            cursor.execute("""
                UPDATE componentes_regras 
                SET nome_componente = ?, intervalo_padrao = ?, lubrificante_id = ?, tipo_manutencao = ?
                WHERE id_regra = ?
            """, (nome_componente, intervalo, lubrificante_id, tipo_manutencao, rule_id))
            conn.commit()
        return True, f"Componente '{nome_componente}' atualizado com sucesso."
    except Exception as e:
        return False, f"Erro ao atualizar componente: {e}"

def get_frota_combustivel(cod_equip):
    """Obt√©m o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tipo_combustivel FROM frotas WHERE COD_EQUIPAMENTO = ?", (cod_equip,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        st.error(f"Erro ao obter tipo de combust√≠vel: {e}")
        return None

def update_frota_combustivel(cod_equip, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de uma frota espec√≠fica."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE COD_EQUIPAMENTO = ?", (tipo_combustivel, cod_equip))
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel: {e}"

def update_classe_combustivel(classe_operacional, tipo_combustivel):
    """Atualiza o tipo de combust√≠vel de todas as frotas de uma classe."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE frotas SET tipo_combustivel = ? WHERE \"Classe Operacional\" = ?", (tipo_combustivel, classe_operacional))
            rows_updated = cursor.rowcount
            conn.commit()
        return True, f"Tipo de combust√≠vel atualizado para {tipo_combustivel} em {rows_updated} frotas da classe {classe_operacional}"
    except Exception as e:
        return False, f"Erro ao atualizar tipo de combust√≠vel da classe: {e}"

def add_tipo_combustivel_column():
    """Adiciona a coluna tipo_combustivel √† tabela frotas se ela n√£o existir."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            # Verificar se a coluna existe
            cursor.execute("PRAGMA table_info(frotas)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'tipo_combustivel' not in columns:
                cursor.execute("ALTER TABLE frotas ADD COLUMN tipo_combustivel TEXT DEFAULT 'Diesel S500'")
                conn.commit()
                return True, "Coluna tipo_combustivel adicionada com sucesso"
            else:
                return True, "Coluna tipo_combustivel j√° existe"
    except Exception as e:
        return False, f"Erro ao adicionar coluna tipo_combustivel: {e}"

def ensure_motoristas_schema():
    """Garante a exist√™ncia da tabela de motoristas e das colunas de v√≠nculo em abastecimentos."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS motoristas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    codigo_pessoa TEXT,
                    matricula TEXT UNIQUE,
                    nome TEXT,
                    ativo TEXT DEFAULT 'ATIVO'
                )
                """
            )
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_matricula ON motoristas(matricula)")
            cursor.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_motoristas_codigo_pessoa ON motoristas(codigo_pessoa)")

            cursor.execute("PRAGMA table_info(abastecimentos)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'Matricula' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Matricula TEXT")
            if 'Cod_Pessoa' not in cols:
                cursor.execute("ALTER TABLE abastecimentos ADD COLUMN Cod_Pessoa TEXT")
            conn.commit()
        return True, "Esquema de motoristas verificado"
    except Exception as e:
        return False, f"Erro ao verificar esquema de motoristas: {e}"

def get_all_motoristas() -> pd.DataFrame:
    """Retorna o DataFrame de motoristas."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM motoristas", conn)
    except Exception:
        return pd.DataFrame(columns=['id', 'codigo_pessoa', 'matricula', 'nome', 'ativo'])

def importar_motoristas_de_planilha(db_path: str, arquivo_carregado):
    """Importa motoristas a partir de planilha Excel. Espera colunas: Matricula, Nome e opcional Cod_Pessoa/C√≥digo Pessoa."""
    try:
        df_mot = pd.read_excel(arquivo_carregado)
        df_mot.columns = [c.strip() for c in df_mot.columns]
        renomeios = {
            'Matr√≠cula': 'Matricula', 'matricula': 'Matricula', 'MATRICULA': 'Matricula',
            'Nome': 'Nome', 'nome': 'Nome', 'NOME': 'Nome',
            'Cod_Pessoa': 'Cod_Pessoa', 'C√≥digo Pessoa': 'Cod_Pessoa', 'codigo_pessoa': 'Cod_Pessoa', 'CODIGO_PESSOA': 'Cod_Pessoa'
        }
        df_mot.rename(columns={k: v for k, v in renomeios.items() if k in df_mot.columns}, inplace=True)
        obrig = ['Matricula', 'Nome']
        faltando = [c for c in obrig if c not in df_mot.columns]
        if faltando:
            return 0, 0, f"Erro: Colunas obrigat√≥rias n√£o encontradas: {', '.join(faltando)}"
        if 'Cod_Pessoa' not in df_mot.columns:
            df_mot['Cod_Pessoa'] = None
        df_mot = df_mot.dropna(subset=['Matricula', 'Nome']).copy()
        df_mot['Matricula'] = df_mot['Matricula'].astype(str).str.strip()
        df_mot['Nome'] = df_mot['Nome'].astype(str).str.strip()
        df_mot['Cod_Pessoa'] = df_mot['Cod_Pessoa'].astype(str).str.strip()
        df_mot = df_mot.drop_duplicates(subset=['Matricula'])
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            existentes = pd.read_sql_query("SELECT matricula FROM motoristas", conn)
            set_exist = set(existentes['matricula'].astype(str)) if not existentes.empty else set()
            df_novos = df_mot[~df_mot['Matricula'].isin(set_exist)].copy()
            if df_novos.empty:
                return 0, len(df_mot), "Nenhum motorista novo para importar. Todos j√° existem."
            registros = [
                (row.get('Cod_Pessoa', None), row['Matricula'], row['Nome'], 'ATIVO')
                for _, row in df_novos.iterrows()
            ]
            cur = conn.cursor()
            cur.executemany(
                "INSERT INTO motoristas (codigo_pessoa, matricula, nome, ativo) VALUES (?, ?, ?, ?)",
                registros
            )
            conn.commit()
            inseridos = cur.rowcount if cur.rowcount is not None else len(registros)
            duplicados = len(df_mot) - len(df_novos)
            return inseridos, duplicados, f"{inseridos} motoristas importados com sucesso. {duplicados} j√° existiam."
    except Exception as e:
        return 0, 0, f"Ocorreu um erro inesperado durante a importa√ß√£o de motoristas: {e}"
    
def ensure_pneus_schema():
    """Garante a exist√™ncia da tabela de hist√≥rico de pneus."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pneus_historico (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    Cod_Equip INTEGER,
                    posicao TEXT,
                    marca TEXT,
                    modelo TEXT,
                    numero_fogo TEXT,
                    data_instalacao TEXT,
                    hodometro_instalacao REAL,
                    
                    observacoes TEXT,
                    status TEXT DEFAULT 'Ativo',
                    vida_atual INTEGER DEFAULT 1
                )
            """)
            # Adiciona colunas se n√£o existirem
            cursor.execute("PRAGMA table_info(pneus_historico)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'status' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN status TEXT DEFAULT 'Ativo'")
            if 'vida_atual' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN vida_atual INTEGER DEFAULT 1")
            if 'numero_fogo' not in cols:
                cursor.execute("ALTER TABLE pneus_historico ADD COLUMN numero_fogo TEXT")
            conn.commit()
        return True, "Tabela de pneus verificada"
    except Exception as e:
        return False, f"Erro ao criar tabela de pneus: {e}"

def importar_pneus_de_planilha(db_path: str, arquivo_carregado):
    """Importa hist√≥rico de pneus de uma planilha Excel, verificando duplicatas."""
    try:
        df_pneus = pd.read_excel(arquivo_carregado)
        df_pneus.columns = [c.strip() for c in df_pneus.columns]
        obrig = ['Cod_Equip', 'posicao', 'marca', 'modelo', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao']
        faltando = [c for c in obrig if c not in df_pneus.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
            if 'observacoes' not in df_pneus.columns:
                    df_pneus['observacoes'] = ""
            
        
        # Limpar dados e remover linhas com valores nulos obrigat√≥rios
        df_pneus = df_pneus.dropna(subset=['Cod_Equip', 'posicao', 'numero_fogo'])
        
        # Normalizar tipos de dados
        df_pneus['Cod_Equip'] = df_pneus['Cod_Equip'].astype(str)
        df_pneus['posicao'] = df_pneus['posicao'].astype(str).str.strip()
        df_pneus['numero_fogo'] = df_pneus['numero_fogo'].astype(str).str.strip()
        df_pneus['data_instalacao'] = pd.to_datetime(df_pneus['data_instalacao']).dt.strftime('%Y-%m-%d')
        
        # Remover duplicatas na pr√≥pria planilha baseada em chave √∫nica
        df_pneus = df_pneus.drop_duplicates(subset=['Cod_Equip', 'posicao', 'numero_fogo', 'data_instalacao', 'hodometro_instalacao'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Buscar registros existentes para verificar duplicatas
            df_existente = pd.read_sql_query("SELECT Cod_Equip, posicao, numero_fogo, data_instalacao, hodometro_instalacao FROM pneus_historico", conn)
            
            if not df_existente.empty:
                # Normalizar dados existentes para compara√ß√£o
                df_existente['Cod_Equip'] = df_existente['Cod_Equip'].astype(str)
                df_existente['posicao'] = df_existente['posicao'].astype(str).str.strip()
                df_existente['numero_fogo'] = df_existente['numero_fogo'].astype(str).str.strip()
                df_existente['data_instalacao'] = pd.to_datetime(df_existente['data_instalacao']).dt.strftime('%Y-%m-%d')
                
                # Criar chaves √∫nicas para compara√ß√£o
                df_pneus['chave_unica'] = (df_pneus['Cod_Equip'] + '_' + 
                                          df_pneus['posicao'] + '_' + 
                                          df_pneus['numero_fogo'] + '_' + 
                                          df_pneus['data_instalacao'] + '_' + 
                                          df_pneus['hodometro_instalacao'].astype(str))
                
                df_existente['chave_unica'] = (df_existente['Cod_Equip'] + '_' + 
                                              df_existente['posicao'] + '_' + 
                                              df_existente['numero_fogo'] + '_' + 
                                              df_existente['data_instalacao'] + '_' + 
                                              df_existente['hodometro_instalacao'].astype(str))
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_pneus[~df_pneus['chave_unica'].isin(df_existente['chave_unica'])]
            else:
                df_para_inserir = df_pneus
            
            num_duplicados = len(df_pneus) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum pneu novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = obrig + ['observacoes']
            # Garantir que a coluna observacoes exista no DataFrame
            if 'observacoes' not in df_para_inserir.columns:
                df_para_inserir['observacoes'] = ''
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.fillna('').to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO pneus_historico ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} pneus novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar pneus: {e}"

def get_pneus_historico(cod_equip=None):
    """Retorna o hist√≥rico de pneus, opcionalmente filtrando por frota."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            query = "SELECT * FROM pneus_historico"
            params = ()
            if cod_equip:
                query += " WHERE Cod_Equip = ?"
                params = (cod_equip,)
            return pd.read_sql_query(query, conn, params=params)
    except Exception:
        return pd.DataFrame()

def ensure_precos_combustivel_schema():
    """Garante a exist√™ncia da tabela de pre√ßos por tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                CREATE TABLE IF NOT EXISTS precos_combustivel (
                    tipo_combustivel TEXT PRIMARY KEY,
                    preco REAL
                )
                """
            )
            tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
            for t in tipos:
                cur.execute("INSERT OR IGNORE INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?)", (t, NULL))
            conn.commit()
        return True, "Tabela de pre√ßos verificada"
    except Exception as e:
        return False, f"Erro ao verificar tabela de pre√ßos: {e}"

def get_precos_combustivel_map() -> dict:
    """Retorna um dicion√°rio {tipo_combustivel: preco}."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            dfp = pd.read_sql_query("SELECT tipo_combustivel, preco FROM precos_combustivel", conn)
        return {row['tipo_combustivel']: row['preco'] for _, row in dfp.iterrows()}
    except Exception:
        return {}

def upsert_preco_combustivel(tipo: str, preco: float) -> tuple[bool, str]:
    """Cria/atualiza pre√ßo para um tipo de combust√≠vel."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO precos_combustivel (tipo_combustivel, preco) VALUES (?, ?) ON CONFLICT(tipo_combustivel) DO UPDATE SET preco=excluded.preco",
                (tipo, preco)
            )
            conn.commit()
        return True, f"Pre√ßo atualizado para {tipo}"
    except Exception as e:
        return False, f"Erro ao atualizar pre√ßo: {e}"
    
def ensure_lubrificantes_schema():
    """Garante a exist√™ncia da tabela de lubrificantes, movimenta√ß√µes e almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            
            # Tabela de lubrificantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT,
                    viscosidade TEXT,
                    quantidade_estoque REAL,
                    unidade TEXT,
                    observacoes TEXT
                )
            """)
            
            # Verificar e adicionar coluna 'tipo' se n√£o existir
            cursor.execute("PRAGMA table_info(lubrificantes)")
            cols = [c[1] for c in cursor.fetchall()]
            if 'tipo' not in cols:
                cursor.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
            
            # Tabela de almoxarifados
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifados (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    nome TEXT NOT NULL,
                    tipo TEXT DEFAULT 'fixo', -- 'fixo' para oficina, 'movel' para caminh√µes
                    localizacao TEXT,
                    responsavel TEXT,
                    observacoes TEXT,
                    ativo BOOLEAN DEFAULT 1
                )
            """)
            
            # Tabela de estoque por almoxarifado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS almoxarifado_estoque (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_almoxarifado INTEGER,
                    id_lubrificante INTEGER,
                    quantidade_estoque REAL DEFAULT 0,
                    unidade TEXT,
                    data_atualizacao TEXT,
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id),
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    UNIQUE(id_almoxarifado, id_lubrificante)
                )
            """)
            
            # Tabela de movimenta√ß√µes (atualizada para incluir almoxarifado)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS lubrificantes_movimentacoes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    id_lubrificante INTEGER,
                    id_almoxarifado INTEGER,
                    tipo TEXT, -- 'entrada' ou 'saida'
                    quantidade REAL,
                    data TEXT,
                    cod_equip INTEGER,
                    observacoes TEXT,
                    FOREIGN KEY(id_lubrificante) REFERENCES lubrificantes(id),
                    FOREIGN KEY(id_almoxarifado) REFERENCES almoxarifados(id)
                )
            """)
            
            # Verificar se a coluna id_almoxarifado existe na tabela de movimenta√ß√µes
            cursor.execute("PRAGMA table_info(lubrificantes_movimentacoes)")
            cols_mov = [c[1] for c in cursor.fetchall()]
            if 'id_almoxarifado' not in cols_mov:
                cursor.execute("ALTER TABLE lubrificantes_movimentacoes ADD COLUMN id_almoxarifado INTEGER")
            
            conn.commit()
        return True, "Tabelas de lubrificantes e almoxarifados verificadas"
    except Exception as e:
        return False, f"Erro ao criar tabelas de lubrificantes: {e}"
    
def add_almoxarifado(nome, tipo="fixo", localizacao="", responsavel="", observacoes=""):
    """Adiciona um novo almoxarifado."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO almoxarifados (nome, tipo, localizacao, responsavel, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, tipo, localizacao, responsavel, observacoes)
            )
            conn.commit()
        return True, "Almoxarifado cadastrado com sucesso!"
    except Exception as e:
        return False, f"Erro: {e}"

def get_almoxarifados():
    """Retorna todos os almoxarifados ativos."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            df = pd.read_sql("SELECT * FROM almoxarifados WHERE ativo = 1 ORDER BY nome", conn)
        return df
    except Exception as e:
        return pd.DataFrame()

def get_estoque_por_almoxarifado(id_lubrificante):
    """Retorna o estoque de um lubrificante distribu√≠do por almoxarifados."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            query = """
            SELECT 
                a.nome as almoxarifado,
                a.tipo,
                COALESCE(ae.quantidade_estoque, 0) as quantidade,
                COALESCE(ae.unidade, l.unidade) as unidade,
                a.localizacao,
                a.responsavel
            FROM almoxarifados a
            CROSS JOIN lubrificantes l
            LEFT JOIN almoxarifado_estoque ae ON a.id = ae.id_almoxarifado AND l.id = ae.id_lubrificante
            WHERE l.id = ? AND a.ativo = 1
            ORDER BY a.nome
            """
            df = pd.read_sql(query, conn, params=(id_lubrificante,))
        return df
    except Exception as e:
        return pd.DataFrame()

def atualizar_estoque_almoxarifado(id_almoxarifado, id_lubrificante, quantidade, unidade):
    """Atualiza o estoque de um lubrificante em um almoxarifado espec√≠fico."""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO almoxarifado_estoque 
                (id_almoxarifado, id_lubrificante, quantidade_estoque, unidade, data_atualizacao) 
                VALUES (?, ?, ?, ?, ?)
            """, (id_almoxarifado, id_lubrificante, quantidade, unidade, date.today().strftime("%Y-%m-%d")))
            conn.commit()
        return True, "Estoque atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao atualizar estoque: {e}"

def add_lubrificante(nome, viscosidade, quantidade, unidade, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes (nome, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?)",
                (nome, viscosidade, quantidade, unidade, observacoes)
            )
            conn.commit()
        return True, "Lubrificante cadastrado!"
    except Exception as e:
        return False, f"Erro: {e}"

def importar_lubrificantes_de_planilha(db_path: str, arquivo_carregado):
    """Importa lubrificantes de uma planilha Excel, verificando duplicatas."""
    try:
        df_lub = pd.read_excel(arquivo_carregado)
        df_lub.columns = [c.strip() for c in df_lub.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome': 'nome',
            'tipo': 'tipo',
            'viscosidade': 'viscosidade',
            'quantidade_estoque': 'quantidade_estoque',
            'unidade': 'unidade',
            'observacoes': 'observacoes'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_lub.columns:
                df_lub = df_lub.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome']
        faltando = [c for c in obrig if c not in df_lub.columns]
        if faltando:
            return 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'tipo' not in df_lub.columns:
            df_lub['tipo'] = '√≥leo'
        if 'viscosidade' not in df_lub.columns:
            df_lub['viscosidade'] = ''
        if 'quantidade_estoque' not in df_lub.columns:
            df_lub['quantidade_estoque'] = 0
        if 'unidade' not in df_lub.columns:
            df_lub['unidade'] = 'L'
        if 'observacoes' not in df_lub.columns:
            df_lub['observacoes'] = ''
        
        # Limpar e normalizar dados
        df_lub = df_lub.dropna(subset=['nome'])
        df_lub['nome'] = df_lub['nome'].astype(str).str.strip()
        df_lub['tipo'] = df_lub['tipo'].astype(str).str.strip().fillna('√≥leo')
        df_lub['viscosidade'] = df_lub['viscosidade'].astype(str).str.strip().fillna('')
        df_lub['quantidade_estoque'] = pd.to_numeric(df_lub['quantidade_estoque'], errors='coerce').fillna(0)
        df_lub['unidade'] = df_lub['unidade'].astype(str).str.strip().fillna('L')
        df_lub['observacoes'] = df_lub['observacoes'].astype(str).str.strip().fillna('')
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome
        df_lub = df_lub.drop_duplicates(subset=['nome'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que a tabela existe com a coluna tipo
            ensure_lubrificantes_schema()
            
            # Buscar lubrificantes existentes
            df_existente = pd.read_sql_query("SELECT nome FROM lubrificantes", conn)
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome'] = df_existente['nome'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem
                df_para_inserir = df_lub[~df_lub['nome'].isin(df_existente['nome'])]
            else:
                df_para_inserir = df_lub
            
            num_duplicados = len(df_lub) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, "Nenhum lubrificante novo para importar. Todos os registros da planilha j√° existem na base de dados."
            
            # Preparar registros para inser√ß√£o
            colunas_insert = ['nome', 'tipo', 'viscosidade', 'quantidade_estoque', 'unidade', 'observacoes']
            df_para_inserir_final = df_para_inserir[colunas_insert]
            registros = [tuple(x) for x in df_para_inserir_final.to_numpy()]
            
            cur = conn.cursor()
            placeholders = ", ".join(["?"] * len(colunas_insert))
            sql = f"INSERT INTO lubrificantes ({', '.join(f'\"{col}\"' for col in colunas_insert)}) VALUES ({placeholders})"
            cur.executemany(sql, registros)
            conn.commit()
            
            num_inseridos = len(registros)
            
            mensagem_sucesso = f"{num_inseridos} lubrificantes novos foram importados com sucesso."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} registros duplicados foram ignorados."
            
            return num_inseridos, num_duplicados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, f"Erro ao importar lubrificantes: {e}"

def importar_componentes_de_planilha(db_path: str, arquivo_carregado, classe_operacional: str):
    """Importa componentes de uma planilha Excel, verificando duplicatas e criando lubrificantes se necess√°rio."""
    try:
        df_comp = pd.read_excel(arquivo_carregado)
        df_comp.columns = [c.strip() for c in df_comp.columns]
        
        # Mapeamento de colunas
        mapa_colunas = {
            'nome_componente': 'nome_componente',
            'componente': 'nome_componente',
            'intervalo_padrao': 'intervalo_padrao',
            'intervalo': 'intervalo_padrao',
            'lubrificante_nome': 'lubrificante_nome',
            'lubrificante': 'lubrificante_nome',
            'capacidade_litros': 'capacidade_litros',
            'capacidade': 'capacidade_litros'
        }
        
        # Normalizar nomes de colunas
        for col_orig, col_norm in mapa_colunas.items():
            if col_orig in df_comp.columns:
                df_comp = df_comp.rename(columns={col_orig: col_norm})
        
        # Verificar colunas obrigat√≥rias
        obrig = ['nome_componente', 'intervalo_padrao']
        faltando = [c for c in obrig if c not in df_comp.columns]
        if faltando:
            return 0, 0, 0, f"Colunas obrigat√≥rias faltando: {', '.join(faltando)}"
        
        # Adicionar colunas opcionais se n√£o existirem
        if 'lubrificante_nome' not in df_comp.columns:
            df_comp['lubrificante_nome'] = None
        if 'capacidade_litros' not in df_comp.columns:
            df_comp['capacidade_litros'] = 0.0
        
        # Limpar e normalizar dados
        df_comp = df_comp.dropna(subset=['nome_componente'])
        df_comp['nome_componente'] = df_comp['nome_componente'].astype(str).str.strip()
        df_comp['intervalo_padrao'] = pd.to_numeric(df_comp['intervalo_padrao'], errors='coerce')
        df_comp = df_comp.dropna(subset=['intervalo_padrao'])
        df_comp['lubrificante_nome'] = df_comp['lubrificante_nome'].astype(str).str.strip().replace('nan', None)
        df_comp['capacidade_litros'] = pd.to_numeric(df_comp['capacidade_litros'], errors='coerce').fillna(0.0)
        
        # Remover duplicatas na pr√≥pria planilha baseada no nome do componente
        df_comp = df_comp.drop_duplicates(subset=['nome_componente'])
        
        with sqlite3.connect(db_path, check_same_thread=False) as conn:
            # Garantir que as tabelas existem
            ensure_lubrificantes_schema()
            
            # Verificar se a tabela componentes_regras tem a coluna capacidade_litros
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(componentes_regras)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'capacidade_litros' not in columns:
                cursor.execute("ALTER TABLE componentes_regras ADD COLUMN capacidade_litros REAL DEFAULT 0.0")
            
            # Buscar componentes existentes na classe
            df_existente = pd.read_sql_query(
                "SELECT nome_componente FROM componentes_regras WHERE classe_operacional = ?", 
                conn, params=(classe_operacional,)
            )
            
            if not df_existente.empty:
                # Normalizar nomes existentes para compara√ß√£o
                df_existente['nome_componente'] = df_existente['nome_componente'].astype(str).str.strip()
                
                # Filtrar apenas registros que n√£o existem na classe
                df_para_inserir = df_comp[~df_comp['nome_componente'].isin(df_existente['nome_componente'])]
            else:
                df_para_inserir = df_comp
            
            num_duplicados = len(df_comp) - len(df_para_inserir)
            
            if df_para_inserir.empty:
                return 0, num_duplicados, 0, "Nenhum componente novo para importar. Todos os registros da planilha j√° existem na classe selecionada."
            
            # Processar lubrificantes
            lubrificantes_criados = 0
            for _, row in df_para_inserir.iterrows():
                if pd.notna(row['lubrificante_nome']) and row['lubrificante_nome']:
                    # Verificar se o lubrificante existe
                    df_lub_existente = pd.read_sql_query(
                        "SELECT id FROM lubrificantes WHERE nome = ?", 
                        conn, params=(row['lubrificante_nome'],)
                    )
                    
                    if df_lub_existente.empty:
                        # Criar lubrificante automaticamente
                        cur = conn.cursor()
                        cur.execute(
                            "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                            (row['lubrificante_nome'], '√≥leo', '', 0, 'L', f'Criado automaticamente durante importa√ß√£o de componentes')
                        )
                        lubrificantes_criados += 1
                        
                        # Buscar o ID do lubrificante criado
                        lub_id = cur.lastrowid
                    else:
                        lub_id = df_lub_existente.iloc[0]['id']
                else:
                    lub_id = None
                
                # Inserir componente
                cur = conn.cursor()
                cur.execute(
                    "INSERT INTO componentes_regras (classe_operacional, nome_componente, intervalo_padrao, lubrificante_id, capacidade_litros) VALUES (?, ?, ?, ?, ?)",
                    (classe_operacional, row['nome_componente'], row['intervalo_padrao'], lub_id, row['capacidade_litros'])
                )
            
            conn.commit()
            num_inseridos = len(df_para_inserir)
            
            mensagem_sucesso = f"{num_inseridos} componentes foram importados com sucesso para a classe '{classe_operacional}'."
            if num_duplicados > 0:
                mensagem_sucesso += f" {num_duplicados} componentes duplicados foram ignorados."
            if lubrificantes_criados > 0:
                mensagem_sucesso += f" {lubrificantes_criados} lubrificantes foram criados automaticamente."
            
            return num_inseridos, num_duplicados, lubrificantes_criados, mensagem_sucesso
            
    except Exception as e:
        return 0, 0, 0, f"Erro ao importar componentes: {e}"

def movimentar_lubrificante(id_lubrificante, tipo, quantidade, data, cod_equip=None, observacoes=""):
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO lubrificantes_movimentacoes (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                (id_lubrificante, tipo, quantidade, data, cod_equip, observacoes)
            )
            # Atualiza estoque
            sinal = 1 if tipo == "entrada" else -1
            cur.execute(
                "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque + ? WHERE id = ?",
                (sinal * quantidade, id_lubrificante)
            )
            conn.commit()
        return True, "Movimenta√ß√£o registrada!"
    except Exception as e:
        return False, f"Erro: {e}"

@st.cache_data(ttl=120)
def filtrar_dados(df: pd.DataFrame, opts: dict) -> pd.DataFrame:
    # Garante que a coluna de data √© do tipo datetime
    df['Data'] = pd.to_datetime(df['Data'])
    
    # Filtra por per√≠odo de datas
    df_filtrado = df[
        (df['Data'].dt.date >= opts['data_inicio']) & 
        (df['Data'].dt.date <= opts['data_fim'])
    ]
    
    # Filtra pelas outras sele√ß√µes, se existirem
    if opts.get("classes_op"):
        df_filtrado = df_filtrado[df_filtrado["Classe_Operacional"].isin(opts["classes_op"])]
    
    if opts.get("safras"):
        df_filtrado = df_filtrado[df_filtrado["Safra"].isin(opts["safras"])]
        
    return df_filtrado.copy()

@st.cache_data(show_spinner="Calculando plano de manuten√ß√£o...", ttl=300)
def build_component_maintenance_plan(_df_frotas: pd.DataFrame, _df_abastecimentos: pd.DataFrame, _df_componentes_regras: pd.DataFrame, _df_componentes_historico: pd.DataFrame) -> pd.DataFrame:
    latest_readings = _df_abastecimentos.sort_values('Data').groupby('Cod_Equip')['Hod_Hor_Atual'].last()
    plan_data = []

    for _, frota_row in _df_frotas.iterrows():
        cod_equip = frota_row['Cod_Equip']
        classe_op = frota_row.get('Classe_Operacional')
        hod_hor_atual = latest_readings.get(cod_equip)

        if pd.isna(hod_hor_atual) or not classe_op:
            continue
        
        regras_da_classe = _df_componentes_regras[_df_componentes_regras['classe_operacional'] == classe_op]
        if regras_da_classe.empty:
            continue

        unidade = 'km' if frota_row['Tipo_Controle'] == 'QUIL√îMETROS' else 'h'
        alerta_default = ALERTAS_MANUTENCAO.get(frota_row['Tipo_Controle'], {}).get('default', 500)
        
        record = {
            'Cod_Equip': cod_equip, 
            'Equipamento': frota_row.get('DESCRICAO_EQUIPAMENTO'), 
            'Leitura_Atual': hod_hor_atual, 
            'Unidade': unidade, 
            'Qualquer_Alerta': False, 
            'Alertas': []
        }

        for _, regra in regras_da_classe.iterrows():
            componente = regra['nome_componente']
            intervalo = regra['intervalo_padrao']
            
            historico_componente = _df_componentes_historico[
                (_df_componentes_historico['Cod_Equip'] == cod_equip) &
                (_df_componentes_historico['nome_componente'] == componente)
            ]
            
            ultimo_servico_hod_hor = 0
            if not historico_componente.empty:
                ultimo_servico_hod_hor = historico_componente['Hod_Hor_No_Servico'].max()

            prox_servico = ((ultimo_servico_hod_hor // intervalo) * intervalo) + intervalo
            while prox_servico < hod_hor_atual:
                prox_servico += intervalo

            restante = prox_servico - hod_hor_atual
            
            record[f'Restante_{componente}'] = restante
            
            if restante <= alerta_default:
                record['Qualquer_Alerta'] = True
                record['Alertas'].append(componente)

        plan_data.append(record)

    # üîπ Garante que sempre retorna um DataFrame com as colunas b√°sicas
    if not plan_data:
        return pd.DataFrame(columns=['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Qualquer_Alerta', 'Alertas'])

    return pd.DataFrame(plan_data)

def prever_manutencoes(df_veiculos: pd.DataFrame, df_abastecimentos: pd.DataFrame, plan_df: pd.DataFrame) -> pd.DataFrame:
    """Estima as datas das pr√≥ximas manuten√ß√µes com base no uso m√©dio."""
    if plan_df.empty or 'Leitura_Atual' not in plan_df.columns:
        return pd.DataFrame()

    # Calcula o uso di√°rio m√©dio de cada ve√≠culo
    uso_diario = {}
    for cod_equip in df_abastecimentos['Cod_Equip'].unique():
        dados_equip = df_abastecimentos[df_abastecimentos['Cod_Equip'] == cod_equip].sort_values('Data')
        if len(dados_equip) > 1:
            total_dias = (dados_equip['Data'].max() - dados_equip['Data'].min()).days
            total_uso = dados_equip['Hod_Hor_Atual'].max() - dados_equip['Hod_Hor_Atual'].min()
            if total_dias > 0 and total_uso > 0: # Garante que houve uso e passagem de tempo
                uso_diario[cod_equip] = total_uso / total_dias

    previsoes = []
    servicos_nomes = [col.replace('Restante_', '') for col in plan_df.columns if 'Restante_' in col]

    for _, row in plan_df.iterrows():
        cod_equip = row['Cod_Equip']
        uso = uso_diario.get(cod_equip)
        if uso:
            for nome_servico in servicos_nomes:
                col_restante = f'Restante_{nome_servico}'
                if col_restante in row and pd.notna(row[col_restante]):
                    dias_para_manut = row[col_restante] / uso
                    data_prevista = datetime.now() + pd.Timedelta(days=dias_para_manut)
                    previsoes.append({
                        'Equipamento': row['Equipamento'],
                        'Manuten√ß√£o': nome_servico,
                        'Data Prevista': data_prevista.strftime('%d/%m/%Y'),
                        'Dias Restantes': int(dias_para_manut)
                    })

    if not previsoes:
        return pd.DataFrame()

    df_previsoes = pd.DataFrame(previsoes)
    return df_previsoes.sort_values('Dias Restantes')

# ---------------------------
# Fun√ß√µes para Checklists
# ---------------------------

@st.cache_data(ttl=120)
def get_checklist_rules():
    """Busca todas as regras de checklist do banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query("SELECT * FROM checklist_regras", conn)
    except Exception as e:
        st.error(f"Erro ao buscar regras de checklist: {e}")
        return pd.DataFrame()

@st.cache_data(ttl=120)
def get_checklist_items(id_regra):
    """Busca os itens de checklist para uma determinada regra."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            return pd.read_sql_query(
                "SELECT * FROM checklist_itens WHERE id_regra = ?",
                conn,
                params=(id_regra,)
            )
    except Exception as e:
        st.error(f"Erro ao buscar itens de checklist: {e}")
        return pd.DataFrame()

# ---------------------------
# CRUD para Checklists
# ---------------------------

def add_checklist_rule(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra de checklist ao banco de dados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
        return True, "Regra de checklist adicionada com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar regra de checklist: {e}"

def add_checklist_rule_and_get_id(classe_operacional, titulo_checklist, turno, frequencia):
    """Adiciona uma nova regra e devolve o ID criado (ou None em erro).

    Mant√©m a fun√ß√£o "add_checklist_rule" para compatibilidade, mas quando for
    necess√°rio o ID imediatamente ap√≥s a cria√ß√£o, utilize esta fun√ß√£o.
    """
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_regras (classe_operacional, titulo_checklist, frequencia, turno)
                VALUES (?, ?, ?, ?)
                """,
                (classe_operacional, titulo_checklist, frequencia, turno)
            )
            conn.commit()
            return cursor.lastrowid
    except Exception as e:
        st.error(f"Erro ao adicionar regra de checklist: {e}")
        return None

def edit_checklist_rule(id_regra, classe_operacional, titulo_checklist, turno, frequencia):
    """Edita uma regra de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_regras
                SET classe_operacional = ?, titulo_checklist = ?, frequencia = ?, turno = ?
                WHERE id_regra = ?
                """ ,
                (classe_operacional, titulo_checklist, frequencia, turno, id_regra)
            )
            conn.commit()
        return True, "Regra de checklist atualizada com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar regra de checklist: {e}"

def delete_checklist_rule(id_regra):
    """Remove uma regra de checklist e seus itens associados."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_regra = ?", (id_regra,))
            cursor.execute("DELETE FROM checklist_regras WHERE id_regra = ?", (id_regra,))
            conn.commit()
        return True, "Regra de checklist removida com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover regra de checklist: {e}"

def add_checklist_item(id_regra, nome_item):
    """Adiciona um novo item de checklist a uma regra existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_itens (id_regra, nome_item)
                VALUES (?, ?)
                """ ,
                (id_regra, nome_item)
            )
            conn.commit()
        return True, "Item de checklist adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao adicionar item de checklist: {e}"

def edit_checklist_item(id_item, nome_item):
    """Edita um item de checklist existente."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                UPDATE checklist_itens
                SET nome_item = ?
                WHERE id_item = ?
                """ ,
                (nome_item, id_item)
            )
            conn.commit()
        return True, "Item de checklist atualizado com sucesso!"
    except Exception as e:
        return False, f"Erro ao editar item de checklist: {e}"

def delete_checklist_item(id_item):
    """Remove um item de checklist."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM checklist_itens WHERE id_item = ?", (id_item,))
            conn.commit()
        return True, "Item de checklist removido com sucesso!"
    except Exception as e:
        return False, f"Erro ao remover item de checklist: {e}"

def save_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno, status_geral):
    """Salva um checklist preenchido no hist√≥rico."""
    try:
        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO checklist_historico 
                (Cod_Equip, titulo_checklist, data_preenchimento, turno, status_geral) 
                VALUES (?, ?, ?, ?, ?)
                """ ,
                (cod_equip, titulo_checklist, data_preenchimento, turno, status_geral)
            )
            conn.commit()
    except Exception as e:
        st.error(f"Erro ao salvar hist√≥rico de checklist: {e}")

def delete_checklist_history(cod_equip, titulo_checklist, data_preenchimento, turno):
    """Remove um registro do hist√≥rico de checklists usando uma combina√ß√£o √∫nica de campos."""
    try:
        # Primeira tentativa: usar conex√£o direta
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # Converter tipos de dados para garantir compatibilidade
        cod_equip = int(cod_equip)  # Converter numpy.int64 para int
        titulo_checklist = str(titulo_checklist)
        data_preenchimento = str(data_preenchimento)
        turno = str(turno)
        
        # Debug: verificar todos os registros na tabela ANTES da exclus√£o
        cursor.execute("SELECT rowid, Cod_Equip, titulo_checklist, data_preenchimento, turno FROM checklist_historico")
        all_records_before = cursor.fetchall()
        
        # Tentar encontrar o registro com diferentes abordagens
        rowid = None
        
        # Primeira tentativa: busca exata
        cursor.execute(
            "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
            (cod_equip, titulo_checklist, data_preenchimento, turno)
        )
        result = cursor.fetchone()
        
        if result:
            rowid = result[0]
        else:
            # Segunda tentativa: buscar apenas por Cod_Equip, t√≠tulo e turno (ignorar data)
            cursor.execute(
                "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND turno = ?", 
                (cod_equip, titulo_checklist, turno)
            )
            result = cursor.fetchone()
            
            if result:
                rowid = result[0]
            else:
                # Terceira tentativa: buscar apenas por Cod_Equip e t√≠tulo
                cursor.execute(
                    "SELECT rowid FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ?", 
                    (cod_equip, titulo_checklist)
                )
                result = cursor.fetchone()
                
                if result:
                    rowid = result[0]
        
        if rowid is None:
            # Debug: retornar informa√ß√µes sobre o que foi encontrado
            debug_info = f"""
            Registro n√£o encontrado para exclus√£o.
            
            Valores procurados (ap√≥s convers√£o):
            - Cod_Equip: {cod_equip} (tipo: {type(cod_equip)})
            - T√≠tulo: {titulo_checklist} (tipo: {type(titulo_checklist)})
            - Data: {data_preenchimento} (tipo: {type(data_preenchimento)})
            - Turno: {turno} (tipo: {type(turno)})
            
            Todos os registros na tabela ANTES da exclus√£o:
            {all_records_before}
            """
            conn.close()
            return False, debug_info
        
        # Agora vamos excluir usando rowid
        cursor.execute("DELETE FROM checklist_historico WHERE rowid = ?", (rowid,))
        
        # For√ßar commit imediato
        conn.commit()
        
        # Verificar se foi realmente exclu√≠do
        rows_deleted = cursor.rowcount
        if rows_deleted > 0:
            # Verificar novamente se o registro foi realmente exclu√≠do
            cursor.execute("SELECT COUNT(*) FROM checklist_historico WHERE rowid = ?", (rowid,))
            count_after = cursor.fetchone()[0]
            
            # Verificar tamb√©m se o registro ainda existe pelos outros campos
            cursor.execute(
                "SELECT COUNT(*) FROM checklist_historico WHERE Cod_Equip = ? AND titulo_checklist = ? AND data_preenchimento = ? AND turno = ?", 
                (cod_equip, titulo_checklist, data_preenchimento, turno)
            )
            count_by_fields = cursor.fetchone()[0]
            
            if count_after == 0 and count_by_fields == 0:
                 # Verificar o total de registros na tabela
                 cursor.execute("SELECT COUNT(*) FROM checklist_historico")
                 total_after = cursor.fetchone()[0]
                 
                 # For√ßar sincroniza√ß√£o do banco
                 cursor.execute("PRAGMA wal_checkpoint(FULL)")
                 cursor.execute("PRAGMA synchronous=FULL")
                 conn.commit()
                 
                 success_msg = f"Checklist exclu√≠do com sucesso! ({rows_deleted} registro(s) removido(s)). Total na tabela: {total_after}"
                 
                 # Salvar backup autom√°tico para persist√™ncia no Streamlit Cloud
                 backup_success, backup_msg = save_backup_to_session_state()
                 if backup_success:
                     success_msg += f" | Backup salvo: {backup_msg}"
                 else:
                     success_msg += f" | Aviso: {backup_msg}"
                 
                 conn.close()
                 return True, success_msg
            else:
                conn.close()
                return False, f"Erro: Registro ainda existe ap√≥s exclus√£o. Count by rowid: {count_after}, Count by fields: {count_by_fields}"
        else:
            conn.close()
            return False, "Nenhum registro foi exclu√≠do"
                
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return False, f"Erro ao excluir checklist: {e}"

def force_cache_clear():
    """For√ßa a limpeza completa de todos os caches."""
    try:
        # Limpar cache de dados
        st.cache_data.clear()
        
        # Limpar cache de recursos
        st.cache_resource.clear()
        
        # For√ßar rerun da aplica√ß√£o
        st.rerun()
    except Exception as e:
        st.error(f"Erro ao limpar cache: {e}")

def force_database_sync():
    """For√ßa a sincroniza√ß√£o do banco de dados com o disco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        # For√ßar commit
        conn.commit()
        
        # Executar PRAGMA para for√ßar sincroniza√ß√£o
        cursor.execute("PRAGMA wal_checkpoint(FULL)")
        cursor.execute("PRAGMA synchronous=FULL")
        cursor.execute("PRAGMA journal_mode=DELETE")
        
        # For√ßar commit novamente
        conn.commit()
        
        # Verificar se o banco est√° em modo WAL
        cursor.execute("PRAGMA journal_mode")
        journal_mode = cursor.fetchone()[0]
        
        conn.close()
        
        return True, f"Banco sincronizado. Modo journal: {journal_mode}"
    except Exception as e:
        return False, f"Erro ao sincronizar banco: {e}"

def export_database_backup():
    """Exporta todos os dados do banco para um arquivo de backup."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        
        # Obter todas as tabelas
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        
        backup_data = {}
        
        for table in tables:
            table_name = table[0]
            if table_name != 'sqlite_master':
                # Exportar dados da tabela
                df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
                backup_data[table_name] = df.to_dict('records')
        
        conn.close()
        
        # Converter para JSON
        backup_json = json.dumps(backup_data, default=str, indent=2)
        
        # Criar arquivo de download
        backup_bytes = backup_json.encode('utf-8')
        backup_b64 = base64.b64encode(backup_bytes).decode()
        
        return backup_b64, backup_data
        
    except Exception as e:
        return None, f"Erro ao exportar backup: {e}"

def import_database_backup(backup_data):
    """Importa dados de backup para o banco."""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cursor = conn.cursor()
        
        for table_name, records in backup_data.items():
            if records:  # Se a tabela tem dados
                # Limpar tabela existente
                cursor.execute(f"DELETE FROM {table_name}")
                
                # Inserir novos dados
                for record in records:
                    columns = list(record.keys())
                    placeholders = ', '.join(['?' for _ in columns])
                    values = list(record.values())
                    
                    # Converter tipos de dados
                    converted_values = []
                    for value in values:
                        if isinstance(value, str):
                            # Tentar converter para datetime se for uma data
                            try:
                                if 'T' in value or '-' in value:
                                    dt = pd.to_datetime(value)
                                    converted_values.append(dt.strftime('%Y-%m-%d %H:%M:%S'))
                                else:
                                    converted_values.append(value)
                            except:
                                converted_values.append(value)
                        else:
                            converted_values.append(value)
                    
                    cursor.execute(
                        f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})",
                        converted_values
                    )
        
        conn.commit()
        conn.close()
        
        return True, "Backup restaurado com sucesso!"
        
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def save_backup_to_session_state():
    """Salva backup dos dados na sess√£o do Streamlit."""
    try:
        backup_b64, backup_data = export_database_backup()
        if backup_b64:
            st.session_state['database_backup'] = backup_b64
            st.session_state['backup_timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return True, "Backup salvo na sess√£o"
        else:
            return False, "Erro ao criar backup"
    except Exception as e:
        return False, f"Erro ao salvar backup: {e}"

def restore_backup_from_session_state():
    """Restaura backup dos dados da sess√£o do Streamlit."""
    try:
        if 'database_backup' in st.session_state:
            backup_b64 = st.session_state['database_backup']
            backup_bytes = base64.b64decode(backup_b64)
            backup_json = backup_bytes.decode('utf-8')
            backup_data = json.loads(backup_json)
            
            success, message = import_database_backup(backup_data)
            if success:
                # Limpar cache para for√ßar recarregamento
                force_cache_clear()
                return True, message
            else:
                return False, message
        else:
            return False, "Nenhum backup encontrado na sess√£o"
    except Exception as e:
        return False, f"Erro ao restaurar backup: {e}"

def auto_restore_backup_on_startup():
    """Tenta restaurar backup automaticamente na inicializa√ß√£o da aplica√ß√£o."""
    try:
        if 'database_backup' in st.session_state:
            # Verificar se o banco est√° vazio
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
            num_tables = cursor.fetchone()[0]
            conn.close()
            
            if num_tables == 0:
                # Banco vazio, tentar restaurar
                success, message = restore_backup_from_session_state()
                if success:
                    st.info("üîÑ Backup restaurado automaticamente na inicializa√ß√£o!")
                    return True
                else:
                    st.warning(f"‚ö†Ô∏è Falha na restaura√ß√£o autom√°tica: {message}")
                    return False
        return False
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na restaura√ß√£o autom√°tica: {e}")
        return False

def main():
    
    # Garante tema dark coerente mesmo sem config.toml
    st.markdown(
        """
        <style>
        :root {
            --primary: #10b981;
            --bg: #0f172a;
            --bg2: #111827;
            --text: #e5e7eb;
        }
        body { background: var(--bg); color: var(--text); }
        section.main > div { background: var(--bg); }
        .stApp { background: var(--bg); }
        .st-emotion-cache-1r4qj8v, .st-emotion-cache-13ln4jf { background: var(--bg2) !important; }
        .stButton>button { background: var(--primary); color: #062e24; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    # CSS fino para polir a UI
    st.markdown(
        """
        <style>
        /* Cart√µes/containers */
        .stExpander, .stDataFrame, .stTable { border-radius: 10px !important; }
        .stButton>button { border-radius: 8px; padding: 0.5rem 1rem; }
        .stSelectbox, .stTextInput, .stNumberInput, .stDateInput, .stTextArea { border-radius: 8px !important; }
        /* M√©tricas com mais destaque */
        div[data-testid="stMetric"] { background: rgba(255,255,255,0.04); padding: 10px 14px; border-radius: 12px; }
        /* T√≠tulos com leve gradiente */
        h1, h2, h3 { background: linear-gradient(90deg, #10b981 0%, #06b6d4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        /* Linhas divis√≥rias mais suaves */
        hr { border: none; height: 1px; background: rgba(255,255,255,0.08); }
        /* Subt√≠tulo de marca (opcional) */
        .brand-subtitle { display: none; }
        /* Centralizar e limitar logo na sidebar */
        section[data-testid="stSidebar"] img { display: block; margin: 0.5rem auto 0.75rem; max-width: 140px; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
        st.session_state.role = None
        st.session_state.username = ""

    if not st.session_state.authenticated:
        _ , col_central, _ = st.columns([1, 1.5, 1])
    
        with col_central:
            
            if os.path.exists("logo.png"):
                # Cria 3 sub-colunas dentro da coluna central
                _, logo_col, _ = st.columns([1, 2, 1])
                with logo_col:
                    st.image("logo.png", width=140)
            
            st.title("Bem vindo ao Aplicativo de Controle do PCMA")

            username = st.text_input("Usu√°rio", key="login_user")
            password = st.text_input("Senha", type="password", key="login_pass")

            if st.button("Entrar", use_container_width=True):
                role = check_login_db(username, password)
                if role:
                    st.session_state.authenticated = True
                    st.session_state.role = role
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("Usu√°rio ou Senha incorretos.")
    else:

        # Cabe√ßalho com logo + t√≠tulo
        if os.path.exists("logo.png"):
            col_logo, col_title = st.columns([1, 8])
            with col_logo:
                st.image("logo.png", width=80)
            with col_title:
                st.title("üìä Dashboard de Frotas e Abastecimentos")
        else:
            st.title("üìä Dashboard de Frotas e Abastecimentos")

        # Tentar restaurar backup automaticamente na inicializa√ß√£o
        auto_restore_backup_on_startup()
        
        # Adicionar coluna de tipo de combust√≠vel se n√£o existir
        add_tipo_combustivel_column()
        
        # Setup de esquemas (motoristas, pre√ßos, combust√≠vel)
        ensure_motoristas_schema()
        ensure_precos_combustivel_schema()

        # Passo um fingerprint simples das tabelas para invalidar cache quando necess√°rio
        ver_frotas = int(os.path.getmtime(DB_PATH)) if os.path.exists(DB_PATH) else 0
        df, df_frotas, df_manutencoes, df_comp_regras, df_comp_historico, df_checklist_regras, df_checklist_itens, df_checklist_historico = load_data_from_db(DB_PATH, ver_frotas, ver_frotas, ver_frotas, ver_frotas, ver_frotas)
        

        if 'intervalos_por_classe' not in st.session_state:
            st.session_state.intervalos_por_classe = {}
        classes_operacionais = [c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()]
        for classe in classes_operacionais:
            if classe not in st.session_state.intervalos_por_classe:
                tipo_controle = df_frotas[df_frotas['Classe_Operacional'] == classe]['Tipo_Controle'].iloc[0]
                if tipo_controle == 'HORAS':
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 5.0,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 250},
                            'servico_2': {'nome': 'Revisao A', 'intervalo': 100},
                            'servico_3': {'nome': 'Revisao B', 'intervalo': 300},
                            'servico_4': {'nome': 'Revisao C', 'intervalo': 500}
                        }
                    }
                else: # QUIL√îMETROS
                    st.session_state.intervalos_por_classe[classe] = {
                        'meta_consumo': 2.5,
                        'servicos': {
                            'servico_1': {'nome': 'Lubrificacao', 'intervalo': 5000},
                            'servico_2': {'nome': 'Revisao 5k', 'intervalo': 5000},
                            'servico_3': {'nome': 'Revisao 10k', 'intervalo': 10000},
                            'servico_4': {'nome': 'Revisao 20k', 'intervalo': 20000}
                        }
                    }
                    
        with st.sidebar:
            if os.path.exists("logo.png"):
                st.image("logo.png", width=200)
            st.write(f"Bem-vindo, **{st.session_state.username}**!")
            if st.button("Sair"):
                st.session_state.authenticated = False
                st.session_state.username = "" # Limpa o username ao sair
                st.session_state.role = None
                st.rerun()
            st.markdown("---")

        with st.sidebar:
            st.header("üìÖ Filtros (v√°lidos apenas na aba An√°lise Geral)")

            # Persist√™ncia de per√≠odo
            if 'filtro_data_inicio' not in st.session_state:
                st.session_state['filtro_data_inicio'] = df['Data'].min().date()
            if 'filtro_data_fim' not in st.session_state:
                st.session_state['filtro_data_fim'] = df['Data'].max().date()

            st.subheader("Per√≠odo de An√°lise")
            data_inicio = st.date_input(
                "Data de In√≠cio", 
                st.session_state['filtro_data_inicio'],
                key='data_inicio'
            )
            data_fim = st.date_input(
                "Data de Fim", 
                st.session_state['filtro_data_fim'],
                key='data_fim'
            )
            st.session_state['filtro_data_inicio'] = data_inicio
            st.session_state['filtro_data_fim'] = data_fim

            st.markdown("---")
            st.caption("Desenvolvido por Andr√© Luis")

            with st.expander("Filtrar por Classe Operacional"):
                classe_opts = sorted(list(df["Classe_Operacional"].dropna().unique()))
                sel_classes = st.multiselect(
                    "Selecione as Classes", 
                    classe_opts, 
                    default=classe_opts,
                    key="sel_classes"
                )

            with st.expander("Filtrar por Safra"):
                safra_opts = sorted(list(df["Safra"].dropna().unique()))
                sel_safras = st.multiselect(
                    "Selecione as Safras", 
                    safra_opts, 
                    default=safra_opts,
                    key="sel_safras"
                )

            # S√≥ aplicaremos os filtros na aba "üìà An√°lise Geral" (guardaremos em sess√£o)
            st.session_state['filtro_opts_analise'] = {
                "data_inicio": data_inicio,
                "data_fim": data_fim,
                "classes_op": sel_classes,
                "safras": sel_safras
            }
    #----------------------------------------------------- aba principal --------------------------------------
        # df_f ser√° calculado apenas para a aba An√°lise Geral
        df_f = None
        plan_df = build_component_maintenance_plan(df_frotas, df, df_comp_regras, df_comp_historico)

        # CSS para barra de rolagem horizontal nas abas com design moderno
        st.markdown("""
        <style>
        .stTabs [data-baseweb="tab-list"] {
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: #00D4AA #E8F5F2;
            padding: 8px 0;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar {
            height: 12px;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-track {
            background: linear-gradient(90deg, #F0F2F6 0%, #E8F5F2 100%);
            border-radius: 8px;
            border: 1px solid #E0E6ED;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #00D4AA 0%, #00B8A9 100%);
            border-radius: 8px;
            border: 1px solid #00A896;
            box-shadow: 0 2px 4px rgba(0,212,170,0.3);
            transition: all 0.3s ease;
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #00B8A9 0%, #00A896 100%);
            box-shadow: 0 3px 6px rgba(0,212,170,0.4);
            transform: translateY(-1px);
        }
        
        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar-thumb:active {
            background: linear-gradient(90deg, #00A896 0%, #009688 100%);
            box-shadow: 0 1px 3px rgba(0,212,170,0.5);
        }
        
        .stTabs [data-baseweb="tab-list"] > div {
            flex-shrink: 0;
            transition: all 0.2s ease;
        }
        
        /* Melhorar apar√™ncia das abas */
        .stTabs [data-baseweb="tab"] {
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .stTabs [data-baseweb="tab"]:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        /* Estilo para abas ativas */
        .stTabs [data-baseweb="tab"][aria-selected="true"] {
            background: linear-gradient(135deg, #00D4AA 0%, #00B8A9 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,212,170,0.3);
        }
        </style>
        """, unsafe_allow_html=True)
        
        # Defini√ß√£o dos grupos de abas
        abas_pagina_inicial = ["üìà An√°lise Geral", "üõ†Ô∏è Controle de Manuten√ß√£o", "üîé Consulta Individual", "‚úÖ Checklists Di√°rios"]
        abas_gerir = ["‚öôÔ∏è Gerir Lan√ßamentos", "üõ¢Ô∏è Gest√£o de Lubrificantes", "‚öôÔ∏è Gerir Frotas", "‚úÖ Gerir Checklists"]
        abas_dados = ["üì§ Importar Dados", "‚öïÔ∏è Sa√∫de dos Dados", "üíæ Backup", "üë§ Gerir Utilizadores", "‚öôÔ∏è Configura√ß√µes"]

        # Sistema de navega√ß√£o por grupos
        st.markdown("### üéØ Navega√ß√£o por Grupos")
        
        # Mostrar informa√ß√µes sobre os grupos dispon√≠veis
        if st.session_state.role == 'admin':
            st.info("""
            **üè† P√°gina Inicial:** Visualiza√ß√µes, an√°lises e consultas principais | 
            **‚öôÔ∏è Gerir:** Gest√£o de lan√ßamentos, frotas e checklists | 
            **üìä Dados:** Importa√ß√µes, backup e sa√∫de dos dados
            """)
        else:
            st.info("**üè† P√°gina Inicial:** Visualiza√ß√µes, an√°lises e consultas principais")
        
        # CSS para os bot√µes de grupo
        st.markdown("""
        <style>
        .group-nav-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102,126,234,0.3);
            margin: 4px;
            cursor: pointer;
        }
        
        .group-nav-button:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102,126,234,0.4);
        }
        
        .group-nav-button.active {
            background: linear-gradient(135deg, #00D4AA 0%, #00B8A9 100%);
            box-shadow: 0 4px 12px rgba(0,212,170,0.3);
        }
        
        .group-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 16px;
            margin: 8px 0;
            border: 1px solid #dee2e6;
        }
        </style>
        """, unsafe_allow_html=True)

        # Bot√µes de navega√ß√£o por grupos
        col1, col2, col3 = st.columns(3)
        
        # Determinar grupo ativo
        active_group = st.session_state.get('active_group', 'pagina_inicial').strip().lower()

        with col1:
            if st.button("üè† P√°gina Inicial", key="nav_pagina_inicial", help="Visualiza√ß√µes e an√°lises principais"):
                st.session_state['active_group'] = 'pagina_inicial'
                st.session_state['active_tab_index'] = 0
                st.rerun()
        
        if st.session_state.role == 'admin':
            with col2:
                if st.button("‚öôÔ∏è Gerir", key="nav_gerir", help="Gest√£o de lan√ßamentos, frotas e checklists"):
                    st.session_state['active_group'] = 'gerir'
                    st.session_state['active_tab_index'] = 0
                    st.rerun()
            
            with col3:
                if st.button("üìä Dados", key="nav_dados", help="Importa√ß√µes, backup e sa√∫de dos dados"):
                    st.session_state['active_group'] = 'dados'
                    st.session_state['active_tab_index'] = 0
                    st.rerun()

        # Determinar quais abas mostrar baseado no grupo ativo
        if st.session_state.role == 'admin':
            if active_group == 'pagina_inicial':
                tabs_para_mostrar = abas_pagina_inicial
            elif active_group == 'gerir':
                tabs_para_mostrar = abas_gerir
            elif active_group == 'dados':
                tabs_para_mostrar = abas_dados
            else:
                tabs_para_mostrar = abas_pagina_inicial
        else:
            # Para usu√°rios comuns, mostrar apenas p√°gina inicial
            tabs_para_mostrar = abas_pagina_inicial

        # Determinar √≠ndice ativo
        active_idx = st.session_state.get('active_tab_index', 0)
        active_idx = max(0, min(active_idx, len(tabs_para_mostrar) - 1))
        
        # Criar as abas
        try:
            abas = st.tabs(tabs_para_mostrar, default_index=active_idx)
        except TypeError:
            abas = st.tabs(tabs_para_mostrar)

        # Atribuir as abas baseado no grupo ativo
        if st.session_state.role == 'admin':
            if active_group == 'pagina_inicial':
                tab_analise, tab_manut, tab_consulta, tab_checklists = abas
                # Criar vari√°veis vazias para as outras abas
                tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
                tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None
            elif active_group == 'gerir':
                tab_gerir_lanc, tab_gerir_lub, tab_gerir_frotas, tab_gerir_checklists = abas
                # Criar vari√°veis vazias para as outras abas
                tab_analise = tab_manut = tab_consulta = tab_checklists = None
                tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None
            elif active_group == 'dados':
                tab_importar, tab_saude, tab_backup, tab_gerir_users, tab_config = abas
                # Criar vari√°veis vazias para as outras abas
                tab_analise = tab_manut = tab_consulta = tab_checklists = None
                tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
                

        else:
            tab_analise, tab_manut, tab_consulta, tab_checklists = abas
            # Criar vari√°veis vazias para as outras abas
            tab_gerir_lanc = tab_gerir_lub = tab_gerir_frotas = tab_gerir_checklists = None
            tab_importar = tab_saude = tab_backup = tab_gerir_users = tab_config = None

        def rerun_keep_tab(tab_title: str, clear_cache: bool = True):
            if clear_cache:
                st.cache_data.clear()
            try:
                st.session_state['active_tab_index'] = tabs_para_mostrar.index(tab_title)
            except Exception:
                pass
            st.rerun()
        

                
        if tab_analise is not None:
            with tab_analise:
                st.header("üìà An√°lise Gr√°fica de Consumo")

                # Aplica filtros apenas nesta aba
                opts = st.session_state.get('filtro_opts_analise', None)
                df_f = filtrar_dados(df, opts) if opts else df.copy()

                if not df_f.empty:
                    # KPIs melhorados com an√°lise por tipo de combust√≠vel
                    st.subheader("üìä Indicadores de Consumo por Combust√≠vel")
                    
                    # Obter tipos de combust√≠vel das frotas
                    if 'tipo_combustivel' in df_frotas.columns:
                        # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                        df_f_com_consumo = df_f[df_f['Qtde Litros'] > 0].copy()
                        
                        if not df_f_com_consumo.empty:
                            # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                            equipamentos_com_consumo = df_f_com_consumo['Cod_Equip'].unique()
                            
                            # Filtrar df_frotas para incluir apenas equipamentos com consumo
                            frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                            
                            # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                            if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                            
                            # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                            combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                            
                            # Aplicar o mapeamento apenas aos registros com consumo
                            df_f_com_consumo['tipo_combustivel'] = df_f_com_consumo['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                            
                            # Calcular consumo por tipo de combust√≠vel
                            consumo_por_combustivel = df_f_com_consumo.groupby('tipo_combustivel')['Qtde Litros'].sum().sort_values(ascending=False)
                        else:
                            # Se n√£o h√° registros com consumo, criar um DataFrame vazio
                            consumo_por_combustivel = pd.Series(dtype='float64')
                        
                        # Criar colunas din√¢micas baseadas no n√∫mero de tipos de combust√≠vel
                        num_tipos = len(consumo_por_combustivel)
                        if num_tipos <= 2:
                            cols = st.columns(2)
                        elif num_tipos <= 3:
                            cols = st.columns(3)
                        elif num_tipos <= 4:
                            cols = st.columns(4)
                        else:
                            cols = st.columns(5)
                        
                        # Exibir KPIs por tipo de combust√≠vel
                        for i, (tipo, litros) in enumerate(consumo_por_combustivel.items()):
                            if i < len(cols):
                                with cols[i]:
                                    # Calcular percentual do total
                                    percentual = (litros / df_f["Qtde Litros"].sum()) * 100
                                    
                                    # Definir cor baseada no tipo de combust√≠vel
                                    if 'Diesel S500' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Diesel S10' in tipo:
                                        delta_color = "normal"
                                        icon = "üöõ"
                                    elif 'Gasolina' in tipo:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    elif 'Etanol' in tipo:
                                        delta_color = "normal"
                                        icon = "üå±"
                                    elif 'Biodiesel' in tipo:
                                        delta_color = "normal"
                                        icon = "üåø"
                                    else:
                                        delta_color = "normal"
                                        icon = "‚õΩ"
                                    
                                    cols[i].metric(
                                        f"{icon} {tipo}",
                                        f"{formatar_brasileiro_int(litros)} L",
                                        f"{percentual:.1f}% do total",
                                        delta_color=delta_color
                                    )
                        
                        # Adicionar linha separadora
                        st.markdown("---")
                        
                        # KPI adicional: Total geral e m√©dia por equipamento
                        k1, k2, k3 = st.columns(3)
                        
                        with k1:
                            total_litros = df_f["Qtde Litros"].sum()
                            k1.metric(
                                "üõ¢Ô∏è Total Geral",
                                f"{formatar_brasileiro_int(total_litros)} L",
                                f"{len(consumo_por_combustivel)} tipos de combust√≠vel"
                            )
                        
                        with k2:
                            if 'Media' in df_f.columns:
                                media_geral = df_f['Media'].mean()
                                k2.metric(
                                    "üìà M√©dia Geral",
                                    f"{formatar_brasileiro(media_geral)}",
                                    "M√©dia de consumo por equipamento"
                                )
                            else:
                                # Calcular m√©dia manual se n√£o existir coluna Media
                                equipamentos_unicos = df_f['Cod_Equip'].nunique()
                                if equipamentos_unicos > 0:
                                    media_manual = total_litros / equipamentos_unicos
                                    k2.metric(
                                        "üìà M√©dia por Equipamento",
                                        f"{formatar_brasileiro(media_manual)} L",
                                        f"{equipamentos_unicos} equipamentos"
                                    )
                                else:
                                    k2.metric("üìà M√©dia por Equipamento", "N/A")
                        
                        with k3:
                            # Calcular efici√™ncia (litros por dia se houver dados de data)
                            if 'Data' in df_f.columns:
                                try:
                                    df_f['Data'] = pd.to_datetime(df_f['Data'])
                                    dias_periodo = (df_f['Data'].max() - df_f['Data'].min()).days + 1
                                    if dias_periodo > 0:
                                        litros_por_dia = total_litros / dias_periodo
                                        k3.metric(
                                            "üìÖ Consumo Di√°rio",
                                            f"{formatar_brasileiro(litros_por_dia)} L/dia",
                                            f"{dias_periodo} dias analisados"
                                        )
                                    else:
                                        k3.metric("üìÖ Consumo Di√°rio", "N/A")
                                except:
                                    k3.metric("üìÖ Consumo Di√°rio", "N/A")
                            else:
                                k3.metric("üìÖ Consumo Di√°rio", "N/A")
                    else:
                        # Fallback se n√£o houver coluna tipo_combustivel
                        k1, k2 = st.columns(2)
                        k1.metric("Litros Consumidos (per√≠odo)", formatar_brasileiro_int(df_f["Qtde Litros"].sum()))
                        if 'Media' in df_f.columns:
                            k2.metric("M√©dia Consumo (per√≠odo)", f"{formatar_brasileiro(df_f['Media'].mean())}")
                        else:
                            equipamentos_unicos = df_f['Cod_Equip'].nunique()
                            if equipamentos_unicos > 0:
                                media_manual = df_f["Qtde Litros"].sum() / equipamentos_unicos
                                k2.metric("M√©dia por Equipamento", f"{formatar_brasileiro(media_manual)} L")
                    st.markdown("---")
                    st.subheader("üìä An√°lise de Consumo por Classe e Equipamentos")
                    c1, c2 = st.columns(2)

                    with c1:
                        st.subheader("Consumo por Classe Operacional")
                        classes_a_excluir = ['VEICULOS LEVES', 'MOTOCICLETA', 'MINI CARREGADEIRA', 'USINA']
                        # Verificar se a coluna Classe_Operacional existe antes de filtrar
                        if 'Classe_Operacional' in df_f.columns:
                            df_consumo_classe = df_f[~df_f['Classe_Operacional'].str.upper().isin(classes_a_excluir)]
                        else:
                            df_consumo_classe = df_f
                        consumo_por_classe = df_consumo_classe.groupby("Classe_Operacional")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()

                        if not consumo_por_classe.empty:
                            consumo_por_classe['texto_formatado'] = consumo_por_classe['Qtde Litros'].apply(formatar_brasileiro_int)
                            fig_classe = px.bar(consumo_por_classe, x='Qtde Litros', y='Classe_Operacional', orientation='h', text='texto_formatado', labels={"x": "Litros Consumidos", "y": "Classe Operacional"})
                            fig_classe.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_classe.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Classe Operacional",
                                height=500,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=12)
                            )
                            st.plotly_chart(fig_classe, use_container_width=True)

                    with c2:
                        st.subheader("Top 10 Equipamentos com Maior Consumo")
                        # Melhorar o gr√°fico com informa√ß√µes mais claras
                        consumo_por_equip = df_f.groupby("Cod_Equip").agg({'Qtde Litros': 'sum'}).dropna()
                        consumo_por_equip = consumo_por_equip[consumo_por_equip.index != 550]
                        consumo_por_equip = consumo_por_equip.sort_values(by="Qtde Litros", ascending=False).head(10)

                        if not consumo_por_equip.empty:
                            # Adicionar informa√ß√µes da frota para melhor identifica√ß√£o
                            consumo_por_equip = consumo_por_equip.reset_index()
                            consumo_por_equip = consumo_por_equip.merge(
                                df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                                on='Cod_Equip', 
                                how='left'
                            )
                            
                            # Criar label mais informativo: C√≥digo - Descri√ß√£o (Placa)
                            consumo_por_equip['label_grafico'] = consumo_por_equip.apply(
                                lambda row: f"{row['Cod_Equip']} - {row['DESCRICAO_EQUIPAMENTO'][:30]}{'...' if len(str(row['DESCRICAO_EQUIPAMENTO'])) > 30 else ''} ({row['PLACA']})", 
                                axis=1
                            )
                            
                            consumo_por_equip['texto_formatado'] = consumo_por_equip['Qtde Litros'].apply(formatar_brasileiro_int)
                            
                            fig_top10 = px.bar(
                                consumo_por_equip, 
                                x='Qtde Litros', 
                                y='label_grafico', 
                                orientation='h', 
                                text='texto_formatado', 
                                labels={"Qtde Litros": "Total Consumido (Litros)", "label_grafico": "Equipamento"},
                                title="Top 10 Equipamentos com Maior Consumo"
                            )
                            fig_top10.update_traces(
                                texttemplate='%{text} L', 
                                textposition='outside',
                                marker_color='#ff7f0e',
                                textfont=dict(size=11, color='black'),
                                cliponaxis=False
                            )
                            fig_top10.update_layout(
                                yaxis={'categoryorder':'total ascending'}, 
                                xaxis_title="Total Consumido (Litros)", 
                                yaxis_title="Equipamento",
                                height=600,
                                margin=dict(l=20, r=20, t=40, b=20),
                                font=dict(size=11)
                            )
                            st.plotly_chart(fig_top10, use_container_width=True)

                    st.markdown("---")
                    
                    # NOVA SE√á√ÉO: Top 10 de Gastos por Frota e por Classe
                    st.subheader("üí∞ Top 10 de Gastos por Frota e Classe")
                    
                    # Calcular gastos por frota
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        df_gastos = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_gastos = df_gastos.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_gastos.columns:
                                df_gastos['tipo_combustivel'] = df_gastos['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_gastos['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_gastos.columns:
                            df_gastos['tipo_combustivel'] = 'Diesel S500'
                        
                        df_gastos['preco_unit'] = df_gastos['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_gastos['custo'] = df_gastos['Qtde Litros'].fillna(0.0) * df_gastos['preco_unit']
                        
                        # Adicionar informa√ß√µes da frota para filtro
                        df_gastos_com_info = df_gastos.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA', 'Classe_Operacional']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        
                        # Garantir que a coluna Classe_Operacional existe
                        if 'Classe_Operacional' not in df_gastos_com_info.columns:
                            df_gastos_com_info['Classe_Operacional'] = 'N/A'
                        
                        # Filtro para excluir a frota 550 (usina) por padr√£o
                        mostrar_usinas = st.checkbox("üè≠ Incluir Frota 550 (Usina) no Top 10 de Gastos por Frota", value=False)
                        
                        if not mostrar_usinas:
                            # Excluir a frota 550 (usina) do DataFrame
                            df_gastos_filtrado = df_gastos_com_info[df_gastos_com_info['Cod_Equip'] != 550]
                        else:
                            df_gastos_filtrado = df_gastos_com_info
                        
                        # Top 10 gastos por frota individual (ap√≥s filtro)
                        gastos_por_frota = df_gastos_filtrado.groupby('Cod_Equip').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        
                        # Adicionar informa√ß√µes da frota
                        gastos_por_frota = gastos_por_frota.merge(
                            df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'PLACA']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        gastos_por_frota['label_frota'] = gastos_por_frota['Cod_Equip'].astype(str)
                        gastos_por_frota['custo_formatado'] = gastos_por_frota['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Top 10 gastos por classe operacional
                        gastos_por_classe = df_gastos.groupby('Classe_Operacional').agg({
                            'custo': 'sum',
                            'Qtde Litros': 'sum'
                        }).sort_values('custo', ascending=False).head(10).reset_index()
                        gastos_por_classe['custo_formatado'] = gastos_por_classe['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                        
                        # Criar layout em 2 colunas para os gr√°ficos
                        col_gastos1, col_gastos2 = st.columns(2)
                        
                        with col_gastos1:
                            st.subheader("üè≠ Top 10 Gastos por Frota")
                            
                            # Mostrar informa√ß√£o sobre filtro da frota 550
                            # Coment√°rio removido para manter propor√ß√£o dos gr√°ficos
                            
                            if not gastos_por_frota.empty:
                                # Garantir que os dados est√£o corretos
                                gastos_por_frota['custo'] = gastos_por_frota['custo'].fillna(0)
                                gastos_por_frota = gastos_por_frota[gastos_por_frota['custo'] > 0]
                                
                                if not gastos_por_frota.empty:
                                    # Dados j√° validados e prontos para o gr√°fico
                                    
                                    # Garantir que label_frota √© string e √∫nico
                                    gastos_por_frota['label_frota'] = gastos_por_frota['label_frota'].astype(str)
                                    
                                    # Criar gr√°fico de barras horizontais com dados limpos
                                    fig_gastos_frota = px.bar(
                                        gastos_por_frota,
                                        x='custo',
                                        y='label_frota',
                                        orientation='h',
                                        text='custo_formatado',
                                        title="Gastos por Frota Individual",
                                        labels={'custo': 'Custo (R$)', 'label_frota': 'Frota'},
                                        color='custo',
                                        color_continuous_scale='Reds'
                                    )
                                    fig_gastos_frota.update_traces(
                                        textposition='outside',
                                        texttemplate='%{text}',
                                        textfont=dict(size=11, color='white'),
                                        cliponaxis=False,
                                        marker=dict(line=dict(width=1, color='black'))
                                    )
                                    fig_gastos_frota.update_layout(
                                        yaxis={'categoryorder':'total ascending'},
                                        xaxis_title="Custo Total (R$)",
                                        yaxis_title="Frota",
                                        height=600,
                                        showlegend=False,
                                        margin=dict(l=20, r=20, t=40, b=20),
                                        font=dict(size=12),
                                        bargap=0.3,
                                        bargroupgap=0.1
                                    )
                                    # Configurar eixo Y para mostrar todas as categorias
                                    fig_gastos_frota.update_yaxes(
                                        type='category',
                                        categoryorder='total ascending'
                                    )
                                    st.plotly_chart(fig_gastos_frota, use_container_width=True)
                                    
                                    # Gr√°fico criado com sucesso
                                else:
                                    st.warning("N√£o h√° frotas com gastos maiores que zero.")
                            else:
                                st.info("N√£o h√° dados de gastos por frota.")
                        
                        with col_gastos2:
                            st.subheader("üèóÔ∏è Top 10 Gastos por Classe")
                            if not gastos_por_classe.empty:
                                fig_gastos_classe = px.bar(
                                    gastos_por_classe,
                                    x='custo',
                                    y='Classe_Operacional',
                                    orientation='h',
                                    text='custo_formatado',
                                    title="Gastos por Classe Operacional",
                                    labels={'custo': 'Custo (R$)', 'Classe_Operacional': 'Classe'},
                                    color='custo',
                                    color_continuous_scale='Blues'
                                )
                                fig_gastos_classe.update_traces(
                                    textposition='outside',
                                    texttemplate='%{text}',
                                    textfont=dict(size=11, color='white'),
                                    cliponaxis=False,
                                    marker=dict(line=dict(width=1, color='black'))
                                )
                                fig_gastos_classe.update_layout(
                                    yaxis={'categoryorder':'total ascending'},
                                    xaxis_title="Custo Total (R$)",
                                    yaxis_title="Classe Operacional",
                                    height=600,
                                    showlegend=False,
                                    margin=dict(l=20, r=20, t=40, b=20),
                                    font=dict(size=12),
                                    bargap=0.3,
                                    bargroupgap=0.1
                                )
                                # Configurar eixo Y para mostrar todas as categorias
                                fig_gastos_classe.update_yaxes(
                                    type='category',
                                    categoryorder='total ascending'
                                )
                                st.plotly_chart(fig_gastos_classe, use_container_width=True)
                            else:
                                st.info("N√£o h√° dados de gastos por classe.")
                        
                        # Resumo dos totais
                        st.markdown("---")
                        col_resumo1, col_resumo2, col_resumo3 = st.columns(3)
                        with col_resumo1:
                            st.metric(
                                "Total Gastos (Per√≠odo)", 
                                formatar_brasileiro(df_gastos['custo'].sum(), 'R$ ')
                            )
                        with col_resumo2:
                            if not gastos_por_frota.empty:
                                frota_maior_gasto = gastos_por_frota.iloc[0]
                                st.metric(
                                    "Frota com Maior Gasto", 
                                    f"{frota_maior_gasto['Cod_Equip']}",
                                    f"{frota_maior_gasto['custo_formatado']}"
                                )
                            else:
                                st.metric("Frota com Maior Gasto", "N/A")
                        with col_resumo3:
                            st.metric(
                                "Classe com Maior Gasto", 
                                f"{gastos_por_classe.iloc[0]['Classe_Operacional'] if not gastos_por_classe.empty else 'N/A'}"
                            )
                    else:
                        st.warning("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos para visualizar os gastos.")

                    st.markdown("---")
                    st.subheader("üìà M√©dia de Consumo por Classe Operacional")
                    df_media = df_f[(df_f['Media'].notna()) & (df_f['Media'] > 0)].copy()

                    classes_para_excluir = ['MOTOCICLETA', 'VEICULOS LEVES', 'USINA', 'MINI CARREGADEIRA']

                    # Verificar se a coluna Classe_Operacional existe antes de filtrar
                    if 'Classe_Operacional' in df_media.columns:
                        df_media_filtrado = df_media[~df_media['Classe_Operacional'].str.upper().isin(classes_para_excluir)]
                    else:
                        df_media_filtrado = df_media

                    if not df_media_filtrado.empty: # Usa o novo DataFrame filtrado
                        media_por_classe = df_media_filtrado.groupby('Classe_Operacional')['Media'].mean().sort_values(ascending=True)
                        
                        df_media_grafico = media_por_classe.reset_index()
                        df_media_grafico['texto_formatado'] = df_media_grafico['Media'].apply(
                            lambda x: formatar_brasileiro(x)
                        )
                        
                        # Cria o gr√°fico de barras
                        fig_media_classe = px.bar(
                            df_media_grafico,
                            x='Media',
                            y='Classe_Operacional',
                            orientation='h',
                            title="M√©dia de Consumo (L/h ou Km/L) por Classe",
                            text='texto_formatado'
                        )
                        fig_media_classe.update_traces(
                            textposition='outside',
                            marker_color='#1f77b4'
                        )
                        fig_media_classe.update_layout(
                            yaxis_title="Classe Operacional",
                            xaxis_title="M√©dia de Consumo"
                        )
                        st.plotly_chart(fig_media_classe, use_container_width=True)
                    else:
                        st.info("N√£o h√° dados de consumo m√©dio para exibir com os filtros e exclus√µes aplicadas.")
                    
                    st.markdown("---")
                     
                    st.subheader("üèÜ Ranking de Efici√™ncia Inteligente")
                    
                    # Explica√ß√£o do ranking
                    with st.expander("‚ÑπÔ∏è Como interpretar o Ranking de Efici√™ncia"):
                        st.markdown("""
                        **üìä Como funciona:**
                        
                        **üéØ Com Metas Definidas:**
                        - **üü¢ Verde (+5%+):** Equipamento mais eficiente que a meta definida
                        - **‚ö™ Branco (-5% a +5%):** Efici√™ncia pr√≥xima √† meta definida
                        - **üî¥ Vermelho (-5%-):** Equipamento menos eficiente que a meta definida
                        
                        **üìà Sem Metas (Fallback):**
                        - **üü¢ Verde (+5%+):** Equipamento mais eficiente que a m√©dia da sua classe
                        - **‚ö™ Branco (-5% a +5%):** Efici√™ncia pr√≥xima √† m√©dia da classe  
                        - **üî¥ Vermelho (-5%-):** Equipamento menos eficiente que a m√©dia da sua classe
                        
                        **üí° Prioridade:** Meta Individual > Meta da Classe > M√©dia da Classe
                        **üéØ Objetivo:** Identificar equipamentos que atendem ou superam as metas de consumo definidas.
                        """)
                    
                    if 'Media' in df.columns and not df['Media'].dropna().empty:
                        media_por_classe = df.groupby('Classe_Operacional')['Media'].mean().to_dict()
                        ranking_df = df.copy()
                        ranking_df['Media_Classe'] = ranking_df['Classe_Operacional'].map(media_por_classe)
                            
                            # Calcular efici√™ncia considerando metas de consumo
                        def calcular_eficiencia_com_meta(row):
                                media_equip = row['Media']
                                media_classe = row['Media_Classe']
                                cod_equip = row['Cod_Equip']
                                classe = row['Classe_Operacional']
                                
                                # Verificar se h√° meta individual para esta frota
                                meta_individual = 0
                                if 'metas_individuals' in st.session_state:
                                    meta_individual = st.session_state.metas_individuals.get(cod_equip, {}).get('meta_consumo', 0)
                                
                                # Verificar meta da classe
                                meta_classe = 0
                                if 'intervalos_por_classe' in st.session_state:
                                    meta_classe = st.session_state.intervalos_por_classe.get(classe, {}).get('meta_consumo', 0)
                                
                                # Usar meta individual se existir e sobrescrever classe, sen√£o usar meta da classe
                                meta_final = meta_individual if meta_individual > 0 and st.session_state.metas_individuals.get(cod_equip, {}).get('sobrescrever_classe', False) else meta_classe
                                
                                # Se h√° meta definida, calcular efici√™ncia vs meta
                                if meta_final > 0:
                                    # Para L/h: menor √© melhor, para Km/L: maior √© melhor
                                    # Assumindo que o tipo de controle est√° em df_frotas
                                    tipo_controle = df_frotas[df_frotas['Cod_Equip'] == cod_equip]['Tipo_Controle'].iloc[0] if 'Tipo_Controle' in df_frotas.columns else 'QUIL√îMETROS'
                                    
                                    if tipo_controle == 'HORAS':  # L/h - menor √© melhor
                                        eficiencia_vs_meta = ((meta_final - media_equip) / meta_final) * 100
                                    else:  # Km/L - maior √© melhor
                                        eficiencia_vs_meta = ((media_equip - meta_final) / meta_final) * 100
                                    
                                    return eficiencia_vs_meta
                                else:
                                    # Se n√£o h√° meta, usar compara√ß√£o com m√©dia da classe
                                    return ((media_classe / media_equip) - 1) * 100
                            
                        ranking_df['Eficiencia_%'] = ranking_df.apply(calcular_eficiencia_com_meta, axis=1)
                        
                        ranking = ranking_df.groupby(['Cod_Equip', 'DESCRICAO_EQUIPAMENTO', 'Classe_Operacional'])['Eficiencia_%'].mean().sort_values(ascending=False).reset_index()
                        ranking.rename(columns={'DESCRICAO_EQUIPAMENTO': 'Equipamento', 'Eficiencia_%': 'Efici√™ncia (%)'}, inplace=True)
                        
                        # Adicionar informa√ß√µes da frota
                        ranking = ranking.merge(
                            df_frotas[['Cod_Equip', 'PLACA', 'ATIVO']], 
                            on='Cod_Equip', 
                            how='left'
                        )
                        
                        # Criar coluna combinada mais informativa
                        ranking['Equipamento_Completo'] = ranking.apply(
                            lambda row: f"{row['Cod_Equip']} - {row['Equipamento'][:25]}{'...' if len(str(row['Equipamento'])) > 25 else ''} ({row['PLACA']})", 
                            axis=1
                        )
                        
                        # Melhorar formata√ß√£o da efici√™ncia
                        def formatar_eficiencia_melhorada(val):
                            if pd.isna(val): return "N/A"
                            if val > 10: return f"üü¢ Excelente (+{val:+.1f}%)".replace('.',',')
                            elif val > 5: return f"üü¢ Bom (+{val:+.1f}%)".replace('.',',')
                            elif val > 0: return f"üü¢ Acima (+{val:+.1f}%)".replace('.',',')
                            elif val > -5: return f"‚ö™ M√©dia ({val:+.1f}%)".replace('.',',')
                            elif val > -10: return f"üü° Abaixo ({val:+.1f}%)".replace('.',',')
                            else: return f"üî¥ Cr√≠tico ({val:+.1f}%)".replace('.',',')
                        
                        ranking['Efici√™ncia_Formatada'] = ranking['Efici√™ncia (%)'].apply(formatar_eficiencia_melhorada)
                        
                        # Adicionar status do equipamento
                        ranking['Status'] = ranking['ATIVO'].apply(lambda x: "‚úÖ Ativo" if x == 'ATIVO' else "‚ùå Inativo")
                        
                        # Mostrar estat√≠sticas r√°pidas
                        col1, col2, col3, col4 = st.columns(4)
                        with col1:
                            excelentes = len(ranking[ranking['Efici√™ncia (%)'] > 10])
                            st.metric("üü¢ Excelentes", excelentes)
                        with col2:
                            bons = len(ranking[(ranking['Efici√™ncia (%)'] > 5) & (ranking['Efici√™ncia (%)'] <= 10)])
                            st.metric("üü¢ Bons", bons)
                        with col3:
                            criticos = len(ranking[ranking['Efici√™ncia (%)'] < -10])
                            st.metric("üî¥ Cr√≠ticos", criticos)
                        with col4:
                            total_analisados = len(ranking)
                            st.metric("üìä Total", total_analisados)
                        
                        # Filtros para o ranking
                        st.markdown("**üîç Filtros:**")
                        col_filtro1, col_filtro2, col_filtro3 = st.columns(3)
                        
                        with col_filtro1:
                            mostrar_inativos = st.checkbox("Mostrar Inativos", value=False)
                        with col_filtro2:
                            classe_filtro = st.selectbox(
                                "Filtrar por Classe",
                                ["Todas"] + sorted(ranking['Classe_Operacional'].unique().tolist())
                            )
                        with col_filtro3:
                            eficiencia_filtro = st.selectbox(
                                "Filtrar por Efici√™ncia",
                                ["Todas", "Excelentes (+10%+)", "Bons (+5%+)", "Acima da M√©dia", "M√©dia", "Abaixo da M√©dia", "Cr√≠ticos (-10%-)"]
                            )
                        
                        # Aplicar filtros
                        ranking_filtrado = ranking.copy()
                        
                        if not mostrar_inativos:
                            ranking_filtrado = ranking_filtrado[ranking_filtrado['ATIVO'] == 'ATIVO']
                        
                        if classe_filtro != "Todas":
                            ranking_filtrado = ranking_filtrado[ranking_filtrado['Classe_Operacional'] == classe_filtro]
                        
                        if eficiencia_filtro != "Todas":
                            if eficiencia_filtro == "Excelentes (+10%+)":
                                ranking_filtrado = ranking_filtrado[ranking_filtrado['Efici√™ncia (%)'] > 10]
                            elif eficiencia_filtro == "Bons (+5%+)":
                                ranking_filtrado = ranking_filtrado[ranking_filtrado['Efici√™ncia (%)'] > 5]
                            elif eficiencia_filtro == "Acima da M√©dia":
                                ranking_filtrado = ranking_filtrado[ranking_filtrado['Efici√™ncia (%)'] > 0]
                            elif eficiencia_filtro == "M√©dia":
                                ranking_filtrado = ranking_filtrado[(ranking_filtrado['Efici√™ncia (%)'] >= -5) & (ranking_filtrado['Efici√™ncia (%)'] <= 5)]
                            elif eficiencia_filtro == "Abaixo da M√©dia":
                                ranking_filtrado = ranking_filtrado[ranking_filtrado['Efici√™ncia (%)'] < 0]
                            elif eficiencia_filtro == "Cr√≠ticos (-10%-)":
                                ranking_filtrado = ranking_filtrado[ranking_filtrado['Efici√™ncia (%)'] < -10]
                        
                        # Exibir ranking com informa√ß√µes melhoradas
                        if not ranking_filtrado.empty:
                            # Criar gr√°fico de barras para visualiza√ß√£o
                            # Verificar se h√° metas definidas para ajustar o t√≠tulo
                            tem_metas = False
                            if 'intervalos_por_classe' in st.session_state or 'metas_individuals' in st.session_state:
                                tem_metas = (any(st.session_state.intervalos_por_classe.values()) if 'intervalos_por_classe' in st.session_state else False) or \
                                           (len(st.session_state.metas_individuals) > 0 if 'metas_individuals' in st.session_state else False)
                            
                            titulo_grafico = "Top 20 Equipamentos por Efici√™ncia vs Metas" if tem_metas else "Top 20 Equipamentos por Efici√™ncia vs M√©dia da Classe"
                            label_eixo_x = "Efici√™ncia vs Meta (%)" if tem_metas else "Efici√™ncia vs M√©dia da Classe (%)"
                            
                            fig_ranking = px.bar(
                                ranking_filtrado.head(20),
                                x='Efici√™ncia (%)',
                                y='Equipamento_Completo',
                                orientation='h',
                                color='Efici√™ncia (%)',
                                color_continuous_scale='RdYlGn',
                                title=titulo_grafico,
                                labels={'Efici√™ncia (%)': label_eixo_x, 'Equipamento_Completo': 'Equipamento'}
                            )
                            fig_ranking.update_layout(
                                yaxis={'categoryorder':'total ascending'},
                                height=600,
                                xaxis_title=label_eixo_x,
                                yaxis_title="Equipamento"
                            )
                            st.plotly_chart(fig_ranking, use_container_width=True)
                            
                            # Bot√£o de exporta√ß√£o
                            csv_ranking = para_csv(ranking_filtrado)
                            st.download_button(
                                "üì• Exportar Ranking Filtrado para CSV", 
                                csv_ranking, 
                                "ranking_eficiencia_filtrado.csv", 
                                "text/csv"
                            )
                        else:
                            st.warning("Nenhum equipamento encontrado com os filtros selecionados.")
                    else:
                        st.info("N√£o h√° dados de consumo m√©dio para gerar o ranking.")
                        
                st.markdown("---")
                st.subheader("üìà An√°lise de Tend√™ncias e Evolu√ß√£o")
                
                # ===== SE√á√ÉO: TEND√äNCIA DE CONSUMO MENSAAL MELHORADA =====
                st.markdown("**üìä Tend√™ncia de Consumo Mensal**")
                
                if not df.empty and 'Qtde Litros' in df.columns:
                    # Agrupa os dados por Ano/M√™s e soma o consumo
                    consumo_mensal = df.groupby('AnoMes')['Qtde Litros'].sum().reset_index().sort_values('AnoMes')
                    
                    if not consumo_mensal.empty:
                        # Calcular estat√≠sticas da tend√™ncia
                        consumo_atual = consumo_mensal['Qtde Litros'].iloc[-1] if len(consumo_mensal) > 0 else 0
                        consumo_anterior = consumo_mensal['Qtde Litros'].iloc[-2] if len(consumo_mensal) > 1 else 0
                        variacao = ((consumo_atual - consumo_anterior) / consumo_anterior * 100) if consumo_anterior > 0 else 0
                        
                        # Mostrar m√©tricas de tend√™ncia
                        col_tend1, col_tend2, col_tend3 = st.columns(3)
                        with col_tend1:
                            st.metric("üìà Consumo Atual", f"{formatar_brasileiro_int(consumo_atual)} L")
                        with col_tend2:
                            st.metric("üìä Consumo Anterior", f"{formatar_brasileiro_int(consumo_anterior)} L")
                        with col_tend3:
                            st.metric("üîÑ Varia√ß√£o", f"{variacao:+.1f}%".replace('.',','))
                        
                        # Gr√°fico de tend√™ncia melhorado
                        fig_tendencia = px.line(
                            consumo_mensal,
                            x='AnoMes',
                            y='Qtde Litros',
                            title="üìà Evolu√ß√£o do Consumo de Combust√≠vel",
                            labels={"AnoMes": "M√™s/Ano", "Qtde Litros": "Litros Consumidos"},
                            markers=True,
                            line_shape='linear'
                        )
                        fig_tendencia.update_layout(
                            xaxis_title="M√™s/Ano", 
                            yaxis_title="Litros Consumidos",
                            height=400,
                            showlegend=False
                        )
                        fig_tendencia.update_traces(
                            line=dict(width=3, color='#1f77b4'),
                            marker=dict(size=8, color='#1f77b4')
                        )
                        st.plotly_chart(fig_tendencia, use_container_width=True)
                        
                        # An√°lise de sazonalidade
                        if len(consumo_mensal) >= 12:  # Pelo menos 1 ano de dados
                            st.markdown("**üìÖ An√°lise de Sazonalidade:**")
                            # Calcular m√©dia por m√™s
                            consumo_mensal['Mes'] = consumo_mensal['AnoMes'].str[-2:] if 'AnoMes' in consumo_mensal.columns else '01'
                            sazonalidade = consumo_mensal.groupby('Mes')['Qtde Litros'].mean().reset_index()
                            sazonalidade['Mes_Nome'] = sazonalidade['Mes'].map({
                                '01': 'Jan', '02': 'Fev', '03': 'Mar', '04': 'Abr',
                                '05': 'Mai', '06': 'Jun', '07': 'Jul', '08': 'Ago',
                                '09': 'Set', '10': 'Out', '11': 'Nov', '12': 'Dez'
                            })
                            
                            fig_sazonalidade = px.bar(
                                sazonalidade,
                                x='Mes_Nome',
                                y='Qtde Litros',
                                title="üìÖ Consumo M√©dio por M√™s (Sazonalidade)",
                                labels={'Mes_Nome': 'M√™s', 'Qtde Litros': 'Litros M√©dios'},
                                color='Qtde Litros',
                                color_continuous_scale='Blues'
                            )
                            fig_sazonalidade.update_layout(height=300)
                            st.plotly_chart(fig_sazonalidade, use_container_width=True)
                    else:
                        st.info("N√£o h√° dados suficientes para gerar o gr√°fico de tend√™ncia com os filtros selecionados.")
                
                # ===== NOVA SE√á√ÉO: AN√ÅLISE DE EFICI√äNCIA TEMPORAL =====
                st.markdown("---")
                st.markdown("**üéØ An√°lise de Efici√™ncia Temporal**")
                
                if 'Media' in df.columns and not df['Media'].dropna().empty:
                    # An√°lise de efici√™ncia ao longo do tempo
                    df_eficiencia_tempo = df[df['Media'].notna()].copy()
                    df_eficiencia_tempo['AnoMes'] = df_eficiencia_tempo['AnoMes'] if 'AnoMes' in df_eficiencia_tempo.columns else '2024-01'
                    
                    eficiencia_temporal = df_eficiencia_tempo.groupby('AnoMes')['Media'].mean().reset_index()
                    
                    if not eficiencia_temporal.empty:
                        fig_eficiencia_tempo = px.line(
                            eficiencia_temporal,
                            x='AnoMes',
                            y='Media',
                            title="üìä Evolu√ß√£o da Efici√™ncia M√©dia da Frota",
                            labels={"AnoMes": "M√™s/Ano", "Media": "Efici√™ncia M√©dia (L/h ou km/L)"},
                            markers=True
                        )
                        fig_eficiencia_tempo.update_layout(
                            xaxis_title="M√™s/Ano", 
                            yaxis_title="Efici√™ncia M√©dia",
                            height=300
                        )
                        st.plotly_chart(fig_eficiencia_tempo, use_container_width=True)
                        
                        # Estat√≠sticas de efici√™ncia
                        eficiencia_atual = eficiencia_temporal['Media'].iloc[-1] if len(eficiencia_temporal) > 0 else 0
                        eficiencia_anterior = eficiencia_temporal['Media'].iloc[-2] if len(eficiencia_temporal) > 1 else 0
                        variacao_eficiencia = ((eficiencia_atual - eficiencia_anterior) / eficiencia_anterior * 100) if eficiencia_anterior > 0 else 0
                        
                        col_ef1, col_ef2, col_ef3 = st.columns(3)
                        with col_ef1:
                            st.metric("üéØ Efici√™ncia Atual", f"{formatar_brasileiro(eficiencia_atual)}")
                        with col_ef2:
                            st.metric("üìä Efici√™ncia Anterior", f"{formatar_brasileiro(eficiencia_anterior)}")
                        with col_ef3:
                            st.metric("üîÑ Varia√ß√£o", f"{variacao_eficiencia:+.1f}%".replace('.',','))
                    else:
                        st.info("N√£o h√° dados suficientes para an√°lise de efici√™ncia temporal.")
                else:
                    st.info("N√£o h√° dados de efici√™ncia para an√°lise temporal.")

                    st.markdown("---")
                    st.subheader("üí∞ Total de Gasto por Motorista")
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        # Vincula combust√≠vel por frota e multiplica litros por pre√ßo
                        df_tmp = df_f.copy()
                        
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_tmp = df_tmp.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_tmp.columns:
                                df_tmp['tipo_combustivel'] = df_tmp['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_tmp['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        # Garantir que a coluna tipo_combustivel existe antes de mapear pre√ßos
                        if 'tipo_combustivel' not in df_tmp.columns:
                            df_tmp['tipo_combustivel'] = 'Diesel S500'
                        
                        df_tmp['preco_unit'] = df_tmp['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_tmp['custo'] = df_tmp['Qtde Litros'].fillna(0.0) * df_tmp['preco_unit']
                        # Agrupar por matr√≠cula
                        if 'Matricula' in df_tmp.columns:
                            gasto_motorista = df_tmp.groupby('Matricula').agg({'custo':'sum', 'Qtde Litros':'sum'}).sort_values('custo', ascending=False)
                            gasto_motorista = gasto_motorista[gasto_motorista['custo']>0]
                            if not gasto_motorista.empty:
                                gasto_motorista = gasto_motorista.reset_index()
                                gasto_motorista['Custo (R$)'] = gasto_motorista['custo'].apply(lambda x: formatar_brasileiro(x, 'R$ '))
                                gasto_motorista['Litros'] = gasto_motorista['Qtde Litros'].apply(formatar_brasileiro_int)
                                st.dataframe(gasto_motorista[['Matricula','Litros','Custo (R$)']])
                                try:
                                    fig_gasto = px.bar(gasto_motorista.head(10), x='custo', y='Matricula', orientation='h', text='Custo (R$)', labels={'custo':'Custo (R$)','Matricula':'Matr√≠cula'})
                                    st.plotly_chart(fig_gasto, use_container_width=True)
                                except Exception:
                                    pass
                            else:
                                st.info("Sem dados suficientes de custo (verifique pre√ßos cadastrados).")
                        else:
                            st.info("N√£o h√° coluna de matr√≠cula nos abastecimentos para calcular o gasto por motorista.")
                    else:
                        st.info("Cadastre os pre√ßos de combust√≠vel na aba Importar > Pre√ßos.")

                    st.markdown("---")
                    st.subheader("üîÑ An√°lise de Propor√ß√µes por Classe e Combust√≠vel")
                
                # Criar DataFrame com informa√ß√µes de combust√≠vel
                df_consumo_combustivel = df.copy()
                
                # Verificar se a coluna tipo_combustivel existe em df_frotas
                if 'tipo_combustivel' in df_frotas.columns:
                    try:
                        # Renomear a coluna COD_EQUIPAMENTO para Cod_Equip em df_frotas
                        df_frotas_temp = df_frotas.copy()
                        df_frotas_temp = df_frotas_temp.rename(columns={"COD_EQUIPAMENTO": "Cod_Equip"}, errors='ignore')
                        
                        frotas_combustivel = df_frotas_temp[['Cod_Equip', 'tipo_combustivel']].copy()
                        frotas_combustivel['tipo_combustivel'] = frotas_combustivel['tipo_combustivel'].fillna('Diesel S500')
                        
                        # Renomear a coluna "C√≥d. Equip." para "Cod_Equip" em df_consumo_combustivel
                        df_consumo_combustivel = df_consumo_combustivel.rename(columns={"C√≥d. Equip.": "Cod_Equip"}, errors='ignore')
                        
                        df_consumo_combustivel = df_consumo_combustivel.merge(
                            frotas_combustivel, 
                            on='Cod_Equip', 
                            how='left'
                        )
                        # Verificar se a coluna foi criada ap√≥s o merge
                        if 'tipo_combustivel' not in df_consumo_combustivel.columns:
                            df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                    except Exception:
                        df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                else:
                    df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                
                # Garantir que a coluna tipo_combustivel existe
                if 'tipo_combustivel' not in df_consumo_combustivel.columns:
                    df_consumo_combustivel['tipo_combustivel'] = 'Diesel S500'
                
                col_grafico1, col_grafico2 = st.columns(2)
                
                with col_grafico1:
                    st.subheader("üìä Consumo por Classe (Vis√£o Macro)")
                    # Excluir "Usina" e frotas sem classe, usar Classe_Operacional
                    classes_a_excluir_macro = ['USINA', 'USINA MOBILE', 'USINA FIXA']
                    # Verificar se a coluna Classe_Operacional existe antes de filtrar
                    if 'Classe_Operacional' in df_consumo_combustivel.columns:
                        df_consumo_classe_macro = df_consumo_combustivel[
                            (df_consumo_combustivel['Classe_Operacional'].notna()) & 
                            (~df_consumo_combustivel['Classe_Operacional'].str.upper().isin(classes_a_excluir_macro))
                        ]
                    else:
                        df_consumo_classe_macro = df_consumo_combustivel
                    
                    if not df_consumo_classe_macro.empty:
                        try:
                            consumo_por_classe_macro = df_consumo_classe_macro.groupby("Classe_Operacional")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()
                            
                            # Criar gr√°fico de pizza
                            fig_pizza_classe = px.pie(
                                consumo_por_classe_macro, 
                                values='Qtde Litros', 
                                names='Classe_Operacional',
                                title="Propor√ß√£o de Consumo por Classe",
                                hole=0.3
                            )
                            fig_pizza_classe.update_traces(textposition='inside', textinfo='percent+label')
                            fig_pizza_classe.update_layout(height=400)
                            st.plotly_chart(fig_pizza_classe, use_container_width=True)
                            
                            # Mostrar totais
                            st.info(f"**Total de classes analisadas:** {len(consumo_por_classe_macro)}")
                            st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_classe_macro['Qtde Litros'].sum())} L")
                        except Exception as e:
                            st.error(f"Erro ao criar gr√°fico de classe: {e}")
                    else:
                        st.warning("N√£o h√° dados suficientes para an√°lise por classe.")
                
                with col_grafico2:
                    st.subheader("‚õΩ Consumo por Tipo de Combust√≠vel")
                    if not df_consumo_combustivel.empty:
                        try:
                            # Filtrar apenas registros que realmente t√™m consumo (Qtde Litros > 0)
                            df_consumo_real = df_consumo_combustivel[df_consumo_combustivel['Qtde Litros'] > 0].copy()
                            
                            if not df_consumo_real.empty:
                                # Obter tipos de combust√≠vel apenas das frotas que realmente abasteceram
                                if 'tipo_combustivel' in df_frotas.columns:
                                    # Pegar apenas os equipamentos que t√™m hist√≥rico de abastecimento
                                    equipamentos_com_consumo = df_consumo_real['Cod_Equip'].unique()
                                    
                                    # Filtrar df_frotas para incluir apenas equipamentos com consumo
                                    frotas_com_consumo = df_frotas[df_frotas['Cod_Equip'].isin(equipamentos_com_consumo)].copy()
                                    
                                    # Verificar se h√° valores duplicados em Cod_Equip e tratar adequadamente
                                    if frotas_com_consumo['Cod_Equip'].duplicated().any():
                                        # Se h√° duplicatas, pegar o primeiro valor de cada equipamento
                                        frotas_com_consumo = frotas_com_consumo.drop_duplicates(subset=['Cod_Equip'], keep='first')
                                    
                                    # Criar mapeamento de tipo de combust√≠vel apenas para equipamentos com consumo
                                    combustivel_map = frotas_com_consumo.set_index('Cod_Equip')['tipo_combustivel'].fillna('Diesel S500')
                                    
                                    # Aplicar o mapeamento apenas aos registros com consumo
                                    df_consumo_real['tipo_combustivel'] = df_consumo_real['Cod_Equip'].map(combustivel_map).fillna('Diesel S500')
                                else:
                                    df_consumo_real['tipo_combustivel'] = 'Diesel S500'
                                
                                # Agrupar por tipo de combust√≠vel
                                consumo_por_combustivel = df_consumo_real.groupby("tipo_combustivel")["Qtde Litros"].sum().sort_values(ascending=False).reset_index()
                                
                                if not consumo_por_combustivel.empty:
                                    # Criar gr√°fico de pizza
                                    fig_pizza_combustivel = px.pie(
                                        consumo_por_combustivel, 
                                        values='Qtde Litros', 
                                        names='tipo_combustivel',
                                        title="Propor√ß√£o de Consumo por Combust√≠vel (Apenas Frotas com Hist√≥rico)",
                                        hole=0.3
                                    )
                                    fig_pizza_combustivel.update_traces(textposition='inside', textinfo='percent+label')
                                    fig_pizza_combustivel.update_layout(height=400)
                                    st.plotly_chart(fig_pizza_combustivel, use_container_width=True)
                                    
                                    # Mostrar totais
                                    st.info(f"**Total de tipos de combust√≠vel:** {len(consumo_por_combustivel)}")
                                    st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                                    st.info(f"**Frotas com hist√≥rico de abastecimento:** {len(equipamentos_com_consumo)}")
                                else:
                                    st.warning("N√£o h√° dados de consumo para an√°lise por combust√≠vel.")
                            else:
                                st.warning("N√£o h√° registros com consumo de combust√≠vel.")
                        except Exception as e:
                            st.error(f"Erro ao criar gr√°fico de combust√≠vel: {e}")
                            st.info("Verificando dados dispon√≠veis...")
                            if 'tipo_combustivel' in df_consumo_combustivel.columns:
                                consumo_por_combustivel = df_consumo_combustivel.groupby("tipo_combustivel")["Qtde Litros"].sum().reset_index()
                                st.info(f"**Total de litros consumidos:** {formatar_brasileiro_int(consumo_por_combustivel['Qtde Litros'].sum())} L")
                            else:
                                st.error("Coluna tipo_combustivel n√£o encontrada")
                    else:
                        st.warning("N√£o h√° dados suficientes para an√°lise por combust√≠vel.")
                
                # Fechar as colunas anteriores e criar nova se√ß√£o com largura total
                st.markdown("---")
                st.subheader("üìä Demonstrativos Detalhados dos Pneus")

                df_pneus_all = get_pneus_historico()
                if not df_pneus_all.empty:
                    # Adicione colunas de status e vida se n√£o existirem
                    if 'status' not in df_pneus_all.columns:
                        df_pneus_all['status'] = 'Ativo'
                    if 'vida_atual' not in df_pneus_all.columns:
                        df_pneus_all['vida_atual'] = 1

                    total_pneus = len(df_pneus_all)
                    ativos = df_pneus_all[df_pneus_all['status'].str.lower() == 'ativo'].shape[0]
                    sucateados = df_pneus_all[df_pneus_all['status'].str.lower() == 'sucateado'].shape[0]
                    reformados = df_pneus_all[df_pneus_all['status'].str.lower() == 'reformado'].shape[0]
                    vidas = df_pneus_all['vida_atual'].value_counts().sort_index()
                    marcas = df_pneus_all['marca'].value_counts()
                    modelos = df_pneus_all['modelo'].value_counts()
                    posicoes = df_pneus_all['posicao'].value_counts()

                    col1, col2, col3, col4 = st.columns(4)
                    col1.metric("Total de Pneus", total_pneus)
                    col2.metric("Ativos", ativos)
                    col3.metric("Sucateados", sucateados)
                    col4.metric("Reformados", reformados)

                    # Gr√°ficos melhorados com r√≥tulos de dados
                    st.markdown("#### üìä Gr√°ficos de Distribui√ß√£o")
                    
                    # Criar DataFrame de status para o gr√°fico
                    status_df = df_pneus_all['status'].value_counts().reset_index()
                    status_df.columns = ["Status", "Quantidade"]
                    
                    # Gr√°fico de Status (Pizza)
                    fig_status = px.pie(status_df, names='Status', values='Quantidade', title='Status dos Pneus')
                    fig_status.update_traces(
                        textposition='inside',
                        textinfo='percent+label',
                        textfont=dict(size=12, color='white')
                    )
                    fig_status.update_layout(
                        height=400,
                        showlegend=True,
                        font=dict(size=12)
                    )
                    st.plotly_chart(fig_status, use_container_width=True)

                    # Gr√°fico de Marcas (Barras)
                    fig_marcas = px.bar(
                        marcas.reset_index(), 
                        x='marca', 
                        y='count', 
                        title='Quantidade por Marca',
                        text='count'
                    )
                    fig_marcas.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_marcas.update_layout(
                        xaxis_title="Marca",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_marcas, use_container_width=True)

                    # Gr√°fico de Modelos (Barras)
                    fig_modelos = px.bar(
                        modelos.reset_index(), 
                        x='modelo', 
                        y='count', 
                        title='Quantidade por Medida',
                        text='count'
                    )
                    fig_modelos.update_traces(
                        textposition='outside',
                        texttemplate='%{text}',
                        textfont=dict(size=11, color='white'),
                        marker=dict(line=dict(width=1, color='black'))
                    )
                    fig_modelos.update_layout(
                        xaxis_title="Modelo",
                        yaxis_title="Quantidade",
                        height=400,
                        bargap=0.3,
                        bargroupgap=0.1
                    )
                    st.plotly_chart(fig_modelos, use_container_width=True)



                    # Bot√µes de exporta√ß√£o
                    st.markdown("#### üìä Exportar Dados")
                    col_export1, col_export2, col_export3 = st.columns(3)
                    
                    with col_export1:
                        export_dataframe(status_df, "status_pneus", "csv")
                    
                    with col_export2:
                        export_dataframe(marcas.reset_index(), "marcas_pneus", "csv")
                    
                    with col_export3:
                        export_dataframe(modelos.reset_index(), "modelos_pneus", "csv")
                    
                    # Informa√ß√µes adicionais
                    st.markdown("---")
                    st.markdown("""
                    <div class="info-box">
                        <strong>üí° Dicas:</strong><br>
                        ‚Ä¢ Use os filtros para analisar per√≠odos espec√≠ficos<br>
                        ‚Ä¢ Exporte os dados para an√°lises externas<br>
                        ‚Ä¢ Os gr√°ficos s√£o interativos - clique para mais detalhes
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.info("Nenhum pneu cadastrado para demonstrativo.")

                st.markdown("---")
                st.subheader("üõ¢Ô∏è Demonstrativos de Lubrificantes")

                ensure_lubrificantes_schema()
                conn = sqlite3.connect(DB_PATH)
                df_lub = pd.read_sql("SELECT * FROM lubrificantes", conn)
                df_mov = pd.read_sql("SELECT * FROM lubrificantes_movimentacoes", conn)

                st.write("**Estoque Atual de Lubrificantes:**")
                if not df_lub.empty:
                    # Separar por tipo
                    df_oleos = df_lub[df_lub['tipo'].str.lower() == '√≥leo']
                    df_graxas = df_lub[df_lub['tipo'].str.lower() == 'graxa']

                    col_o, col_g = st.columns(2)
                    with col_o:
                        st.markdown("#### Estoque de √ìleos")
                        if not df_oleos.empty:
                            fig_oleos = px.bar(
                                df_oleos,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="√ìleos - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': '√ìleo'}
                            )
                            st.plotly_chart(fig_oleos, use_container_width=True)
                        else:
                            st.info("Nenhum √≥leo cadastrado.")

                    with col_g:
                        st.markdown("#### Estoque de Graxas")
                        if not df_graxas.empty:
                            fig_graxas = px.bar(
                                df_graxas,
                                x='nome',
                                y='quantidade_estoque',
                                color='viscosidade',
                                text='quantidade_estoque',
                                title="Graxas - Estoque Atual",
                                labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': 'Graxa'}
                            )
                            st.plotly_chart(fig_graxas, use_container_width=True)
                        else:
                            st.info("Nenhuma graxa cadastrada.")

                    # Pizza geral
                    df_lub['tipo'] = df_lub['tipo'].fillna('√≥leo')
                    fig_pizza = px.pie(
                        df_lub,
                        names='tipo',
                        values='quantidade_estoque',
                        title="Propor√ß√£o de Estoque: √ìleos vs Graxas"
                    )
                    st.plotly_chart(fig_pizza, use_container_width=True)

                    st.write("**Movimenta√ß√µes Recentes:**")
                    df_mov['data'] = pd.to_datetime(df_mov['data'], errors='coerce')
                    df_mov = df_mov.sort_values('data', ascending=False)
                    st.dataframe(df_mov.head(20))
                else:
                    st.info("Nenhum lubrificante cadastrado.")

                conn.close()
            
        if tab_consulta is not None:
            with tab_consulta:
                st.header("üîé Ficha Individual do Equipamento")
                # Permitir consulta direta por c√≥digo (C√≥d Equipamento)
                cod_input = st.text_input("Digite o c√≥digo da frota")
                if cod_input and cod_input.isdigit() and int(cod_input) in df_frotas['Cod_Equip'].values:
                    equip_label = df_frotas.loc[df_frotas['Cod_Equip'] == int(cod_input)].iloc[0]['label']
                else:
                    equip_label = None
            
                if equip_label:
                    cod_sel = int(equip_label.split(" - ")[0])
                    dados_eq = df_frotas.query("Cod_Equip == @cod_sel").iloc[0]
                    consumo_eq = df.query("Cod_Equip == @cod_sel")
                    
                    st.subheader(f"{dados_eq.get('DESCRICAO_EQUIPAMENTO','‚Äì')} ({dados_eq.get('PLACA','‚Äì')})")
                    
                    ultimo_registro = consumo_eq.dropna(subset=['Hod_Hor_Atual']).sort_values("Data", ascending=False).iloc[0] if not consumo_eq.dropna(subset=['Hod_Hor_Atual']).empty else None
                    valor_atual_display = formatar_brasileiro_int(ultimo_registro['Hod_Hor_Atual']) if ultimo_registro is not None else "‚Äì"
                    
                    c1, c2, c3 = st.columns(3)
                    c1.metric("Status", dados_eq.get("ATIVO", "‚Äì"))
                    c2.metric("Placa", dados_eq.get("PLACA", "‚Äì"))
                    c3.metric("Leitura Atual (Hod./Hor.)", valor_atual_display)

                    # An√°lise do motorista com uso mais frequente
                    st.markdown("---")
                    st.subheader("üë§ An√°lise de Uso por Motorista")
                    
                    if not consumo_eq.empty and 'Matricula' in consumo_eq.columns:
                        # An√°lise por motorista (matr√≠cula)
                        uso_por_motorista = consumo_eq.groupby('Matricula').agg({
                            'Qtde Litros': 'sum',
                            'Data': 'count'
                        }).rename(columns={'Data': 'Abastecimentos'}).sort_values('Qtde Litros', ascending=False)
                        
                        if not uso_por_motorista.empty:
                            # Top 5 motoristas com maior consumo
                            top_motoristas = uso_por_motorista.head(5).reset_index()
                            top_motoristas['Consumo (L)'] = top_motoristas['Qtde Litros'].apply(formatar_brasileiro_int)
                            top_motoristas['Abastecimentos'] = top_motoristas['Abastecimentos'].astype(int)
                            
                            col_motorista1, col_motorista2 = st.columns(2)
                            
                            with col_motorista1:
                                st.subheader("üèÜ Top 5 Motoristas por Consumo")
                                st.dataframe(
                                    top_motoristas[['Matricula', 'Consumo (L)', 'Abastecimentos']], 
                                    use_container_width=True
                                )
                            
                            with col_motorista2:
                                st.subheader("üìä Motorista com Maior Uso")
                                motorista_mais_frequente = top_motoristas.iloc[0]
                                st.metric(
                                    "Motorista Principal", 
                                    f"Matr√≠cula {motorista_mais_frequente['Matricula']}",
                                    f"{motorista_mais_frequente['Consumo (L)']} L"
                                )
                                st.metric(
                                    "Total de Abastecimentos", 
                                    motorista_mais_frequente['Abastecimentos']
                                )
                                st.metric(
                                    "Percentual do Total", 
                                    f"{(motorista_mais_frequente['Qtde Litros'] / uso_por_motorista['Qtde Litros'].sum() * 100):.1f}%"
                                )
                            
                            # Gr√°fico de consumo por motorista
                            st.subheader("üìà Consumo por Motorista")
                            fig_motoristas = px.bar(
                                top_motoristas,
                                x='Qtde Litros',
                                y='Matricula',
                                orientation='h',
                                text='Consumo (L)',
                                title="Consumo de Combust√≠vel por Motorista",
                                labels={'Qtde Litros': 'Litros Consumidos', 'Matricula': 'Matr√≠cula'}
                            )
                            fig_motoristas.update_traces(
                                textposition='outside',
                                marker_color='#2ca02c'
                            )
                            fig_motoristas.update_layout(
                                yaxis={'categoryorder':'total ascending'},
                                height=400
                            )
                            st.plotly_chart(fig_motoristas, use_container_width=True)
                            
                        else:
                            st.info("N√£o h√° dados de motoristas (matr√≠culas) para este equipamento.")
                    else:
                        st.info("N√£o h√° dados de consumo ou coluna de matr√≠cula para an√°lise de motoristas.")

                    # Indicadores: Checklists/Revis√µes executadas
                    col_filtro_a, col_filtro_b, col_filtro_c = st.columns([1, 1, 2])
                    periodo_opcoes = [7, 30, 90, 180, 365]
                    periodo_dias = col_filtro_a.selectbox(
                        "Per√≠odo (dias)", options=periodo_opcoes, index=periodo_opcoes.index(30), key="consulta_periodo_dias"
                    )
                    filtro_turno = col_filtro_b.selectbox(
                        "Turno (chk)", options=["Todos", "Manh√£", "Tarde", "Noite", "N/A"], index=0, key="consulta_turno_chk"
                    )
                    # Capturar t√≠tulos existentes para filtro
                    chk_titulos = (
                        sorted(df_checklist_historico['titulo_checklist'].dropna().unique().tolist())
                        if 'titulo_checklist' in df_checklist_historico.columns else []
                    )
                    filtro_titulo = col_filtro_c.selectbox(
                        "T√≠tulo do Checklist", options=["Todos"] + chk_titulos, index=0, key="consulta_titulo_chk"
                    )
                    limite_dt = pd.Timestamp.today().normalize() - pd.Timedelta(days=periodo_dias)
                    # Checklists por equipamento
                    hist_chk_eq = df_checklist_historico[df_checklist_historico['Cod_Equip'] == cod_sel].copy()
                    if not hist_chk_eq.empty and 'data_preenchimento' in hist_chk_eq.columns:
                        hist_chk_eq['data_preenchimento'] = pd.to_datetime(
                            hist_chk_eq['data_preenchimento'], errors='coerce'
                        )
                        if filtro_turno != "Todos" and 'turno' in hist_chk_eq.columns:
                            hist_chk_eq = hist_chk_eq[hist_chk_eq['turno'] == filtro_turno]
                        if filtro_titulo != "Todos" and 'titulo_checklist' in hist_chk_eq.columns:
                            hist_chk_eq = hist_chk_eq[hist_chk_eq['titulo_checklist'] == filtro_titulo]
                    chk_total = len(hist_chk_eq)
                    chk_30d = (
                        hist_chk_eq[hist_chk_eq['data_preenchimento'] >= limite_dt].shape[0]
                        if 'data_preenchimento' in hist_chk_eq.columns else 0
                    )
                    # Revis√µes (manuten√ß√µes de componentes) por equipamento
                    hist_rev_eq = df_comp_historico[df_comp_historico['Cod_Equip'] == cod_sel].copy()
                    if not hist_rev_eq.empty and 'Data' in hist_rev_eq.columns:
                        hist_rev_eq['Data'] = pd.to_datetime(hist_rev_eq['Data'], errors='coerce')
                    rev_total = len(hist_rev_eq)
                    rev_30d = (
                        hist_rev_eq[hist_rev_eq['Data'] >= limite_dt].shape[0] if 'Data' in hist_rev_eq.columns else 0
                    )

                    m1, m2, m3, m4 = st.columns(4)
                    m1.metric(f"Checklists ({periodo_dias}d)", chk_30d)
                    m2.metric("Checklists (total)", chk_total)
                    m3.metric(f"Revis√µes ({periodo_dias}d)", rev_30d)
                    m4.metric("Revis√µes (total)", rev_total)
            
                    st.markdown("---")

                    # NOVA SE√á√ÉO: Gastos com Combust√≠vel por Frota vs Classe
                    st.subheader("üí∞ Gastos com Combust√≠vel")
                    
                    precos_map = get_precos_combustivel_map()
                    if precos_map:
                        # Calcular gasto da frota selecionada
                        df_frota_gastos = consumo_eq.copy()
                        # Verificar se a coluna tipo_combustivel existe em df_frotas
                        if 'tipo_combustivel' in df_frotas.columns:
                            df_frota_gastos = df_frota_gastos.merge(
                                df_frotas[['Cod_Equip', 'tipo_combustivel']], 
                                on='Cod_Equip', 
                                how='left'
                            )
                            # Verificar se a coluna foi criada ap√≥s o merge
                            if 'tipo_combustivel' in df_frota_gastos.columns:
                                df_frota_gastos['tipo_combustivel'] = df_frota_gastos['tipo_combustivel'].fillna('Diesel S500')
                            else:
                                df_frota_gastos['tipo_combustivel'] = 'Diesel S500'
                        else:
                            # Se n√£o existir, criar a coluna com valor padr√£o
                            df_frota_gastos['tipo_combustivel'] = 'Diesel S500'
                        df_frota_gastos['preco_unit'] = df_frota_gastos['tipo_combustivel'].map(precos_map).fillna(0.0)
                        df_frota_gastos['custo'] = df_frota_gastos['Qtde Litros'].fillna(0.0) * df_frota_gastos['preco_unit']
                        
                        gasto_frota = df_frota_gastos['custo'].sum()
                        
                        # Calcular gasto total da classe
                        classe_selecionada = dados_eq.get('Classe_Operacional')
                        gasto_classe_total = 0
                        if classe_selecionada:
                            df_classe_gastos = df[df['Classe_Operacional'] == classe_selecionada].copy()
                            # Verificar se a coluna tipo_combustivel existe em df_frotas
                            if 'tipo_combustivel' in df_frotas.columns:
                                df_classe_gastos = df_classe_gastos.merge(
                                    df_frotas[['Cod_Equip', 'tipo_combustivel']], 
                                    on='Cod_Equip', 
                                    how='left'
                                )
                                # Verificar se a coluna foi criada ap√≥s o merge
                                if 'tipo_combustivel' in df_classe_gastos.columns:
                                    df_classe_gastos['tipo_combustivel'] = df_classe_gastos['tipo_combustivel'].fillna('Diesel S500')
                                else:
                                    df_classe_gastos['tipo_combustivel'] = 'Diesel S500'
                            else:
                                # Se n√£o existir, criar a coluna com valor padr√£o
                                df_classe_gastos['tipo_combustivel'] = 'Diesel S500'
                            
                            df_classe_gastos['preco_unit'] = df_classe_gastos['tipo_combustivel'].map(precos_map).fillna(0.0)
                            df_classe_gastos['custo'] = df_classe_gastos['Qtde Litros'].fillna(0.0) * df_classe_gastos['preco_unit']
                            gasto_classe_total = df_classe_gastos['custo'].sum()
                        
                        # Calcular porcentagem
                        porcentagem_classe = (gasto_frota / gasto_classe_total * 100) if gasto_classe_total > 0 else 0
                        
                        # Exibir m√©tricas
                        col_gasto1, col_gasto2, col_gasto3 = st.columns(3)
                        
                        with col_gasto1:
                            st.metric(
                                "üí∞ Gasto da Frota", 
                                formatar_brasileiro(gasto_frota, 'R$ '),
                                help="Total gasto com combust√≠vel por esta frota"
                            )
                        
                        with col_gasto2:
                            st.metric(
                                "üí∞ Gasto Total da Classe", 
                                formatar_brasileiro(gasto_classe_total, 'R$ '),
                                help="Total gasto com combust√≠vel por todas as frotas da mesma classe"
                            )
                        
                        with col_gasto3:
                            st.metric(
                                "üìä % da Classe", 
                                f"{porcentagem_classe:.1f}%",
                                help="Porcentagem que esta frota representa do gasto total da classe"
                            )
                        
                        # Gr√°fico de compara√ß√£o
                        if gasto_classe_total > 0:
                            df_comparacao_gastos = pd.DataFrame({
                                'Categoria': ['Esta Frota', 'Outras Frotas da Classe'],
                                'Gasto (R$)': [gasto_frota, gasto_classe_total - gasto_frota]
                            })
                            
                            fig_gastos = px.pie(
                                df_comparacao_gastos,
                                values='Gasto (R$)',
                                names='Categoria',
                                title=f"Distribui√ß√£o de Gastos na Classe {classe_selecionada}",
                                color_discrete_map={
                                    'Esta Frota': '#ff7f0e',
                                    'Outras Frotas da Classe': '#1f77b4'
                                }
                            )
                            fig_gastos.update_traces(
                                textposition='inside',
                                textinfo='percent+label',
                                textfont_size=14
                            )
                            fig_gastos.update_layout(height=400)
                            st.plotly_chart(fig_gastos, use_container_width=True)
                            
                            # Informa√ß√µes adicionais
                            st.info(f"""
                            **üìä Resumo dos Gastos:**
                            - Esta frota representa **{porcentagem_classe:.1f}%** do gasto total da classe **{classe_selecionada}**
                            - Gasto m√©dio por frota na classe: **{formatar_brasileiro(gasto_classe_total / df_frotas[df_frotas['Classe_Operacional'] == classe_selecionada].shape[0], 'R$ ')}**
                            """)
                    else:
                        st.warning("‚ö†Ô∏è Para visualizar os gastos com combust√≠vel, configure os pre√ßos na aba 'Importar Dados > Pre√ßos de Combust√≠vel'.")
                    
                    st.markdown("---")
                    st.subheader("‚õΩ Consumo Total da Frota")

                    if not consumo_eq.empty:
                        # Calcular consumo total em litros
                        consumo_total_litros = consumo_eq['Qtde Litros'].sum()

                        # Calcular consumo por per√≠odo (√∫ltimos 30, 90, 365 dias)
                        hoje = pd.Timestamp.now()
                        periodos = {
                            '√öltimos 30 dias': 30,
                            '√öltimos 90 dias': 90,
                            '√öltimos 365 dias': 365
                        }

                        consumos_periodo = {}
                        for nome_periodo, dias in periodos.items():
                            data_limite = hoje - pd.Timedelta(days=dias)
                            consumo_periodo = consumo_eq[consumo_eq['Data'] >= data_limite]['Qtde Litros'].sum()
                            consumos_periodo[nome_periodo] = consumo_periodo

                        # Calcular consumo da classe para compara√ß√£o
                        classe_selecionada = dados_eq.get('Classe_Operacional')
                        consumo_classe_total = 0
                        if classe_selecionada:
                            df_classe_consumo = df[df['Classe_Operacional'] == classe_selecionada]
                            consumo_classe_total = df_classe_consumo['Qtde Litros'].sum()

                        # Calcular porcentagem do consumo da classe
                        porcentagem_consumo_classe = (consumo_total_litros / consumo_classe_total * 100) if consumo_classe_total > 0 else 0

                        # M√©tricas de consumo
                        col_consumo1, col_consumo2, col_consumo3, col_consumo4, col_consumo5 = st.columns(5)

                        with col_consumo1:
                            st.metric(
                                "üìä Consumo Total",
                                f"{formatar_brasileiro_int(consumo_total_litros)} L",
                                help="Total de litros consumidos por esta frota"
                            )

                        with col_consumo2:
                            st.metric(
                                "üìÖ √öltimos 30 dias",
                                f"{formatar_brasileiro_int(consumos_periodo['√öltimos 30 dias'])} L"
                            )

                        with col_consumo3:
                            st.metric(
                                "üìÖ √öltimos 90 dias",
                                f"{formatar_brasileiro_int(consumos_periodo['√öltimos 90 dias'])} L"
                            )

                        with col_consumo4:
                            st.metric(
                                "üìÖ √öltimos 365 dias",
                                f"{formatar_brasileiro_int(consumos_periodo['√öltimos 365 dias'])} L"
                            )

                        with col_consumo5:
                            st.metric(
                                "üìä % da Classe",
                                f"{porcentagem_consumo_classe:.1f}%",
                                help="Porcentagem que esta frota representa do consumo total da classe"
                            )

                        # Gr√°fico de consumo por per√≠odo
                        df_consumo_periodo = pd.DataFrame({
                            'Per√≠odo': list(consumos_periodo.keys()),
                            'Consumo (L)': list(consumos_periodo.values())
                        })

                        # Melhorar formata√ß√£o dos r√≥tulos para o gr√°fico
                        df_consumo_periodo['R√≥tulo_Formatado'] = df_consumo_periodo['Consumo (L)'].apply(
                            lambda x: f"{formatar_brasileiro_int(x)} L" if x > 0 else "0 L"
                        )
                        
                        fig_consumo_periodo = px.bar(
                            df_consumo_periodo,
                            x='Per√≠odo',
                            y='Consumo (L)',
                            title=f"Consumo de Combust√≠vel por Per√≠odo - Frota {cod_sel}",
                            text='R√≥tulo_Formatado',
                            color='Consumo (L)',
                            color_continuous_scale='Blues'
                        )
                        
                        # Melhorar a apar√™ncia dos r√≥tulos
                        fig_consumo_periodo.update_traces(
                            textposition='outside',
                            texttemplate='%{text}',
                            textfont=dict(
                                size=14,
                                color='#edf5fc',
                                family='Arial, sans-serif'
                            ),
                            hovertemplate='<b>%{x}</b><br>' +
                                        'Consumo: <b>%{y:,.0f} L</b><br>' +
                                        '<extra></extra>'
                        )
                        
                        fig_consumo_periodo.update_layout(
                            height=500,
                            showlegend=False,
                            xaxis_title="Per√≠odo",
                            yaxis_title="Consumo (Litros)",
                            title_font=dict(size=18, color='#edf5fc'),
                            xaxis=dict(
                                title_font=dict(size=14, color='#edf5fc'),
                                tickfont=dict(size=12, color='#edf5fc')
                            ),
                            yaxis=dict(
                                title_font=dict(size=14, color='#edf5fc'),
                                tickfont=dict(size=12, color='#edf5fc'),
                                tickformat=',.0f'
                            ),
                            plot_bgcolor='rgba(0,0,0,0)',
                            paper_bgcolor='rgba(0,0,0,0)',
                            margin=dict(t=80, b=80, l=80, r=80)
                        )
                        st.plotly_chart(fig_consumo_periodo, use_container_width=True)

                        # Gr√°fico de compara√ß√£o de consumo vs classe
                        if consumo_classe_total > 0:
                            df_comparacao_consumo = pd.DataFrame({
                                'Categoria': ['Esta Frota', 'Outras Frotas da Classe'],
                                'Consumo (L)': [consumo_total_litros, consumo_classe_total - consumo_total_litros]
                            })

                            # Melhorar formata√ß√£o dos r√≥tulos para o gr√°fico de pizza
                            df_comparacao_consumo['R√≥tulo_Formatado'] = df_comparacao_consumo['Consumo (L)'].apply(
                                lambda x: f"{formatar_brasileiro_int(x)} L"
                            )
                            
                            fig_consumo_classe = px.pie(
                                df_comparacao_consumo,
                                values='Consumo (L)',
                                names='Categoria',
                                title=f"Distribui√ß√£o de Consumo na Classe {classe_selecionada}",
                                color_discrete_map={
                                    'Esta Frota': '#ff7f0e',
                                    'Outras Frotas da Classe': '#1f77b4'
                                }
                            )
                            
                            # Melhorar a apar√™ncia dos r√≥tulos
                            fig_consumo_classe.update_traces(
                                textposition='inside',
                                textinfo='percent+label',
                                textfont=dict(
                                    size=16,
                                    color='white',
                                    family='Arial, sans-serif'
                                ),
                                hovertemplate='<b>%{label}</b><br>' +
                                            'Consumo: <b>%{value:,.0f} L</b><br>' +
                                            'Percentual: <b>%{percent:.1%}</b><br>' +
                                            '<extra></extra>'
                            )
                            
                            fig_consumo_classe.update_layout(
                                height=450,
                                title_font=dict(size=18, color='#2c3e50'),
                                showlegend=True,
                                legend=dict(
                                    font=dict(size=14, color='#34495e'),
                                    bgcolor='rgba(255,255,255,0.8)',
                                    bordercolor='#bdc3c7',
                                    borderwidth=1
                                ),
                                margin=dict(t=80, b=80, l=80, r=80)
                            )
                            st.plotly_chart(fig_consumo_classe, use_container_width=True)

                        # Gr√°fico de evolu√ß√£o mensal do consumo
                        if len(consumo_eq) > 1:
                            consumo_mensal_frota = consumo_eq.groupby('AnoMes')['Qtde Litros'].sum().reset_index().sort_values('AnoMes')

                            if not consumo_mensal_frota.empty:
                                # Melhorar formata√ß√£o dos dados para o gr√°fico
                                consumo_mensal_frota['Consumo_Formatado'] = consumo_mensal_frota['Qtde Litros'].apply(
                                    lambda x: f"{formatar_brasileiro_int(x)} L"
                                )
                                
                                fig_evolucao = px.line(
                                    consumo_mensal_frota,
                                    x='AnoMes',
                                    y='Qtde Litros',
                                    title=f"Evolu√ß√£o Mensal do Consumo - Frota {cod_sel}",
                                    labels={"AnoMes": "M√™s/Ano", "Qtde Litros": "Litros Consumidos"},
                                    markers=True,
                                    text='Consumo_Formatado'
                                )
                                
                                # Melhorar a apar√™ncia dos r√≥tulos e marcadores
                                fig_evolucao.update_traces(
                                    textposition='top center',
                                    textfont=dict(
                                        size=12,
                                        color='#2c3e50',
                                        family='Arial, sans-serif'
                                    ),
                                    hovertemplate='<b>%{x}</b><br>' +
                                                'Consumo: <b>%{y:,.0f} L</b><br>' +
                                                '<extra></extra>',
                                    marker=dict(
                                        size=8,
                                        color='#e74c3c',
                                        line=dict(width=2, color='#edf5fc')
                                    ),
                                    line=dict(width=3, color='#e74c3c')
                                )
                                
                                fig_evolucao.update_layout(
                                    height=500,
                                    xaxis_title="M√™s/Ano",
                                    yaxis_title="Litros Consumidos",
                                    title_font=dict(size=18, color='#edf5fc'),
                                    xaxis=dict(
                                        title_font=dict(size=14, color='#edf5fc'),
                                        tickfont=dict(size=12, color='#edf5fc'),
                                        tickangle=45
                                    ),
                                    yaxis=dict(
                                        title_font=dict(size=14, color='#edf5fc'),
                                        tickfont=dict(size=12, color='#edf5fc'),
                                        tickformat=',.0f'
                                    ),
                                    plot_bgcolor='rgba(0,0,0,0)',
                                    paper_bgcolor='rgba(0,0,0,0)',
                                    margin=dict(t=80, b=80, l=80, r=80)
                                )
                                st.plotly_chart(fig_evolucao, use_container_width=True)

                        # Resumo informativo
                        st.info(f"""
                        **üìà Resumo do Consumo:**
                        - **Total hist√≥rico:** {formatar_brasileiro_int(consumo_total_litros)} litros
                        - **M√©dia por abastecimento:** {formatar_brasileiro_int(consumo_eq['Qtde Litros'].mean())} litros
                        - **Total de abastecimentos:** {len(consumo_eq)} registros
                        - **Per√≠odo de opera√ß√£o:** {consumo_eq['Data'].min().strftime('%d/%m/%Y')} a {consumo_eq['Data'].max().strftime('%d/%m/%Y')}
                        - **Compara√ß√£o com classe:** Esta frota representa **{porcentagem_consumo_classe:.1f}%** do consumo total da classe **{classe_selecionada}**
                        """)
                    else:
                        st.info("N√£o h√° dados de consumo para este equipamento.")

                    st.markdown("---")
                    
                    st.subheader("Comparativo de Efici√™ncia")
                
                    col_grafico, col_alerta = st.columns([2, 1]) 

                    if 'Media' not in df.columns or df['Media'].dropna().empty:
                        col_grafico.warning("A coluna 'Media' n√£o foi encontrada ou est√° vazia.")
                    else:
                        consumo_real_eq = consumo_eq[(consumo_eq['Media'].notna()) & (consumo_eq['Media'] > 0)]
                        media_equip_selecionado = consumo_real_eq['Media'].mean()
                        
                        classe_selecionada = dados_eq.get('Classe_Operacional')
                        media_da_classe = np.nan

                        if classe_selecionada:
                            consumo_classe = df[(df['Classe_Operacional'] == classe_selecionada) & (df['Media'].notna()) & (df['Media'] > 0)]
                            media_da_classe = consumo_classe['Media'].mean()
                            
                            # Verificar meta da classe
                            meta_consumo = st.session_state.intervalos_por_classe.get(classe_selecionada, {}).get('meta_consumo', 0)
                            
                            # Verificar se h√° meta individual para esta frota (que sobrescreve a da classe)
                            meta_individual = 0
                            if 'metas_individuals' in st.session_state:
                                meta_individual = st.session_state.metas_individuals.get(cod_sel, {}).get('meta_consumo', 0)
                            
                            # Usar meta individual se existir e sobrescrever classe, sen√£o usar meta da classe
                            meta_final = meta_individual if meta_individual > 0 and st.session_state.metas_individuals.get(cod_sel, {}).get('sobrescrever_classe', False) else meta_consumo

                            if pd.notna(media_equip_selecionado) and pd.notna(media_da_classe):
                                with col_alerta:
                                    st.write("") 
                                    st.write("")
                                    if meta_final > 0 and media_equip_selecionado > meta_final * 1.05:
                                        st.error(f"**ALERTA DE META!** O consumo est√° acima da meta definida.")
                                    elif media_equip_selecionado <= media_da_classe * 1.05:
                                        st.success(f"**EFICIENTE!** O consumo est√° dentro ou abaixo da m√©dia da sua classe.")
                                    else:
                                        st.warning(f"**ATEN√á√ÉO!** O consumo est√° acima da m√©dia da classe.")
                                    
                                    st.metric(label=f"M√©dia do Equipamento", value=formatar_brasileiro(media_equip_selecionado))
                                    st.metric(label=f"M√©dia da Classe", value=formatar_brasileiro(media_da_classe))
                                    if meta_final > 0:
                                        # Mostrar qual meta est√° sendo usada
                                        if meta_individual > 0 and st.session_state.metas_individuals.get(cod_sel, {}).get('sobrescrever_classe', False):
                                            st.metric(label=f"Meta Individual", value=formatar_brasileiro(meta_final), help="Meta individual que sobrescreve a da classe")
                                        else:
                                            st.metric(label=f"Meta da Classe", value=formatar_brasileiro(meta_final))

                                with col_grafico:
                                    # --- IN√çCIO DA CORRE√á√ÉO ---
                                    # 1. Define os novos nomes para as categorias do gr√°fico
                                    nome_frota = f"Frota {dados_eq.get('Cod_Equip')}"
                                    nome_classe = f"M√©dia {classe_selecionada}"

                                    df_comp = pd.DataFrame({
                                        'Categoria': [nome_frota, nome_classe, "Meta Definida"],
                                        'M√©dia Consumo': [media_equip_selecionado, media_da_classe, meta_final]
                                    })
                                    df_comp['texto_formatado'] = df_comp['M√©dia Consumo'].apply(lambda x: formatar_brasileiro(x))

                                    fig_comp = px.bar(
                                        df_comp, 
                                        x='Categoria', 
                                        y='M√©dia Consumo', 
                                        text='texto_formatado', 
                                        title=f"Efici√™ncia de Consumo vs. Meta ({'Individual' if meta_individual > 0 and st.session_state.metas_individuals.get(cod_sel, {}).get('sobrescrever_classe', False) else 'da Classe'})",
                                        color='Categoria',
                                        # 2. Atualiza o mapa de cores com os novos nomes
                                        color_discrete_map={
                                            nome_frota: 'royalblue',
                                            nome_classe: 'lightgrey',
                                            'Meta Definida': 'lightcoral'
                                        }
                                    )
                                    # --- FIM DA CORRE√á√ÉO ---

                                    fig_comp.update_traces(textposition='outside', width=0.5)
                                    fig_comp.update_layout(height=500, showlegend=False, xaxis_title=None, yaxis_title="M√©dia de Consumo")
                                    st.plotly_chart(fig_comp, use_container_width=True)
                            else:
                                col_grafico.info("N√£o h√° dados de consumo suficientes para gerar o comparativo.")
                            
                    st.markdown("---")
                    
                    st.markdown("---")
                    
                    st.subheader("Manuten√ß√µes Pendentes (Componentes)")
                    dados_manut_pendente = plan_df[plan_df['Cod_Equip'] == cod_sel]
                    
                    if not dados_manut_pendente.empty:
                        componentes_pendentes = []
                        for col in dados_manut_pendente.columns:
                            if 'Restante_' in col:
                                valor_restante = dados_manut_pendente[col].iloc[0]
                                if pd.notna(valor_restante):
                                    nome_componente = col.replace('Restante_', '')
                                    unidade = dados_manut_pendente['Unidade'].iloc[0]
                                    componentes_pendentes.append((nome_componente, valor_restante, unidade))
                        
                        if componentes_pendentes:
                            componentes_pendentes.sort(key=lambda x: x[1]) # Ordena para mostrar os mais urgentes primeiro
                            cols_metricas = st.columns(len(componentes_pendentes))
                            for i, (nome, valor, unid) in enumerate(componentes_pendentes):
                                cols_metricas[i].metric(
                                    label=f"Pr√≥ximo(a) {nome}", 
                                    value=f"{formatar_brasileiro_int(valor)} {unid}"
                                )
                        else:
                            st.success("‚úÖ Nenhum componente com manuten√ß√£o pendente.")
                    else:
                        st.info("Sem dados de manuten√ß√£o para este equipamento.")
                    # --- FIM DA MELHORIA 1 ---

                    st.markdown("---")
                    
                    # --- IN√çCIO DA MELHORIA 2: Hist√≥rico de Manuten√ß√£o por Componente ---
                    st.subheader("Hist√≥rico de Manuten√ß√µes de Componentes")
                    
                    # Buscar componentes configurados para este equipamento
                    classe_equip = df_frotas[df_frotas['Cod_Equip'] == cod_sel]['Classe_Operacional'].iloc[0]
                    componentes_configurados = df_comp_regras[df_comp_regras['classe_operacional'] == classe_equip]
                    
                    if not componentes_configurados.empty:
                        # Criar abas para cada componente
                        componentes_nomes = componentes_configurados['nome_componente'].tolist()
                        if componentes_nomes:
                            tab_componentes = st.tabs(componentes_nomes)
                            
                            for i, componente in enumerate(componentes_nomes):
                                with tab_componentes[i]:
                                    # Buscar hist√≥rico do componente
                                    historico_componente = df_comp_historico[
                                        (df_comp_historico['Cod_Equip'] == cod_sel) & 
                                        (df_comp_historico['nome_componente'] == componente)
                                    ].sort_values("Data", ascending=False)
                                    
                                    # Buscar informa√ß√µes da regra do componente
                                    regra_componente = componentes_configurados[componentes_configurados['nome_componente'] == componente].iloc[0]
                                    intervalo_padrao = regra_componente['intervalo_padrao']
                                    
                                    # Buscar informa√ß√µes do lubrificante se existir
                                    lubrificante_info = ""
                                    if 'lubrificante_id' in regra_componente and regra_componente['lubrificante_id']:
                                        conn = sqlite3.connect(DB_PATH)
                                        df_lub = pd.read_sql("SELECT nome, viscosidade FROM lubrificantes WHERE id = ?", conn, params=(regra_componente['lubrificante_id'],))
                                        conn.close()
                                        if not df_lub.empty:
                                            lub = df_lub.iloc[0]
                                            lubrificante_info = f"{lub['nome']} ({lub['viscosidade']})"
                                    
                                    # Mostrar informa√ß√µes do componente
                                    col1, col2, col3 = st.columns(3)
                                    with col1:
                                        st.metric("Intervalo Padr√£o", f"{intervalo_padrao} {'km' if df_frotas[df_frotas['Cod_Equip'] == cod_sel]['Tipo_Controle'].iloc[0] == 'QUIL√îMETROS' else 'h'}")
                                    with col2:
                                        if lubrificante_info:
                                            st.metric("Lubrificante", lubrificante_info)
                                        else:
                                            st.metric("Lubrificante", "N√£o aplic√°vel")
                                    with col3:
                                        # Contar manuten√ß√µes
                                        total_manutencoes = len(historico_componente)
                                        st.metric("Total de Manuten√ß√µes", total_manutencoes)
                                    
                                    # Mostrar status atual se houver hist√≥rico
                                    if not historico_componente.empty:
                                        # Verificar se a coluna tipo_servico existe
                                        if 'tipo_servico' in historico_componente.columns:
                                            # Buscar a √∫ltima TROCA (n√£o remonta) para calcular km restantes
                                            ultimas_trocas = historico_componente[
                                                (historico_componente['tipo_servico'] == 'Troca') | 
                                                (historico_componente['tipo_servico'].isna())  # Para registros antigos sem tipo
                                            ]
                                        else:
                                            # Se a coluna n√£o existe, considerar todos como trocas (registros antigos)
                                            ultimas_trocas = historico_componente
                                        
                                        if not ultimas_trocas.empty:
                                            ultima_troca = ultimas_trocas.iloc[0]
                                            hod_ultima_troca = ultima_troca['Hod_Hor_No_Servico']
                                            
                                            # Buscar hod√¥metro atual
                                            hod_atual = df[df['Cod_Equip'] == cod_sel]['Hod_Hor_Atual'].max()
                                            if pd.notna(hod_atual):
                                                km_restantes = (hod_ultima_troca + intervalo_padrao) - hod_atual
                                                
                                                col_status1, col_status2 = st.columns(2)
                                                with col_status1:
                                                    if km_restantes > 0:
                                                        st.success(f"üü¢ **{formatar_brasileiro_int(km_restantes)}** restantes")
                                                    else:
                                                        st.error(f"üî¥ **{formatar_brasileiro_int(abs(km_restantes))}** em atraso")
                                                
                                                with col_status2:
                                                    st.info(f"√öltima troca: {ultima_troca['Data']} ({formatar_brasileiro_int(hod_ultima_troca)})")
                                        else:
                                            st.warning("‚ö†Ô∏è Nenhuma troca registrada. Remontas n√£o reiniciam o contador.")
                                        
                                        # Mostrar √∫ltima manuten√ß√£o (qualquer tipo)
                                        ultima_manutencao = historico_componente.iloc[0]
                                        tipo_ultima = ultima_manutencao.get('tipo_servico', 'N/A') if 'tipo_servico' in historico_componente.columns else 'N/A'
                                        st.info(f"√öltima manuten√ß√£o: {ultima_manutencao['Data']} - {tipo_ultima}")
                                    
                                    # Mostrar hist√≥rico detalhado
                                    if not historico_componente.empty:
                                        st.subheader("Hist√≥rico Detalhado")
                                        # Selecionar colunas dispon√≠veis
                                        colunas_disponiveis = ['Data', 'Hod_Hor_No_Servico', 'Observacoes']
                                        
                                        # Verificar e adicionar colunas se existirem
                                        if 'tipo_servico' in historico_componente.columns:
                                            colunas_disponiveis.insert(2, 'tipo_servico')
                                        if 'lubrificante_utilizado' in historico_componente.columns:
                                            colunas_disponiveis.insert(3, 'lubrificante_utilizado')
                                        
                                        # Filtrar apenas colunas que existem no DataFrame
                                        colunas_finais = [col for col in colunas_disponiveis if col in historico_componente.columns]
                                        
                                        st.dataframe(historico_componente[colunas_finais])
                                    else:
                                        st.info("Nenhum hist√≥rico de manuten√ß√£o para este componente.")
                    else:
                        st.info("Nenhum componente configurado para esta classe de equipamento.")
                    
                    # --- IN√çCIO DA MELHORIA 3: Estat√≠sticas de Manuten√ß√£o ---
                    st.markdown("---")
                    st.subheader("üìä Estat√≠sticas de Manuten√ß√£o por Tipo")
                    
                    # Buscar todas as manuten√ß√µes do equipamento
                    todas_manutencoes = df_comp_historico[df_comp_historico['Cod_Equip'] == cod_sel]
                    
                    if not todas_manutencoes.empty:
                        # Verificar se a coluna tipo_servico existe
                        if 'tipo_servico' in todas_manutencoes.columns:
                            # Contar por tipo de servi√ßo
                            contagem_tipos = todas_manutencoes['tipo_servico'].value_counts()
                        
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            total_manut = len(todas_manutencoes)
                            st.metric("Total de Manuten√ß√µes", total_manut)
                        
                        with col2:
                            if 'tipo_servico' in todas_manutencoes.columns:
                                total_trocas = contagem_tipos.get('Troca', 0)
                                st.metric("Total de Trocas", total_trocas)
                            else:
                                st.metric("Total de Trocas", "N/A")
                        
                        with col3:
                            if 'tipo_servico' in todas_manutencoes.columns:
                                total_remontas = contagem_tipos.get('Remonta', 0)
                                st.metric("Total de Remontas", total_remontas)
                            else:
                                st.metric("Total de Remontas", "N/A")
                        
                        # Gr√°fico de pizza para tipos de manuten√ß√£o
                        if 'tipo_servico' in todas_manutencoes.columns and len(contagem_tipos) > 0:
                            fig_tipos = px.pie(
                                values=contagem_tipos.values,
                                names=contagem_tipos.index,
                                title="Distribui√ß√£o por Tipo de Manuten√ß√£o"
                            )
                            st.plotly_chart(fig_tipos, use_container_width=True)
                        elif 'tipo_servico' not in todas_manutencoes.columns:
                            st.info("‚ö†Ô∏è Registros antigos detectados. Novas manuten√ß√µes incluir√£o tipo de servi√ßo.")
                    else:
                        st.info("Nenhuma manuten√ß√£o registrada para este equipamento.")
                    # --- FIM DA MELHORIA 3 ---
                    # --- FIM DA MELHORIA 2 ---

                    st.subheader("Hist√≥rico de Abastecimentos")
                    # O seu hist√≥rico de abastecimentos continua igual
                    historico_abast_display = consumo_eq.sort_values("Data", ascending=False)
                    if not historico_abast_display.empty:
                        # Mostra matr√≠cula (Cod_Equip) e nome do motorista quando dispon√≠vel
                        colunas_abast = ["Data", "Qtde Litros", "Media", "Hod_Hor_Atual", "Matricula", "Nome_Motorista"]
                        st.dataframe(historico_abast_display[[c for c in colunas_abast if c in historico_abast_display.columns]])
                    else:
                        st.info("Nenhum registo de abastecimento para este equipamento.")
                
                # ===== NOVA SE√á√ÉO: INSIGHTS E RECOMENDA√á√ïES INTELIGENTES =====
                st.markdown("---")
                st.subheader("üß† Insights e Recomenda√ß√µes Inteligentes")
                
                # Recalcular vari√°veis necess√°rias para os insights
                total_frotas_ativas_insights = df_frotas[df_frotas['ATIVO'] == 'ATIVO']['Cod_Equip'].nunique()
                frotas_com_alerta_insights = plan_df[plan_df['Qualquer_Alerta'] == True]['Cod_Equip'].nunique() if not plan_df.empty else 0
                
                # Calcular gasto total para insights
                gasto_total_combustivel_insights = 0
                precos_map = get_precos_combustivel_map()
                
                # Definir consumo_eq se n√£o estiver definida (para insights gerais)
                if 'consumo_eq' not in locals():
                    consumo_eq = df.copy()
                
                if precos_map:
                    df_gastos_insights = consumo_eq.copy()
                    if 'tipo_combustivel' in df_frotas.columns:
                        df_gastos_insights = df_gastos_insights.merge(df_frotas[['Cod_Equip','tipo_combustivel']], on='Cod_Equip', how='left')
                        # Verificar se a coluna foi criada ap√≥s o merge
                        if 'tipo_combustivel' in df_gastos_insights.columns:
                            df_gastos_insights['tipo_combustivel'] = df_gastos_insights['tipo_combustivel'].fillna('Diesel S500')
                        else:
                            df_gastos_insights['tipo_combustivel'] = 'Diesel S500'
                    else:
                        df_gastos_insights['tipo_combustivel'] = 'Diesel S500'
                    
                    df_gastos_insights['preco_unit'] = df_gastos_insights['tipo_combustivel'].map(precos_map).fillna(0.0)
                    df_gastos_insights['custo'] = df_gastos_insights['Qtde Litros'].fillna(0.0) * df_gastos_insights['preco_unit']
                    gasto_total_combustivel_insights = df_gastos_insights['custo'].sum()
                
                # Gerar insights baseados nos dados
                insights = []
                recomendacoes = []
                
                # Insight 1: An√°lise de efici√™ncia
                if 'Media' in consumo_eq.columns and not consumo_eq['Media'].dropna().empty:
                    media_geral = consumo_eq['Media'].mean()
                    equipamentos_ineficientes = consumo_eq[consumo_eq['Media'] > media_geral * 1.2]['Cod_Equip'].nunique()
                    if equipamentos_ineficientes > 0:
                        insights.append(f"üîç **{equipamentos_ineficientes} equipamentos** est√£o consumindo mais de 20% acima da m√©dia")
                        recomendacoes.append("üí° Considere revisar a opera√ß√£o destes equipamentos ou agendar manuten√ß√£o preventiva")
                
                # Insight 2: An√°lise de alertas
                if frotas_com_alerta_insights > 0:
                    insights.append(f"‚ö†Ô∏è **{frotas_com_alerta_insights} equipamentos** com alertas de manuten√ß√£o pendentes")
                    recomendacoes.append("üîß Priorize a manuten√ß√£o destes equipamentos para evitar paradas n√£o programadas")
                
                # Insight 3: An√°lise de gastos
                if gasto_total_combustivel_insights > 0:
                    # Calcular gasto mensal m√©dio se houver dados de consumo mensal
                    if 'consumo_mensal' in locals() and len(consumo_mensal) > 0:
                        gasto_mensal_medio = gasto_total_combustivel_insights / len(consumo_mensal)
                        insights.append(f"üí∞ Gasto mensal m√©dio com combust√≠vel: **{formatar_brasileiro(gasto_mensal_medio, 'R$ ')}**")
                        recomendacoes.append("üìä Monitore regularmente os gastos para identificar oportunidades de economia")
                    else:
                        insights.append(f"üí∞ Gasto total com combust√≠vel: **{formatar_brasileiro(gasto_total_combustivel_insights, 'R$ ')}**")
                        recomendacoes.append("üìä Monitore regularmente os gastos para identificar oportunidades de economia")
                
                # Insight 4: An√°lise de tend√™ncia (se dispon√≠vel)
                if 'variacao' in locals() and abs(variacao) > 10:
                    if variacao > 0:
                        insights.append(f"üìà Consumo aumentou **{variacao:+.1f}%** no √∫ltimo per√≠odo")
                        recomendacoes.append("üîç Investigar causas do aumento de consumo (sazonalidade, opera√ß√£o, etc.)")
                    else:
                        insights.append(f"üìâ Consumo diminuiu **{variacao:+.1f}%** no √∫ltimo per√≠odo")
                        recomendacoes.append("‚úÖ Boa performance! Mantenha as pr√°ticas que levaram √† redu√ß√£o")
                
                # Insight 5: An√°lise de frotas ativas
                total_frotas = df_frotas['Cod_Equip'].nunique()
                if total_frotas_ativas_insights < total_frotas * 0.9:
                    frotas_inativas = total_frotas - total_frotas_ativas_insights
                    insights.append(f"üö´ **{frotas_inativas} equipamentos** est√£o inativos")
                    recomendacoes.append("üîÑ Avalie se estes equipamentos podem ser reativados ou se devem ser descartados")
                
                # Exibir insights
                if insights:
                    st.markdown("**üîç Insights Principais:**")
                    for insight in insights:
                        st.info(insight)
                else:
                    st.info("üìä N√£o h√° insights espec√≠ficos para exibir no momento.")
                
                # Exibir recomenda√ß√µes
                if recomendacoes:
                    st.markdown("**üí° Recomenda√ß√µes:**")
                    for i, recomendacao in enumerate(recomendacoes, 1):
                        st.success(f"{i}. {recomendacao}")
                
                # Resumo executivo
                st.markdown("---")
                st.markdown("**üìã Resumo Executivo:**")
                
                col_res1, col_res2, col_res3 = st.columns(3)
                with col_res1:
                    st.metric("üöó Frotas Analisadas", total_frotas_ativas_insights)
                with col_res2:
                    st.metric("üí∞ Gasto Total", formatar_brasileiro(gasto_total_combustivel_insights, 'R$ '))
                with col_res3:
                    st.metric("‚ö†Ô∏è Alertas Ativos", frotas_com_alerta_insights)
                
                # Bot√£o para exportar relat√≥rio completo
                if st.button("üìÑ Gerar Relat√≥rio Executivo", type="primary"):
                    st.success("‚úÖ Relat√≥rio gerado com sucesso! Use o bot√£o de download abaixo.")
                    
                    # Criar relat√≥rio em formato de texto
                    relatorio = f"""
RELAT√ìRIO EXECUTIVO - AN√ÅLISE DE FROTA
Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}

RESUMO GERAL:
- Frotas Ativas: {total_frotas_ativas_insights}
- Gasto Total com Combust√≠vel: {formatar_brasileiro(gasto_total_combustivel_insights, 'R$ ')}
- Equipamentos com Alerta: {frotas_com_alerta_insights}

INSIGHTS:
{chr(10).join([f"- {insight.replace('**', '')}" for insight in insights])}

RECOMENDA√á√ïES:
{chr(10).join([f"- {rec}" for rec in recomendacoes])}

---
Relat√≥rio gerado automaticamente pelo sistema de gest√£o de frotas.
                    """
                    
                    # Bot√£o de download do relat√≥rio
                    st.download_button(
                        "üì• Download Relat√≥rio Executivo",
                        relatorio.encode('utf-8'),
                        "relatorio_executivo_frota.txt",
                        "text/plain"
                    )
                                
        if tab_manut is not None:
            with tab_manut:
                st.header("üõ†Ô∏è Controle de Manuten√ß√£o")
                
                if not plan_df.empty:
                    st.subheader("üö® Equipamentos com Alertas de Manuten√ß√£o")
                    df_com_alerta = plan_df[plan_df['Qualquer_Alerta'] == True].copy()
                    if not df_com_alerta.empty:
                        alert_cols = [col for col in df_com_alerta.columns if 'Alerta_' in col]
                        df_com_alerta['Alertas'] = df_com_alerta[alert_cols].apply(lambda row: ', '.join([col.replace('Alerta_', '') for col, val in row.items() if val is True]), axis=1)
                        display_cols = ['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Alertas']

                        df_alertas_display = df_com_alerta[display_cols].copy()
                        df_alertas_display['Leitura_Atual'] = df_alertas_display['Leitura_Atual'].apply(
                            lambda x: formatar_brasileiro_int(x) if pd.notna(x) else ''
                        )
                        st.dataframe(
                            df_alertas_display,
                            column_config={"Cod_Equip": st.column_config.NumberColumn(format="%d")}
                        )

                    else:
                        st.success("‚úÖ Nenhum equipamento com alerta no momento.")

                    with st.expander("Ver Plano de Manuten√ß√£o Completo (Quanto Falta)"):
                        cols_to_show = ['Cod_Equip', 'Equipamento', 'Leitura_Atual']
                        for col in plan_df.columns:
                            if 'Restante_' in col and plan_df[col].notna().any():
                                cols_to_show.append(col)
                        
                        df_plano_display = plan_df[cols_to_show].copy()
                        for col in df_plano_display.columns:
                            if col not in ['Cod_Equip', 'Equipamento'] and pd.api.types.is_numeric_dtype(df_plano_display[col]):
                                df_plano_display[col] = df_plano_display[col].apply(
                                    lambda x: formatar_brasileiro_int(x) if pd.notna(x) else ''
                                )
                        st.dataframe(
                            df_plano_display,
                            column_config={"Cod_Equip": st.column_config.NumberColumn(format="%d")}
                        )

                else:
                    st.info("N√£o h√° dados suficientes para gerar o plano de manuten√ß√£o.")

                st.markdown("---")
                st.subheader("üõ†Ô∏è Controle de Manuten√ß√£o por Componentes")

                if not plan_df.empty:
                    df_com_alerta = plan_df[plan_df['Qualquer_Alerta'] == True].copy()
                    
                    st.subheader("üö® Equipamentos com Alertas de Manuten√ß√£o")
                    if not df_com_alerta.empty:
                        df_com_alerta['Alertas'] = df_com_alerta['Alertas'].apply(lambda x: ', '.join(x))
                        display_cols = ['Cod_Equip', 'Equipamento', 'Leitura_Atual', 'Unidade', 'Alertas']
                        st.dataframe(df_com_alerta[display_cols])
                    else:
                        st.success("‚úÖ Nenhum equipamento com alerta no momento.")

                    with st.expander("Ver Plano de Manuten√ß√£o Completo (Quanto Falta)"):
                        display_cols_full = ['Cod_Equip', 'Equipamento', 'Leitura_Atual']
                        restante_cols = [col for col in plan_df.columns if 'Restante_' in col]
                        st.dataframe(plan_df[display_cols_full + restante_cols])
                else:
                    st.info("N√£o h√° dados suficientes para gerar o plano de manuten√ß√£o.")

                st.markdown("---")
                st.subheader("üìù Registrar Manuten√ß√£o de Componente Realizada")

                with st.form("form_add_comp_service", clear_on_submit=True):
                    equip_label = st.selectbox(
                        "Selecione o Equipamento",
                        options=df_frotas.sort_values("label")["label"],
                        key="add_servico_equip"
                    )

                    componentes_disponiveis = []
                    componente_info = {}
                    if equip_label:
                        cod_equip_selecionado = int(equip_label.split(" - ")[0])
                        classe_selecionada = df_frotas.loc[df_frotas['Cod_Equip'] == cod_equip_selecionado, 'Classe_Operacional'].iloc[0]
                        regras_classe = df_comp_regras[df_comp_regras['classe_operacional'] == classe_selecionada]
                        if not regras_classe.empty:
                            componentes_disponiveis = regras_classe['nome_componente'].tolist()
                            # Criar dicion√°rio com informa√ß√µes dos componentes
                            for _, regra in regras_classe.iterrows():
                                componente_info[regra['nome_componente']] = {
                                    'intervalo': regra['intervalo_padrao'],
                                    'lubrificante_id': regra.get('lubrificante_id'),
                                    'tipo_manutencao': regra.get('tipo_manutencao', 'Troca')
                                }
                    
                    componente_servico = st.selectbox("Componente que recebeu manuten√ß√£o", options=componentes_disponiveis)
                    
                    # Mostrar informa√ß√µes do componente selecionado
                    if componente_servico and componente_servico in componente_info:
                        info = componente_info[componente_servico]
                        st.info(f"**Componente:** {componente_servico} | **Intervalo:** {info['intervalo']} | **Tipo:** {info['tipo_manutencao']}")
                        
                        # Buscar informa√ß√µes do lubrificante se existir
                        if info['lubrificante_id']:
                            conn = sqlite3.connect(DB_PATH)
                            df_lub = pd.read_sql("SELECT nome, viscosidade, quantidade_estoque, unidade FROM lubrificantes WHERE id = ?", conn, params=(info['lubrificante_id'],))
                            conn.close()
                            if not df_lub.empty:
                                lub = df_lub.iloc[0]
                                estoque_atual = lub.get('quantidade_estoque', 0)
                                unidade = lub.get('unidade', 'L')
                                
                                # Determinar cor do estoque
                                if estoque_atual > 10:
                                    cor_estoque = "üü¢"
                                elif estoque_atual > 3:
                                    cor_estoque = "üü°"
                                else:
                                    cor_estoque = "üî¥"
                                
                                st.info(f"**Lubrificante associado:** {lub['nome']} ({lub['viscosidade']}) | **Estoque:** {cor_estoque} {estoque_atual} {unidade}")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        data_servico = st.date_input("Data do Servi√ßo")
                        hod_hor_servico = st.number_input("Leitura no Momento do Servi√ßo", min_value=0.0, format="%.2f")
                    
                    with col2:
                        # Tipo de servi√ßo baseado na configura√ß√£o do componente
                        tipo_servico_opcoes = []
                        if componente_servico and componente_servico in componente_info:
                            tipo_config = componente_info[componente_servico]['tipo_manutencao']
                            if tipo_config == "Troca":
                                tipo_servico_opcoes = ["Troca"]
                            elif tipo_config == "Remonta":
                                tipo_servico_opcoes = ["Remonta"]
                            elif tipo_config == "Ambos":
                                tipo_servico_opcoes = ["Troca", "Remonta"]
                        else:
                            tipo_servico_opcoes = ["Troca", "Remonta"]
                        
                        tipo_servico = st.selectbox("Tipo de Servi√ßo", options=tipo_servico_opcoes)
                        
                        # Lubrificante utilizado (se aplic√°vel)
                        lubrificante_utilizado = None
                        if componente_servico and componente_servico in componente_info and info['lubrificante_id']:
                            conn = sqlite3.connect(DB_PATH)
                            df_lub = pd.read_sql("SELECT nome, quantidade_estoque, unidade FROM lubrificantes WHERE id = ?", conn, params=(info['lubrificante_id'],))
                            conn.close()
                            if not df_lub.empty:
                                lub = df_lub.iloc[0]
                                lubrificante_utilizado = lub['nome']
                                estoque_atual = lub.get('quantidade_estoque', 0)
                                unidade = lub.get('unidade', 'L')
                                
                                # Determinar cor do estoque
                                if estoque_atual > 10:
                                    cor_estoque = "üü¢"
                                elif estoque_atual > 3:
                                    cor_estoque = "üü°"
                                else:
                                    cor_estoque = "üî¥"
                                
                                st.info(f"**Lubrificante:** {lubrificante_utilizado} | **Estoque:** {cor_estoque} {estoque_atual} {unidade}")
                                
                                # Aviso se estoque baixo
                                if estoque_atual <= 3:
                                    st.warning(f"‚ö†Ô∏è **Estoque baixo!** Considere repor o lubrificante '{lubrificante_utilizado}'")
                    
                    observacoes = st.text_area("Observa√ß√µes (opcional)", placeholder="Detalhes do servi√ßo realizado...")

                    if st.form_submit_button("Salvar Manuten√ß√£o de Componente"):
                        if equip_label and componente_servico:
                            cod_equip = int(equip_label.split(" - ")[0])
                            
                            # Usar a nova fun√ß√£o avan√ßada
                            success, message = add_component_service_advanced(
                                cod_equip, 
                                componente_servico, 
                                data_servico.strftime("%Y-%m-%d"), 
                                hod_hor_servico, 
                                tipo_servico, 
                                lubrificante_utilizado, 
                                observacoes
                            )
                            
                            if success:
                                st.success(f"Manuten√ß√£o do componente '{componente_servico}' para '{equip_label}' registrada com sucesso!")
                                
                                # Atualizar estoque de lubrificante se aplic√°vel
                                if lubrificante_utilizado and tipo_servico in ["Troca", "Remonta"]:
                                    try:
                                        conn = sqlite3.connect(DB_PATH)
                                        cursor = conn.cursor()
                                        
                                        # Buscar a capacidade do componente
                                        cursor.execute(
                                            "SELECT capacidade_litros FROM componentes_regras WHERE nome_componente = ? AND classe_operacional = (SELECT Classe_Operacional FROM frotas WHERE Cod_Equip = ?)",
                                            (componente_servico, cod_equip)
                                        )
                                        result = cursor.fetchone()
                                        capacidade = result[0] if result and result[0] else 1.0  # Padr√£o 1L se n√£o definido
                                        
                                        # Reduzir estoque do lubrificante baseado na capacidade
                                        cursor.execute(
                                            "UPDATE lubrificantes SET quantidade_estoque = quantidade_estoque - ? WHERE nome = ?",
                                            (capacidade, lubrificante_utilizado)
                                        )
                                        conn.commit()
                                        conn.close()
                                        # Buscar o novo estoque ap√≥s a atualiza√ß√£o
                                        cursor.execute(
                                            "SELECT quantidade_estoque, unidade FROM lubrificantes WHERE nome = ?",
                                            (lubrificante_utilizado,)
                                        )
                                        result_estoque = cursor.fetchone()
                                        novo_estoque = result_estoque[0] if result_estoque else 0
                                        unidade_estoque = result_estoque[1] if result_estoque else 'L'
                                        
                                        # Determinar cor do novo estoque
                                        if novo_estoque > 10:
                                            cor_novo_estoque = "üü¢"
                                        elif novo_estoque > 3:
                                            cor_novo_estoque = "üü°"
                                        else:
                                            cor_novo_estoque = "üî¥"
                                        
                                        st.info(f"Estoque do lubrificante '{lubrificante_utilizado}' atualizado ({tipo_servico}) - {capacidade}L consumidos. **Novo estoque:** {cor_novo_estoque} {novo_estoque} {unidade_estoque}")
                                        
                                        # Aviso se estoque ficou baixo ap√≥s a opera√ß√£o
                                        if novo_estoque <= 3:
                                            st.warning(f"‚ö†Ô∏è **Aten√ß√£o!** Estoque do lubrificante '{lubrificante_utilizado}' est√° baixo ({novo_estoque} {unidade_estoque}). Considere repor.")
                                    except Exception as e:
                                        st.warning(f"N√£o foi poss√≠vel atualizar o estoque do lubrificante: {e}")
                                
                                # Atualizar cache para refletir mudan√ßas
                                st.cache_data.clear()
                                rerun_keep_tab("üõ†Ô∏è Controle de Manuten√ß√£o")
                            else:
                                st.error(f"Erro ao salvar manuten√ß√£o: {message}")
                        else:
                            st.warning("Por favor, selecione um equipamento e um componente.")
                                        
                        st.markdown("---")
                        st.subheader("üìÖ Previs√£o de Pr√≥ximas Manuten√ß√µes")
                    
                df_previsao = prever_manutencoes(df_frotas, df, plan_df)

                if not df_previsao.empty:
                        # Filtra para mostrar apenas as previs√µes para os pr√≥ximos 90 dias
                        st.dataframe(df_previsao[df_previsao['Dias Restantes'] <= 90])
                else:
                        st.info("N√£o h√° dados suficientes para gerar uma previs√£o de manuten√ß√µes.")
                        
            # APAGUE O CONTE√öDO DA SUA "with tab_checklists:" E SUBSTITUA-O POR ESTE BLOCO

        if tab_checklists is not None:
            with tab_checklists:
                st.header("‚úÖ Checklists de Verifica√ß√£o Di√°ria")
                st.info("Esta aba mostra os checklists que, de acordo com as regras, precisam de ser preenchidos hoje.")

                hoje = date.today()
                dia_par = hoje.day % 2 == 0
                
                frotas_a_verificar = df_frotas[df_frotas['ATIVO'] == 'ATIVO']
                regras_a_aplicar = get_checklist_rules()

                if regras_a_aplicar.empty:
                    st.warning("Nenhum modelo de checklist foi configurado. Por favor, v√° √† aba 'Configura√ß√µes' para criar um.")
                else:
                    checklists_para_hoje = False
                    for _, regra in regras_a_aplicar.iterrows():
                        regra_aplica_hoje = False
                        # L√≥gica para determinar se o checklist se aplica hoje
                        if regra['frequencia'] == 'Di√°rio':
                            regra_aplica_hoje = True
                        elif regra['frequencia'] == 'Dias Pares' and dia_par:
                            regra_aplica_hoje = True
                        elif regra['frequencia'] == 'Dias √çmpares' and not dia_par:
                            regra_aplica_hoje = True
                        # Adicionar aqui a l√≥gica de 'Dia Sim/N√£o' se necess√°rio no futuro

                        if regra_aplica_hoje:
                            checklists_para_hoje = True
                            exp_open_key = st.session_state.get('open_expander_checklists')
                            with st.expander(
                                f"**{regra['titulo_checklist']}** - Turno: {regra['turno']}",
                                expanded=(exp_open_key == f"regra_{regra['id_regra']}"
                            ) ):
                                veiculos_da_classe = frotas_a_verificar[frotas_a_verificar['Classe_Operacional'] == regra['classe_operacional']]
                                itens_checklist = get_checklist_items(regra['id_regra'])

                                if veiculos_da_classe.empty:
                                    st.write("Nenhum ve√≠culo ativo encontrado para esta classe.")
                                    continue
                                if itens_checklist.empty:
                                    st.warning("Este checklist n√£o tem itens configurados. Adicione itens na aba 'Configura√ß√µes'.")
                                    continue

                                for _, veiculo in veiculos_da_classe.iterrows():
                                    st.subheader(f"Ve√≠culo: {veiculo['label']}")
                                    
                                    ja_preenchido = df_checklist_historico[
                                        (df_checklist_historico['Cod_Equip'] == veiculo['Cod_Equip']) &
                                        (df_checklist_historico['data_preenchimento'] == hoje.strftime('%Y-%m-%d')) &
                                        (df_checklist_historico['turno'] == regra['turno'])
                                    ].shape[0] > 0

                                    if ja_preenchido:
                                        st.success("‚úîÔ∏è Checklist j√° preenchido hoje para este turno.")
                                    else:
                                        with st.form(f"form_{regra['id_regra']}_{veiculo['Cod_Equip']}", clear_on_submit=True):
                                            status_itens = {}
                                            for _, item in itens_checklist.iterrows():
                                                status_itens[item['nome_item']] = st.selectbox(
                                                    item['nome_item'],
                                                    options=["Selecione...", "OK", "Com Problema"],
                                                    key=f"item_{item['id_item']}_{veiculo['Cod_Equip']}"
                                                )
                                            
                                            if st.form_submit_button("Salvar Checklist"):
                                                if any(v == "Selecione..." for v in status_itens.values()):
                                                    st.warning("Selecione uma op√ß√£o para todos os itens antes de salvar.")
                                                else:
                                                    status_geral = "Com Problema" if "Com Problema" in status_itens.values() else "OK"
                                                    save_checklist_history(veiculo['Cod_Equip'], regra['titulo_checklist'], hoje.strftime('%Y-%m-%d'), regra['turno'], status_geral)
                                                    st.success("Checklist salvo com sucesso!")
                                                    st.session_state['open_expander_checklists'] = f"regra_{regra['id_regra']}"
                                                    rerun_keep_tab("‚úÖ Checklists Di√°rios")
                    
                    if not checklists_para_hoje:
                        st.info("Nenhum checklist agendado para hoje.")

                                # bloco duplicado removido
                    
        if st.session_state.role == 'admin' and tab_gerir_lanc is not None:
            with tab_gerir_lanc:
                        st.header("‚öôÔ∏è Gerir Lan√ßamentos de Abastecimento e Manuten√ß√£o")
                        acao = st.radio(
                            "Selecione a a√ß√£o que deseja realizar:",
                            ("Adicionar Abastecimento", "Editar Lan√ßamento", "Excluir Lan√ßamento"),
                            horizontal=True,
                            key="acao_lancamentos"
                        )
                        if acao == "Adicionar Abastecimento":
                            st.subheader("‚ûï Adicionar Novo Abastecimento")
                            with st.form("form_abastecimento", clear_on_submit=True):
                                equip_selecionado_label = st.selectbox(
                                    "Selecione o Equipamento", 
                                    options=df_frotas.sort_values("label")["label"],
                                    key="add_abast_equip"
                                )
                                # Sele√ß√£o de motorista (matr√≠cula)
                                df_mot_all = get_all_motoristas()
                                matriculas_opts = [m for m in df_mot_all['matricula'].astype(str).tolist()] if not df_mot_all.empty else []
                                matricula_sel = st.selectbox("Matr√≠cula do Motorista", options=[""] + matriculas_opts)

                                data_abastecimento = st.date_input("Data do Abastecimento")
                                qtde_litros = st.number_input("Quantidade de Litros", min_value=0.01, format="%.2f")
                                hod_hor_atual = st.number_input("Hod√¥metro/Hor√≠metro Atual", min_value=0.01, format="%.2f")
                                safra = st.text_input("Safra (Ex: 2023/2024)")

                                submitted = st.form_submit_button("Salvar Abastecimento")

                                if submitted:
                                    if not all([equip_selecionado_label, data_abastecimento, qtde_litros, hod_hor_atual, safra]):
                                        st.warning("Por favor, preencha todos os campos.")
                                    else:
                                        cod_equip = int(equip_selecionado_label.split(" - ")[0])
                                        
                                        # Usa o nome da coluna padronizado ('Classe_Operacional' com underscore)
                                        classe_op = df_frotas.loc[df_frotas['Cod_Equip'] == cod_equip, 'Classe_Operacional'].iloc[0]

                                        cod_pessoa_val = None
                                        if matricula_sel:
                                            df_mot_sel = df_mot_all[df_mot_all['matricula'].astype(str) == str(matricula_sel)] if not df_mot_all.empty else pd.DataFrame()
                                            if not df_mot_sel.empty:
                                                cod_pessoa_val = df_mot_sel.iloc[0].get('codigo_pessoa')

                                        dados_novos = {
                                            'cod_equip': cod_equip,
                                            'data': data_abastecimento.strftime("%Y-%m-%d %H:%M:%S"),
                                            'qtde_litros': qtde_litros,
                                            'hod_hor_atual': hod_hor_atual,
                                            'safra': safra,
                                            'mes': data_abastecimento.month,
                                            'classe_operacional': classe_op,
                                            'matricula': matricula_sel if matricula_sel else None,
                                            'cod_pessoa': cod_pessoa_val
                                        }

                                        if inserir_abastecimento(DB_PATH, dados_novos):
                                            st.success("Abastecimento salvo com sucesso!")
                                            rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")

                        elif acao == "Excluir Lan√ßamento":
                                    st.subheader("üóëÔ∏è Excluir um Lan√ßamento")
                                    
                                    tipo_exclusao = st.radio("O que deseja excluir?", ("Abastecimento", "Manuten√ß√£o", "Manuten√ß√£o de Componentes"), horizontal=True, key="delete_choice")
                                    
                                    if tipo_exclusao == "Abastecimento":
                                        df_para_excluir = df.sort_values(by="Data", ascending=False).copy()
                                        df_para_excluir['label_exclusao'] = (
                                            df_para_excluir['Data'].dt.strftime('%d/%m/%Y') + " | Frota: " +
                                            df_para_excluir['Cod_Equip'].astype(str) + " - " +
                                            df_para_excluir['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                            df_para_excluir['Qtde Litros'].apply(lambda x: f"{x:.2f}".replace('.',',')) + " L | " +
                                            df_para_excluir['Hod_Hor_Atual'].apply(lambda x: formatar_brasileiro_int(x)) + " h/km"
                                        )
            
                                        # Adiciona um mapeamento de label para rowid para encontrar o registro certo
                                        map_label_to_rowid = pd.Series(df_para_excluir.rowid.values, index=df_para_excluir.label_exclusao).to_dict()
            
                                        registro_selecionado_label = st.selectbox(
                                            "Selecione o abastecimento a ser exclu√≠do (mais recentes primeiro)",
                                            options=df_para_excluir['label_exclusao']
                                        )
                                        
                                        if registro_selecionado_label:
                                            rowid_para_excluir = map_label_to_rowid[registro_selecionado_label]
                                            
                                            st.warning("**Aten√ß√£o:** Voc√™ est√° prestes a excluir o seguinte registro. Esta a√ß√£o n√£o pode ser desfeita.")
                                            
                                            # Mostra os detalhes do registro selecionado
                                            registro_detalhes = df[df['rowid'] == rowid_para_excluir]
                                            st.dataframe(registro_detalhes[['Data', 'DESCRICAO_EQUIPAMENTO', 'Qtde Litros', 'Hod_Hor_Atual']])
            
                                            if st.button("Confirmar Exclus√£o", type="primary"):
                                                if excluir_abastecimento(DB_PATH, rowid_para_excluir):
                                                    st.success("Registro exclu√≠do com sucesso!")
                                                    # Invalidar cache para atualizar contadores
                                                    st.cache_data.clear()
                                                    rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")
                                    
                                    elif tipo_exclusao == "Manuten√ß√£o":
                                        st.subheader("üóëÔ∏è Excluir Manuten√ß√£o")
                                        
                                        # Garantir que df_manutencoes tenha rowid
                                        if 'rowid' not in df_manutencoes.columns:
                                            df_manutencoes = df_manutencoes.reset_index().rename(columns={'index': 'rowid'})
                                        
                                        df_manut_para_excluir = df_manutencoes.copy()
                                        df_manut_para_excluir['Data'] = pd.to_datetime(df_manut_para_excluir['Data'], errors='coerce')
                                        df_manut_para_excluir = df_manut_para_excluir.sort_values(by="Data", ascending=False)
                                        
                                        # Adiciona descri√ß√£o do equipamento
                                        df_frotas_unique = df_frotas.drop_duplicates(subset=['Cod_Equip'], keep='first')
                                        desc_map = df_frotas_unique.set_index('Cod_Equip')['DESCRICAO_EQUIPAMENTO']
                                        df_manut_para_excluir['DESCRICAO_EQUIPAMENTO'] = df_manut_para_excluir['Cod_Equip'].map(desc_map).fillna('N/A')
                                        
                                        df_manut_para_excluir['label_exclusao'] = (
                                            df_manut_para_excluir['Data'].dt.strftime('%d/%m/%Y') + " | Frota: " +
                                            df_manut_para_excluir['Cod_Equip'].astype(str) + " - " +
                                            df_manut_para_excluir['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                            df_manut_para_excluir['Tipo_Servico'] + " | " +
                                            df_manut_para_excluir['Hod_Hor_No_Servico'].apply(lambda x: formatar_brasileiro_int(x)) + " h/km"
                                        )
                                        
                                        map_label_to_rowid = pd.Series(df_manut_para_excluir.rowid.values, index=df_manut_para_excluir.label_exclusao).to_dict()
                                        
                                        registro_selecionado_label = st.selectbox(
                                            "Selecione a manuten√ß√£o a ser exclu√≠da (mais recentes primeiro)",
                                            options=df_manut_para_excluir['label_exclusao']
                                        )
                                        
                                        if registro_selecionado_label:
                                            rowid_para_excluir = map_label_to_rowid[registro_selecionado_label]
                                            
                                            st.warning("**Aten√ß√£o:** Voc√™ est√° prestes a excluir o seguinte registro. Esta a√ß√£o n√£o pode ser desfeita.")
                                            
                                            registro_detalhes = df_manut_para_excluir[df_manut_para_excluir['rowid'] == rowid_para_excluir]
                                            st.dataframe(registro_detalhes[['Data', 'DESCRICAO_EQUIPAMENTO', 'Tipo_Servico', 'Hod_Hor_No_Servico']])
            
                                            if st.button("Confirmar Exclus√£o", type="primary"):
                                                if excluir_manutencao(DB_PATH, rowid_para_excluir):
                                                    st.success("Manuten√ß√£o exclu√≠da com sucesso!")
                                                    # Invalidar cache para atualizar contadores
                                                    st.cache_data.clear()
                                                    rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")
                                    
                                    elif tipo_exclusao == "Manuten√ß√£o de Componentes":
                                        st.subheader("üóëÔ∏è Excluir Manuten√ß√£o de Componentes")
                                        
                                        df_comp_para_excluir = df_comp_historico.copy()
                                        
                                        if df_comp_para_excluir.empty:
                                            st.warning("Nenhuma manuten√ß√£o de componente encontrada.")
                                        else:
                                            # Garantir que df_comp_historico tenha rowid
                                            if 'rowid' not in df_comp_para_excluir.columns:
                                                df_comp_para_excluir = df_comp_para_excluir.reset_index().rename(columns={'index': 'rowid'})
                                            
                                            df_comp_para_excluir['Data'] = pd.to_datetime(df_comp_para_excluir['Data'], errors='coerce')
                                            df_comp_para_excluir = df_comp_para_excluir.sort_values(by="Data", ascending=False)
                                            
                                            # Adiciona descri√ß√£o do equipamento
                                            df_frotas_unique = df_frotas.drop_duplicates(subset=['Cod_Equip'], keep='first')
                                            desc_map = df_frotas_unique.set_index('Cod_Equip')['DESCRICAO_EQUIPAMENTO']
                                            df_comp_para_excluir['DESCRICAO_EQUIPAMENTO'] = df_comp_para_excluir['Cod_Equip'].map(desc_map).fillna('N/A')
                                            
                                            df_comp_para_excluir['label_exclusao'] = (
                                                df_comp_para_excluir['Data'].dt.strftime('%d/%m/%Y') + " | Frota: " +
                                                df_comp_para_excluir['Cod_Equip'].astype(str) + " - " +
                                                df_comp_para_excluir['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                                df_comp_para_excluir['nome_componente'] + " | " +
                                                df_comp_para_excluir['Observacoes'].fillna('N/A')
                                            )
                                            
                                            map_label_to_rowid = pd.Series(df_comp_para_excluir.rowid.values, index=df_comp_para_excluir.label_exclusao).to_dict()
                                            
                                            registro_selecionado_label = st.selectbox(
                                                "Selecione a manuten√ß√£o de componente a ser exclu√≠da (mais recentes primeiro)",
                                                options=df_comp_para_excluir['label_exclusao']
                                            )
                                            
                                            if registro_selecionado_label:
                                                rowid_para_excluir = map_label_to_rowid[registro_selecionado_label]
                                                
                                                st.warning("**Aten√ß√£o:** Voc√™ est√° prestes a excluir o seguinte registro. Esta a√ß√£o n√£o pode ser desfeita.")
                                                
                                                registro_detalhes = df_comp_para_excluir[df_comp_para_excluir['rowid'] == rowid_para_excluir]
                                                st.dataframe(registro_detalhes[['Data', 'DESCRICAO_EQUIPAMENTO', 'nome_componente', 'Observacoes']])
                
                                                if st.button("Confirmar Exclus√£o", type="primary"):
                                                    # Obter os dados do registro selecionado
                                                    registro_detalhes = df_comp_para_excluir[df_comp_para_excluir['rowid'] == rowid_para_excluir].iloc[0]
                                                    
                                                    # Converter a data para string se for Timestamp
                                                    data_str = str(registro_detalhes['Data'])
                                                    if hasattr(registro_detalhes['Data'], 'strftime'):
                                                        data_str = registro_detalhes['Data'].strftime('%Y-%m-%d')
                                                    
                                                    if excluir_manutencao_componente(
                                                        DB_PATH, 
                                                        registro_detalhes['Cod_Equip'],
                                                        registro_detalhes['nome_componente'],
                                                        data_str,
                                                        registro_detalhes['Hod_Hor_No_Servico']
                                                    ):
                                                        st.success("Manuten√ß√£o de componente exclu√≠da com sucesso!")
                                                        # Invalidar cache para atualizar contadores
                                                        force_cache_clear()
                                                        rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")
                                                
                        elif acao == "Editar Lan√ßamento":
                                    st.subheader("‚úèÔ∏è Editar um Lan√ßamento")
                                    tipo_edicao = st.radio("O que deseja editar?", ("Abastecimento", "Manuten√ß√£o", "Manuten√ß√£o de Componentes"), horizontal=True, key="edit_choice")
            
                                    if tipo_edicao == "Abastecimento":
                                        df_abast_edit = df.sort_values(by="Data", ascending=False).copy()
                                        df_abast_edit['label_edit'] = (
                                            df_abast_edit['Data'].dt.strftime('%d/%m/%Y') + " | Frota: " +
                                            df_abast_edit['Cod_Equip'].astype(str) + " - " +
                                            df_abast_edit['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                            df_abast_edit['Qtde Litros'].apply(lambda x: f"{x:.2f}".replace('.',',')) + " L | " +
                                            df_abast_edit['Hod_Hor_Atual'].apply(lambda x: formatar_brasileiro_int(x)) + " h/km"
                                        )
                                        map_label_to_rowid = pd.Series(df_abast_edit.rowid.values, index=df_abast_edit.label_edit).to_dict()
                                        label_selecionado = st.selectbox("Selecione o abastecimento para editar", options=df_abast_edit['label_edit'])
                                        
                                        if label_selecionado:
                                            rowid_selecionado = map_label_to_rowid[label_selecionado]
                                            dados_atuais = df[df['rowid'] == rowid_selecionado].iloc[0]
                                            with st.form("form_edit_abastecimento"):
                                                st.write(f"**Editando:** {label_selecionado}")

                                                # Encontra o √≠ndice do equipamento atual para pr√©-selecionar no selectbox
                                                lista_labels_frotas = df_frotas['label'].tolist()
                                                index_equip_atual = lista_labels_frotas.index(df_frotas[df_frotas['Cod_Equip'] == dados_atuais['Cod_Equip']]['label'].iloc[0])

                                                # --- Campos do formul√°rio pr√©-preenchidos ---
                                                novo_equip_label = st.selectbox(
                                                    "Equipamento", 
                                                    options=lista_labels_frotas, 
                                                    index=index_equip_atual
                                                )
                                                # Motorista: matr√≠cula e nome (mostra matr√≠cula na UI e guarda ambos)
                                                df_mot_all = get_all_motoristas()
                                                matriculas_opts = [m for m in df_mot_all['matricula'].astype(str).tolist()] if not df_mot_all.empty else []
                                                matricula_sel = st.selectbox("Matr√≠cula do Motorista", options=[""] + matriculas_opts)

                                                nova_data = st.date_input(
                                                    "Data", 
                                                    value=pd.to_datetime(dados_atuais['Data']).date()
                                                )
                                                nova_qtde = st.number_input(
                                                    "Qtde Litros", 
                                                    value=float(dados_atuais['Qtde Litros']), 
                                                    format="%.2f"
                                                )
                                                novo_hod = st.number_input(
                                                    "Hod./Hor. Atual", 
                                                    value=float(dados_atuais['Hod_Hor_Atual']), 
                                                    format="%.2f"
                                                )
                                                nova_safra = st.text_input(
                                                    "Safra", 
                                                    value=dados_atuais['Safra']
                                                )

                                            submitted = st.form_submit_button("Salvar Altera√ß√µes")
                                            if submitted:
                                                # map matricula -> cod_pessoa/nome
                                                cod_pessoa_val = None
                                                if matricula_sel:
                                                    df_mot_sel = df_mot_all[df_mot_all['matricula'].astype(str) == str(matricula_sel)] if not df_mot_all.empty else pd.DataFrame()
                                                    if not df_mot_sel.empty:
                                                        cod_pessoa_val = df_mot_sel.iloc[0].get('codigo_pessoa')
                                                dados_editados = {
                                                    'cod_equip': int(novo_equip_label.split(" - ")[0]),
                                                    'data': nova_data.strftime("%Y-%m-%d %H:%M:%S"), 
                                                    'qtde_litros': nova_qtde,
                                                    'hod_hor_atual': novo_hod,
                                                    'safra': nova_safra,
                                                    'matricula': matricula_sel if matricula_sel else None,
                                                    'cod_pessoa': cod_pessoa_val
                                                }
                                                if editar_abastecimento(DB_PATH, rowid_selecionado, dados_editados):
                                                    st.success("Abastecimento atualizado com sucesso!")
                                                    rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")

                                    if tipo_edicao == "Manuten√ß√£o":
                                        st.subheader("Editar Lan√ßamento de Manuten√ß√£o")

                                        # Garantir que df_manutencoes tenha rowid
                                        if 'rowid' not in df_manutencoes.columns:
                                            df_manutencoes = df_manutencoes.reset_index().rename(columns={'index': 'rowid'})

                                        # Usa o df_manutencoes original (preserva rowid)
                                        df_manut_edit = df_manutencoes.copy()

                                        # Garante que a coluna Data seja datetime
                                        df_manut_edit['Data'] = pd.to_datetime(df_manut_edit['Data'], errors='coerce')

                                        # Remove duplicatas de Cod_Equip no df_frotas para evitar erro no map
                                        df_frotas_unique = df_frotas.drop_duplicates(subset=['Cod_Equip'], keep='first')

                                        # Adiciona descri√ß√£o do equipamento via map
                                        desc_map = df_frotas_unique.set_index('Cod_Equip')['DESCRICAO_EQUIPAMENTO']
                                        df_manut_edit['DESCRICAO_EQUIPAMENTO'] = df_manut_edit['Cod_Equip'].map(desc_map).fillna('N/A')

                                        # Garantir que df_manut_edit tenha rowid
                                        if 'rowid' not in df_manut_edit.columns:
                                            if 'rowid_frota' in df_manut_edit.columns:
                                                df_manut_edit.rename(columns={'rowid_frota': 'rowid'}, inplace=True)
                                            else:
                                                df_manut_edit.reset_index(inplace=True)
                                                df_manut_edit.rename(columns={'index': 'rowid'}, inplace=True)

                                        # Ordena e cria os labels para sele√ß√£o
                                        df_manut_edit.sort_values(by="Data", ascending=False, inplace=True)
                                        df_manut_edit['label_edit'] = (
                                            df_manut_edit['Data'].dt.strftime('%d/%m/%Y') + " | Frota: " +
                                            df_manut_edit['Cod_Equip'].astype(str) + " - " +
                                            df_manut_edit['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                            df_manut_edit['Tipo_Servico'] + " | " +
                                            df_manut_edit['Hod_Hor_No_Servico'].apply(lambda x: formatar_brasileiro_int(x)) + " h/km"
                                        )

                                        # Cria o dicion√°rio de label -> rowid
                                        map_label_to_rowid = pd.Series(
                                            df_manut_edit['rowid'].values,
                                            index=df_manut_edit['label_edit']
                                        ).to_dict()

                                        # Selectbox para escolher manuten√ß√£o
                                        label_selecionado = st.selectbox(
                                            "Selecione a manuten√ß√£o para editar",
                                            options=df_manut_edit['label_edit'],
                                            key="manut_edit_select"
                                        )

                                        if label_selecionado:
                                            rowid_selecionado = map_label_to_rowid.get(label_selecionado)
                                            if rowid_selecionado is not None:
                                                dados_atuais = df_manutencoes[df_manutencoes['rowid'] == rowid_selecionado].iloc[0]

                                                with st.form("form_edit_manutencao"):
                                                    st.write(f"**Editando:** {label_selecionado}")

                                                    lista_labels_frotas = df_frotas.sort_values("label")['label'].tolist()
                                                    equip_atual = df_frotas[df_frotas['Cod_Equip'] == dados_atuais['Cod_Equip']]['label'].iloc[0]
                                                    index_equip_atual = lista_labels_frotas.index(equip_atual)

                                                    novo_equip_label = st.selectbox("Equipamento", options=lista_labels_frotas, index=index_equip_atual)

                                                    classe_selecionada = df_frotas[df_frotas['label'] == novo_equip_label]['Classe_Operacional'].iloc[0]
                                                    servicos_configurados = st.session_state.intervalos_por_classe.get(classe_selecionada, {}).get('servicos', {})
                                                    servicos_disponiveis = [info['nome'] for info in servicos_configurados.values()]

                                                    index_servico_atual = servicos_disponiveis.index(dados_atuais['Tipo_Servico']) if dados_atuais['Tipo_Servico'] in servicos_disponiveis else 0

                                                    novo_tipo_servico = st.selectbox("Tipo de Servi√ßo", options=servicos_disponiveis, index=index_servico_atual)
                                                    nova_data = st.date_input("Data", value=pd.to_datetime(dados_atuais['Data']).date())
                                                    novo_hod = st.number_input("Hod./Hor. no Servi√ßo", value=float(dados_atuais['Hod_Hor_No_Servico']), format="%.2f")

                                                    submitted = st.form_submit_button("Salvar Altera√ß√µes")
                                                    if submitted:
                                                        dados_editados = {
                                                            'cod_equip': int(novo_equip_label.split(" - ")[0]),
                                                            'data': nova_data.strftime("%Y-%m-%d"),
                                                            'tipo_servico': novo_tipo_servico,
                                                            'hod_hor_servico': novo_hod,
                                                        }
                                                        if editar_manutencao(DB_PATH, rowid_selecionado, dados_editados):
                                                            st.success("Manuten√ß√£o atualizada com sucesso!")
                                                            rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")

                                    if tipo_edicao == "Manuten√ß√£o de Componentes":
                                        st.subheader("Editar Lan√ßamento de Manuten√ß√£o de Componentes")

                                        # Carregar dados de componentes_historico
                                        df_comp_edit = df_comp_historico.copy()
                                        
                                        if df_comp_edit.empty:
                                            st.warning("Nenhuma manuten√ß√£o de componente encontrada.")
                                        else:
                                            # Garantir que df_comp_historico tenha rowid
                                            if 'rowid' not in df_comp_edit.columns:
                                                df_comp_edit = df_comp_edit.reset_index().rename(columns={'index': 'rowid'})

                                            # Garante que a coluna Data seja datetime
                                            df_comp_edit['Data'] = pd.to_datetime(df_comp_edit['Data'], errors='coerce')

                                            # Remove duplicatas de Cod_Equip no df_frotas para evitar erro no map
                                            df_frotas_unique = df_frotas.drop_duplicates(subset=['Cod_Equip'], keep='first')

                                            # Adiciona descri√ß√£o do equipamento via map
                                            desc_map = df_frotas_unique.set_index('Cod_Equip')['DESCRICAO_EQUIPAMENTO']
                                            df_comp_edit['DESCRICAO_EQUIPAMENTO'] = df_comp_edit['Cod_Equip'].map(desc_map).fillna('N/A')

                                            # Ordena e cria os labels para sele√ß√£o com informa√ß√µes melhoradas
                                            df_comp_edit.sort_values(by="Data", ascending=False, inplace=True)
                                            
                                            # Adicionar informa√ß√µes de tipo de servi√ßo e lubrificante se dispon√≠veis
                                            if 'tipo_servico' in df_comp_edit.columns:
                                                df_comp_edit['tipo_servico_info'] = df_comp_edit['tipo_servico'].fillna('N/A')
                                            else:
                                                df_comp_edit['tipo_servico_info'] = 'N/A'
                                            
                                            if 'lubrificante_utilizado' in df_comp_edit.columns:
                                                df_comp_edit['lubrificante_info'] = df_comp_edit['lubrificante_utilizado'].fillna('N/A')
                                            else:
                                                df_comp_edit['lubrificante_info'] = 'N/A'
                                            
                                            df_comp_edit['label_edit'] = (
                                                df_comp_edit['Data'].dt.strftime('%d/%m/%Y') + " | " +
                                                df_comp_edit['Cod_Equip'].astype(str) + " - " +
                                                df_comp_edit['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                                                df_comp_edit['nome_componente'] + " | " +
                                                df_comp_edit['tipo_servico_info'] + " | " +
                                                df_comp_edit['lubrificante_info']
                                            )

                                            # Cria o dicion√°rio de label -> rowid
                                            map_label_to_rowid = pd.Series(
                                                df_comp_edit['rowid'].values,
                                                index=df_comp_edit['label_edit']
                                            ).to_dict()

                                            # Selectbox para escolher manuten√ß√£o de componente
                                            label_selecionado = st.selectbox(
                                                "Selecione a manuten√ß√£o de componente para editar",
                                                options=df_comp_edit['label_edit'],
                                                key="comp_edit_select"
                                            )

                                            if label_selecionado:
                                                rowid_selecionado = map_label_to_rowid.get(label_selecionado)
                                                if rowid_selecionado is not None:
                                                    dados_atuais = df_comp_edit[df_comp_edit['rowid'] == rowid_selecionado].iloc[0]

                                                    with st.form("form_edit_comp"):
                                                        st.write(f"**Editando:** {label_selecionado}")

                                                        col1, col2 = st.columns(2)
                                                        
                                                        with col1:
                                                            lista_labels_frotas = df_frotas.sort_values("label")['label'].tolist()
                                                            equip_atual = df_frotas[df_frotas['Cod_Equip'] == dados_atuais['Cod_Equip']]['label'].iloc[0]
                                                            index_equip_atual = lista_labels_frotas.index(equip_atual)

                                                            novo_equip_label = st.selectbox("Equipamento", options=lista_labels_frotas, index=index_equip_atual)
                                                            novo_componente = st.text_input("Componente", value=dados_atuais['nome_componente'])
                                                            nova_data = st.date_input("Data", value=pd.to_datetime(dados_atuais['Data']).date())
                                                            novo_hod = st.number_input("Hod./Hor. no Servi√ßo", value=float(dados_atuais.get('Hod_Hor_No_Servico', 0)), format="%.2f")
                                                        
                                                        with col2:
                                                            # Tipo de servi√ßo
                                                            if 'tipo_servico' in dados_atuais:
                                                                tipo_servico_atual = dados_atuais.get('tipo_servico', 'Troca')
                                                                tipo_servico_opcoes = ["Troca", "Remonta"]
                                                                index_tipo = tipo_servico_opcoes.index(tipo_servico_atual) if tipo_servico_atual in tipo_servico_opcoes else 0
                                                                novo_tipo_servico = st.selectbox("Tipo de Servi√ßo", options=tipo_servico_opcoes, index=index_tipo)
                                                            else:
                                                                novo_tipo_servico = st.selectbox("Tipo de Servi√ßo", options=["Troca", "Remonta"], index=0)
                                                            
                                                            # Lubrificante utilizado
                                                            if 'lubrificante_utilizado' in dados_atuais:
                                                                lubrificante_atual = dados_atuais.get('lubrificante_utilizado', '')
                                                                novo_lubrificante = st.text_input("Lubrificante Utilizado", value=lubrificante_atual)
                                                            else:
                                                                novo_lubrificante = st.text_input("Lubrificante Utilizado", value="")
                                                            
                                                            nova_acao = st.text_input("Observa√ß√µes", value=dados_atuais.get('Observacoes', ''))

                                                        submitted = st.form_submit_button("Salvar Altera√ß√µes")
                                                        if submitted:
                                                            dados_editados = {
                                                                'cod_equip': int(novo_equip_label.split(" - ")[0]),
                                                                'componente': novo_componente,
                                                                'acao': nova_acao,
                                                                'data': nova_data.strftime("%Y-%m-%d"),
                                                                'hod_hor_servico': novo_hod,
                                                                'tipo_servico': novo_tipo_servico,
                                                                'lubrificante_utilizado': novo_lubrificante if novo_lubrificante else None,
                                                            }
                                                            if editar_manutencao_componente_advanced(DB_PATH, rowid_selecionado, dados_editados):
                                                                st.success("Manuten√ß√£o de componente atualizada com sucesso!")
                                                                rerun_keep_tab("‚öôÔ∏è Gerir Lan√ßamentos")

            if tab_gerir_lub is not None:
                with tab_gerir_lub:
                        st.header("üõ¢Ô∏è Gest√£o de Lubrificantes")
                        ensure_lubrificantes_schema()
                        conn = sqlite3.connect(DB_PATH)
                        df_lub = pd.read_sql("SELECT * FROM lubrificantes", conn)
                        df_mov = pd.read_sql("SELECT * FROM lubrificantes_movimentacoes", conn)
                        df_almoxarifados = get_almoxarifados()

                        # ----------- Visualiza√ß√£o do Estoque Atual -----------
                        st.subheader("Visualiza√ß√£o do Estoque Atual")

                        if not df_lub.empty:
                            # Separar por tipo
                            df_oleos = df_lub[df_lub['tipo'].str.lower() == '√≥leo']
                            df_graxas = df_lub[df_lub['tipo'].str.lower() == 'graxa']

                            col_o, col_g = st.columns(2)
                            with col_o:
                                st.markdown("#### Estoque de √ìleos")
                                if not df_oleos.empty:
                                    fig_oleos = px.bar(
                                        df_oleos,
                                        x='nome',
                                        y='quantidade_estoque',
                                        color='viscosidade',
                                        text='quantidade_estoque',
                                        title="√ìleos - Estoque Atual",
                                        labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': '√ìleo'}
                                    )
                                    st.plotly_chart(fig_oleos, use_container_width=True)
                                else:
                                    st.info("Nenhum √≥leo cadastrado.")

                            with col_g:
                                st.markdown("#### Estoque de Graxas")
                                if not df_graxas.empty:
                                    fig_graxas = px.bar(
                                        df_graxas,
                                        x='nome',
                                        y='quantidade_estoque',
                                        color='viscosidade',
                                        text='quantidade_estoque',
                                        title="Graxas - Estoque Atual",
                                        labels={'quantidade_estoque': 'Qtd. Estoque', 'nome': 'Graxa'}
                                    )
                                    st.plotly_chart(fig_graxas, use_container_width=True)
                                else:
                                    st.info("Nenhuma graxa cadastrada.")

                            # Pizza geral
                            df_lub['tipo'] = df_lub['tipo'].fillna('√≥leo')
                            fig_pizza = px.pie(
                                df_lub,
                                names='tipo',
                                values='quantidade_estoque',
                                title="Propor√ß√£o de Estoque: √ìleos vs Graxas"
                            )
                            st.plotly_chart(fig_pizza, use_container_width=True)

                            st.markdown("#### Tabela Detalhada do Estoque")
                            st.dataframe(df_lub)
                        else:
                            st.info("Nenhum lubrificante cadastrado.")

                        st.markdown("---")

                        # ----------- KPI de Estoque Distribu√≠do -----------
                        st.subheader("üìä KPI de Estoque Distribu√≠do por Almoxarifado")
                        
                        if not df_lub.empty and not df_almoxarifados.empty:
                            # Sele√ß√£o do lubrificante para an√°lise
                            lub_analise = st.selectbox(
                                "Selecione o lubrificante para an√°lise de estoque distribu√≠do:",
                                options=df_lub['nome'].tolist(),
                                key="kpi_lubrificante"
                            )
                            
                            if lub_analise:
                                id_lub_analise = df_lub[df_lub['nome'] == lub_analise]['id'].iloc[0]
                                df_estoque_distribuido = get_estoque_por_almoxarifado(id_lub_analise)
                                
                                if not df_estoque_distribuido.empty:
                                    # Calcular totais
                                    total_estoque = df_estoque_distribuido['quantidade'].sum()
                                    total_almoxarifados = len(df_estoque_distribuido)
                                    
                                    # M√©tricas principais
                                    col_kpi1, col_kpi2, col_kpi3, col_kpi4 = st.columns(4)
                                    
                                    with col_kpi1:
                                        st.metric("Estoque Total", f"{total_estoque:.1f} {df_estoque_distribuido['unidade'].iloc[0]}")
                                    
                                    with col_kpi2:
                                        st.metric("Almoxarifados", total_almoxarifados)
                                    
                                    with col_kpi3:
                                        almoxarifados_com_estoque = len(df_estoque_distribuido[df_estoque_distribuido['quantidade'] > 0])
                                        st.metric("Com Estoque", almoxarifados_com_estoque)
                                    
                                    with col_kpi4:
                                        almoxarifados_sem_estoque = total_almoxarifados - almoxarifados_com_estoque
                                        st.metric("Sem Estoque", almoxarifados_sem_estoque)
                                    
                                    # Gr√°fico de distribui√ß√£o
                                    col_grafico, col_tabela = st.columns([2, 1])
                                    
                                    with col_grafico:
                                        # Preparar dados para o gr√°fico
                                        df_grafico = df_estoque_distribuido[df_estoque_distribuido['quantidade'] > 0].copy()
                                        if not df_grafico.empty:
                                            df_grafico['percentual'] = (df_grafico['quantidade'] / total_estoque * 100).round(1)
                                            
                                            fig_distribuicao = px.pie(
                                                df_grafico,
                                                values='quantidade',
                                                names='almoxarifado',
                                                title=f"Distribui√ß√£o de Estoque: {lub_analise}",
                                                hover_data=['percentual', 'quantidade', 'unidade']
                                            )
                                            fig_distribuicao.update_traces(textposition='inside', textinfo='percent+label')
                                            st.plotly_chart(fig_distribuicao, use_container_width=True)
                                        else:
                                            st.info("Nenhum almoxarifado possui estoque deste lubrificante.")
                                    
                                    with col_tabela:
                                        st.write("**Detalhamento por Almoxarifado:**")
                                        
                                        # Preparar dados para tabela
                                        df_tabela = df_estoque_distribuido.copy()
                                        df_tabela['percentual'] = (df_tabela['quantidade'] / total_estoque * 100).round(1)
                                        df_tabela['quantidade_formatada'] = df_tabela['quantidade'].astype(str) + ' ' + df_tabela['unidade']
                                        
                                        # Determinar cor baseada na quantidade
                                        def get_color(quantidade, total):
                                            if total == 0:
                                                return "‚ö™"
                                            percentual = (quantidade / total * 100) if total > 0 else 0
                                            if percentual > 50:
                                                return "üü¢"
                                            elif percentual > 20:
                                                return "üü°"
                                            else:
                                                return "üî¥"
                                        
                                        df_tabela['indicador'] = df_tabela.apply(
                                            lambda row: get_color(row['quantidade'], total_estoque), axis=1
                                        )
                                        
                                        # Exibir tabela
                                        for _, row in df_tabela.iterrows():
                                            if row['quantidade'] > 0:
                                                st.write(f"{row['indicador']} **{row['almoxarifado']}**")
                                                st.write(f"   {row['quantidade_formatada']} ({row['percentual']}%)")
                                                if row['tipo'] == 'movel':
                                                    st.write(f"   üöõ {row['localizacao']}")
                                                else:
                                                    st.write(f"   üè¢ {row['localizacao']}")
                                                st.write("---")
                                            else:
                                                st.write(f"‚ö™ **{row['almoxarifado']}**")
                                                st.write(f"   Sem estoque")
                                                st.write("---")
                                    
                                    # Gr√°fico de barras por tipo de almoxarifado
                                    st.subheader("üìà An√°lise por Tipo de Almoxarifado")
                                    
                                    df_tipo = df_estoque_distribuido.groupby('tipo').agg({
                                        'quantidade': 'sum',
                                        'almoxarifado': 'count'
                                    }).reset_index()
                                    df_tipo['percentual'] = (df_tipo['quantidade'] / total_estoque * 100).round(1)
                                    
                                    col_barras1, col_barras2 = st.columns(2)
                                    
                                    with col_barras1:
                                        fig_barras_tipo = px.bar(
                                            df_tipo,
                                            x='tipo',
                                            y='quantidade',
                                            title="Estoque por Tipo de Almoxarifado",
                                            labels={'tipo': 'Tipo', 'quantidade': 'Quantidade'},
                                            text='quantidade'
                                        )
                                        st.plotly_chart(fig_barras_tipo, use_container_width=True)
                                    
                                    with col_barras2:
                                        fig_barras_contagem = px.bar(
                                            df_tipo,
                                            x='tipo',
                                            y='almoxarifado',
                                            title="Quantidade de Almoxarifados por Tipo",
                                            labels={'tipo': 'Tipo', 'almoxarifado': 'Quantidade'},
                                            text='almoxarifado'
                                        )
                                        st.plotly_chart(fig_barras_contagem, use_container_width=True)
                                    
                                else:
                                    st.warning("Nenhum almoxarifado cadastrado para an√°lise.")
                        else:
                            if df_lub.empty:
                                st.warning("Cadastre lubrificantes para visualizar o KPI de estoque distribu√≠do.")
                            if df_almoxarifados.empty:
                                st.warning("Cadastre almoxarifados para visualizar o KPI de estoque distribu√≠do.")

                        st.markdown("---")

                        # ----------- Registro de Entrada/Sa√≠da -----------
                        st.subheader("üì¶ Registrar Entrada/Sa√≠da de Lubrificantes")
                        
                        # Criar abas para entrada e sa√≠da
                        tab_entrada, tab_saida = st.tabs(["‚ûï Entrada (Compra)", "‚ûñ Sa√≠da (Consumo)"])
                        
                        if not df_lub.empty:
                            # Aba de Entrada (Compra)
                            with tab_entrada:
                                st.info("üí° **Entrada:** Registre compras e reposi√ß√µes de lubrificantes no almoxarifado.")
                                
                                with st.form("form_entrada_lub", clear_on_submit=True):
                                    col1, col2 = st.columns(2)
                                    
                                    with col1:
                                        lubs = df_lub['nome'].tolist()
                                        lub_sel = st.selectbox("Lubrificante", lubs, key="entrada_lub")
                                        
                                        # Mostrar estoque atual do lubrificante selecionado
                                        if lub_sel:
                                            lub_info = df_lub[df_lub['nome'] == lub_sel].iloc[0]
                                            estoque_atual = lub_info['quantidade_estoque']
                                            unidade = lub_info['unidade']
                                            
                                            # Determinar cor do estoque
                                            if estoque_atual > 10:
                                                cor_estoque = "üü¢"
                                            elif estoque_atual > 3:
                                                cor_estoque = "üü°"
                                            else:
                                                cor_estoque = "üî¥"
                                            
                                            st.info(f"**Estoque atual:** {cor_estoque} {estoque_atual} {unidade}")
                                        
                                        quantidade = st.number_input("Quantidade a adicionar", min_value=0.01, step=0.5, format="%.2f", key="entrada_qtd")
                                    
                                    with col2:
                                        data_mov = st.date_input("Data da compra", value=date.today(), key="entrada_data")
                                        obs_mov = st.text_area("Observa√ß√µes (ex: fornecedor, nota fiscal)", placeholder="Ex: Compra da Petrobras, NF 123456", key="entrada_obs")
                                    
                                    submitted_entrada = st.form_submit_button("‚ûï Registrar Entrada", type="primary")
                                    if submitted_entrada:
                                        id_lub = df_lub[df_lub['nome'] == lub_sel]['id'].iloc[0]
                                        ok, msg = movimentar_lubrificante(id_lub, "entrada", quantidade, data_mov.strftime("%Y-%m-%d"), None, obs_mov)
                                        if ok:
                                            st.success(f"‚úÖ {msg}")
                                            st.info(f"üì¶ **{quantidade} {unidade}** de '{lub_sel}' adicionados ao estoque.")
                                            st.rerun()
                                        else:
                                            st.error(f"‚ùå {msg}")
                            
                            # Aba de Sa√≠da (Consumo)
                            with tab_saida:
                                st.info("üí° **Sa√≠da:** Registre consumos manuais de lubrificantes (para casos n√£o registrados via manuten√ß√£o de componentes).")
                                
                                with st.form("form_saida_lub", clear_on_submit=True):
                                    col1, col2 = st.columns(2)
                                    
                                    with col1:
                                        lubs = df_lub['nome'].tolist()
                                        lub_sel = st.selectbox("Lubrificante", lubs, key="saida_lub")
                                        
                                        # Mostrar estoque atual do lubrificante selecionado
                                        if lub_sel:
                                            lub_info = df_lub[df_lub['nome'] == lub_sel].iloc[0]
                                            estoque_atual = lub_info['quantidade_estoque']
                                            unidade = lub_info['unidade']
                                            
                                            # Determinar cor do estoque
                                            if estoque_atual > 10:
                                                cor_estoque = "üü¢"
                                            elif estoque_atual > 3:
                                                cor_estoque = "üü°"
                                            else:
                                                cor_estoque = "üî¥"
                                            
                                            st.info(f"**Estoque atual:** {cor_estoque} {estoque_atual} {unidade}")
                                            
                                            # Aviso se estoque baixo
                                            if estoque_atual <= 3:
                                                st.warning(f"‚ö†Ô∏è **Estoque baixo!** Considere repor '{lub_sel}'")
                                        
                                        quantidade = st.number_input("Quantidade consumida", min_value=0.01, step=0.5, format="%.2f", max_value=estoque_atual if lub_sel else 999, key="saida_qtd")
                                    
                                    with col2:
                                        data_mov = st.date_input("Data do consumo", value=date.today(), key="saida_data")
                                        cod_equip = st.number_input("C√≥digo da M√°quina (opcional)", min_value=0, step=1, key="saida_equip")
                                        obs_mov = st.text_area("Observa√ß√µes (ex: motivo do consumo)", placeholder="Ex: Consumo manual, vazamento, etc.", key="saida_obs")
                                    
                                    submitted_saida = st.form_submit_button("‚ûñ Registrar Sa√≠da", type="secondary")
                                    if submitted_saida:
                                        id_lub = df_lub[df_lub['nome'] == lub_sel]['id'].iloc[0]
                                        ok, msg = movimentar_lubrificante(id_lub, "saida", quantidade, data_mov.strftime("%Y-%m-%d"), cod_equip if cod_equip > 0 else None, obs_mov)
                                        if ok:
                                            st.success(f"‚úÖ {msg}")
                                            st.info(f"üìâ **{quantidade} {unidade}** de '{lub_sel}' consumidos.")
                                            st.rerun()
                                        else:
                                            st.error(f"‚ùå {msg}")
                        else:
                            st.info("Cadastre lubrificantes para registrar movimenta√ß√µes.")

                        st.markdown("---")

                        # ----------- Hist√≥rico de Movimenta√ß√µes -----------
                        st.subheader("üìä Hist√≥rico de Movimenta√ß√µes")
                        
                        if not df_mov.empty:
                            df_mov['data'] = pd.to_datetime(df_mov['data'], errors='coerce')
                            df_mov = df_mov.sort_values('data', ascending=False)
                            # Junta nome do lubrificante
                            df_mov = df_mov.merge(df_lub[['id', 'nome', 'tipo', 'unidade']], left_on='id_lubrificante', right_on='id', how='left')
                            
                            # Criar abas para diferentes visualiza√ß√µes
                            tab_historico, tab_estatisticas = st.tabs(["üìã Hist√≥rico Detalhado", "üìà Estat√≠sticas"])
                            
                            with tab_historico:
                                # Filtros
                                col_filtro1, col_filtro2, col_filtro3 = st.columns(3)
                                
                                with col_filtro1:
                                    lub_filtro = st.selectbox("Filtrar por lubrificante", ["Todos"] + df_lub['nome'].tolist())
                                
                                with col_filtro2:
                                    tipo_filtro = st.selectbox("Filtrar por tipo", ["Todos", "entrada", "saida"])
                                
                                with col_filtro3:
                                    data_inicio = st.date_input("Data in√≠cio", value=df_mov['data'].min().date() if not df_mov.empty else date.today())
                                    data_fim = st.date_input("Data fim", value=df_mov['data'].max().date() if not df_mov.empty else date.today())
                                
                                # Aplicar filtros
                                df_filtrado = df_mov.copy()
                                
                                if lub_filtro != "Todos":
                                    df_filtrado = df_filtrado[df_filtrado['nome'] == lub_filtro]
                                
                                if tipo_filtro != "Todos":
                                    df_filtrado = df_filtrado[df_filtrado['tipo_x'] == tipo_filtro]
                                
                                df_filtrado = df_filtrado[
                                    (df_filtrado['data'].dt.date >= data_inicio) & 
                                    (df_filtrado['data'].dt.date <= data_fim)
                                ]
                                
                                # Preparar dados para exibi√ß√£o
                                df_mov_display = df_filtrado[['data', 'nome', 'tipo', 'tipo_x', 'quantidade', 'unidade', 'cod_equip', 'observacoes']].copy()
                                df_mov_display['data'] = df_mov_display['data'].dt.strftime('%d/%m/%Y')
                                df_mov_display['quantidade'] = df_mov_display['quantidade'].astype(str) + ' ' + df_mov_display['unidade']
                                df_mov_display = df_mov_display.rename(columns={
                                    'data': 'Data', 
                                    'nome': 'Lubrificante', 
                                    'tipo': 'Tipo Lubrificante', 
                                    'tipo_x': 'Movimenta√ß√£o', 
                                    'quantidade': 'Quantidade', 
                                    'cod_equip': 'M√°quina', 
                                    'observacoes': 'Observa√ß√µes'
                                })
                                
                                # Remover coluna unidade que j√° foi concatenada
                                df_mov_display = df_mov_display.drop('unidade', axis=1)
                                
                                st.dataframe(df_mov_display, use_container_width=True)
                                
                                # Resumo dos filtros aplicados
                                st.info(f"üìä **Resumo:** {len(df_filtrado)} movimenta√ß√µes encontradas no per√≠odo selecionado.")
                            
                            with tab_estatisticas:
                                # Estat√≠sticas gerais
                                col_stat1, col_stat2, col_stat3 = st.columns(3)
                                
                                with col_stat1:
                                    total_entradas = len(df_mov[df_mov['tipo_x'] == 'entrada'])
                                    total_saidas = len(df_mov[df_mov['tipo_x'] == 'saida'])
                                    st.metric("Total Entradas", total_entradas)
                                    st.metric("Total Sa√≠das", total_saidas)
                                
                                with col_stat2:
                                    qtd_entradas = df_mov[df_mov['tipo_x'] == 'entrada']['quantidade'].sum()
                                    qtd_saidas = df_mov[df_mov['tipo_x'] == 'saida']['quantidade'].sum()
                                    st.metric("Qtd. Total Entrada", f"{qtd_entradas:.1f}")
                                    st.metric("Qtd. Total Sa√≠da", f"{qtd_saidas:.1f}")
                                
                                with col_stat3:
                                    saldo = qtd_entradas - qtd_saidas
                                    st.metric("Saldo Geral", f"{saldo:.1f}")
                                
                                # Gr√°fico de movimenta√ß√µes por m√™s
                                if not df_mov.empty:
                                    df_mov['mes_ano'] = df_mov['data'].dt.to_period('M')
                                    mov_mensal = df_mov.groupby(['mes_ano', 'tipo_x'])['quantidade'].sum().reset_index()
                                    mov_mensal['mes_ano'] = mov_mensal['mes_ano'].astype(str)
                                    
                                    fig_mov = px.bar(
                                        mov_mensal,
                                        x='mes_ano',
                                        y='quantidade',
                                        color='tipo_x',
                                        title="Movimenta√ß√µes por M√™s",
                                        labels={'mes_ano': 'M√™s/Ano', 'quantidade': 'Quantidade', 'tipo_x': 'Tipo'},
                                        color_discrete_map={'entrada': 'green', 'saida': 'red'}
                                    )
                                    st.plotly_chart(fig_mov, use_container_width=True)
                        else:
                            st.info("Nenhuma movimenta√ß√£o registrada.")

                        st.markdown("---")

                        # ----------- Gest√£o de Almoxarifados -----------
                        st.subheader("üè¢ Gest√£o de Almoxarifados")
                        
                        # Criar abas para cadastro e visualiza√ß√£o
                        tab_cadastro_almox, tab_visualizar_almox = st.tabs(["‚ûï Cadastrar Almoxarifado", "üìã Almoxarifados Cadastrados"])
                        
                        # Aba de cadastro
                        with tab_cadastro_almox:
                            st.info("üí° **Cadastre os almoxarifados da empresa:** oficinas fixas e caminh√µes oficina m√≥veis.")
                            
                            with st.form("form_add_almoxarifado", clear_on_submit=True):
                                col1, col2 = st.columns(2)
                                
                                with col1:
                                    nome_almox = st.text_input("Nome do Almoxarifado", placeholder="Ex: Oficina Central, Caminh√£o Oficina 01")
                                    tipo_almox = st.selectbox("Tipo", ["fixo", "movel"], 
                                                           format_func=lambda x: "üè¢ Fixo (Oficina)" if x == "fixo" else "üöõ M√≥vel (Caminh√£o)")
                                    localizacao = st.text_input("Localiza√ß√£o", placeholder="Ex: Sede da empresa, Regi√£o Sul")
                                
                                with col2:
                                    responsavel = st.text_input("Respons√°vel", placeholder="Nome do respons√°vel")
                                    observacoes = st.text_area("Observa√ß√µes", placeholder="Informa√ß√µes adicionais sobre o almoxarifado")
                                
                                submitted_almox = st.form_submit_button("‚ûï Cadastrar Almoxarifado", type="primary")
                                if submitted_almox:
                                    if nome_almox:
                                        success, message = add_almoxarifado(nome_almox, tipo_almox, localizacao, responsavel, observacoes)
                                        if success:
                                            st.success(f"‚úÖ {message}")
                                            st.rerun()
                                        else:
                                            st.error(f"‚ùå {message}")
                                    else:
                                        st.warning("Por favor, informe o nome do almoxarifado.")
                        
                        # Aba de visualiza√ß√£o
                        with tab_visualizar_almox:
                            if not df_almoxarifados.empty:
                                st.write("**Almoxarifados Cadastrados:**")
                                
                                for _, almox in df_almoxarifados.iterrows():
                                    with st.container():
                                        col1, col2, col3 = st.columns([3, 2, 1])
                                        
                                        with col1:
                                            if almox['tipo'] == 'fixo':
                                                st.write(f"üè¢ **{almox['nome']}**")
                                            else:
                                                st.write(f"üöõ **{almox['nome']}**")
                                            
                                            if almox['localizacao']:
                                                st.write(f"üìç {almox['localizacao']}")
                                        
                                        with col2:
                                            if almox['responsavel']:
                                                st.write(f"üë§ {almox['responsavel']}")
                                        
                                        with col3:
                                            if almox['tipo'] == 'fixo':
                                                st.write("üè¢ Fixo")
                                            else:
                                                st.write("üöõ M√≥vel")
                                        
                                        if almox['observacoes']:
                                            st.write(f"üìù {almox['observacoes']}")
                                        
                                        st.markdown("---")
                                
                                # Estat√≠sticas dos almoxarifados
                                st.subheader("üìä Estat√≠sticas dos Almoxarifados")
                                
                                col_stat1, col_stat2, col_stat3 = st.columns(3)
                                
                                with col_stat1:
                                    total_almox = len(df_almoxarifados)
                                    st.metric("Total de Almoxarifados", total_almox)
                                
                                with col_stat2:
                                    almox_fixos = len(df_almoxarifados[df_almoxarifados['tipo'] == 'fixo'])
                                    st.metric("Almoxarifados Fixos", almox_fixos)
                                
                                with col_stat3:
                                    almox_moveis = len(df_almoxarifados[df_almoxarifados['tipo'] == 'movel'])
                                    st.metric("Almoxarifados M√≥veis", almox_moveis)
                                
                                # Gr√°fico de distribui√ß√£o por tipo
                                fig_almox_tipo = px.pie(
                                    df_almoxarifados,
                                    names='tipo',
                                    title="Distribui√ß√£o por Tipo de Almoxarifado",
                                    color_discrete_map={'fixo': 'blue', 'movel': 'orange'}
                                )
                                st.plotly_chart(fig_almox_tipo, use_container_width=True)
                                
                            else:
                                st.info("Nenhum almoxarifado cadastrado. Cadastre o primeiro almoxarifado na aba 'Cadastrar Almoxarifado'.")

                        conn.close()

            if tab_gerir_frotas is not None:
                with tab_gerir_frotas:
                    st.header("‚öôÔ∏è Gerir Frotas")
                    acao_frota = st.radio(
                        "Selecione a a√ß√£o que deseja realizar:",
                        ("Cadastrar Nova Frota", "Editar Frota Existente", "üóëÔ∏è Excluir Frota/Classe"),
                        horizontal=True,
                        key="acao_frotas"
                    )
            
                    if acao_frota == "Cadastrar Nova Frota":
                        st.subheader("‚ûï Cadastrar Nova Frota")
                        with st.form("form_nova_frota", clear_on_submit=True):
                            st.info("Certifique-se de que o C√≥digo do Equipamento √© √∫nico e n√£o existe na base de dados.")
                            
                            # Campos do formul√°rio
                            cod_equip = st.number_input("C√≥digo do Equipamento (√∫nico)", min_value=1, step=1)
                            descricao = st.text_input("Descri√ß√£o do Equipamento (ex: CAMINH√ÉO BASCULANTE)")
                            placa = st.text_input("Placa (deixe em branco se n√£o aplic√°vel)")
                            classe_op = st.text_input("Classe Operacional (ex: Caminh√µes Pesados)")
                            ativo = st.selectbox("Status", options=["ATIVO", "INATIVO"])
                            
                            # Campo de tipo de combust√≠vel
                            tipos_combustivel = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
                            tipo_combustivel = st.selectbox("Tipo de Combust√≠vel", options=tipos_combustivel, index=0)
                            
                            submitted_frota = st.form_submit_button("Salvar Novo Equipamento")
                            
                            if submitted_frota:
                                # Valida√ß√£o
                                if not all([cod_equip, descricao, classe_op]):
                                    st.warning("Os campos 'C√≥digo', 'Descri√ß√£o' e 'Classe Operacional' s√£o obrigat√≥rios.")
                                elif cod_equip in df_frotas['Cod_Equip'].values:
                                    st.error(f"Erro: O C√≥digo de Equipamento '{cod_equip}' j√° existe! Por favor, escolha outro.")
                                else:
                                    # Prepara os dados para inser√ß√£o
                                    dados_frota = {
                                        'cod_equip': cod_equip,
                                        'descricao': descricao,
                                        'placa': placa if placa else None, # Salva None se o campo estiver vazio
                                        'classe_op': classe_op,
                                        'ativo': ativo,
                                        'tipo_combustivel': tipo_combustivel
                                    }
                                    
                                    if inserir_frota(DB_PATH, dados_frota):
                                        st.success(f"Equipamento '{descricao}' cadastrado com sucesso!")
                                        rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                
                    elif acao_frota == "Editar Frota Existente":
                        st.subheader("‚úèÔ∏è Editar Frota Existente")
                        equip_para_editar_label = st.selectbox(
                            "Selecione o equipamento que deseja editar",
                            options=df_frotas.sort_values("label")["label"],
                            key="frota_edit_select"
                        )
            
                        if equip_para_editar_label:
                            cod_equip_edit = int(equip_para_editar_label.split(" - ")[0])
                            dados_atuais = df_frotas[df_frotas['Cod_Equip'] == cod_equip_edit].iloc[0]
            
                            with st.form("form_edit_frota"):
                                st.write(f"**Editando:** {dados_atuais['DESCRICAO_EQUIPAMENTO']} (C√≥d: {dados_atuais['Cod_Equip']})")
            
                                nova_descricao = st.text_input("Descri√ß√£o do Equipamento", value=dados_atuais['DESCRICAO_EQUIPAMENTO'])
                                nova_placa = st.text_input("Placa", value=dados_atuais['PLACA'])
                                nova_classe_op = st.text_input("Classe Operacional", value=dados_atuais['Classe_Operacional'])
                                
                                # Campo de tipo de combust√≠vel
                                tipos_combustivel = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
                                combustivel_atual = dados_atuais.get('tipo_combustivel', 'Diesel S500')
                                index_combustivel = tipos_combustivel.index(combustivel_atual) if combustivel_atual in tipos_combustivel else 0
                                novo_tipo_combustivel = st.selectbox("Tipo de Combust√≠vel", options=tipos_combustivel, index=index_combustivel)
                                
                                status_options = ["ATIVO", "INATIVO"]
                                index_status = status_options.index(dados_atuais['ATIVO']) if dados_atuais['ATIVO'] in status_options else 0
                                novo_status = st.selectbox("Status", options=status_options, index=index_status)
            
                                submitted = st.form_submit_button("Salvar Altera√ß√µes na Frota")
                                if submitted:
                                    dados_editados = {
                                        'descricao': nova_descricao,
                                        'placa': nova_placa,
                                        'classe_op': nova_classe_op,
                                        'ativo': novo_status,
                                        'tipo_combustivel': novo_tipo_combustivel
                                    }
                                    if editar_frota(DB_PATH, cod_equip_edit, dados_editados):
                                        st.success("Dados da frota atualizados com sucesso!")
                                        rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                
                    elif acao_frota == "üóëÔ∏è Excluir Frota/Classe":
                        st.subheader("üóëÔ∏è Excluir Frota ou Classe Operacional")
                        st.warning("‚ö†Ô∏è **ATEN√á√ÉO:** Esta a√ß√£o √© irrevers√≠vel e pode afetar dados relacionados!")
                        
                        # Abas para escolher o tipo de exclus√£o
                        tab_excluir_frota, tab_excluir_classe = st.tabs(["üöö Excluir Frota", "üè∑Ô∏è Excluir Classe"])
                        
                        with tab_excluir_frota:
                            st.info("üìã **Excluir Frota Individual:** Remove um equipamento espec√≠fico da base de dados.")
                            
                            # Mostrar frotas existentes com op√ß√£o de exclus√£o
                            if not df_frotas.empty:
                                st.write("**Frotas Cadastradas:**")
                                
                                # Se√ß√£o de destaque para frotas sem abastecimento
                                st.markdown("""
                                <div style="
                                    background: linear-gradient(135deg, rgba(255, 165, 0, 0.1), rgba(255, 165, 0, 0.05));
                                    border: 1px solid #ffa500;
                                    border-radius: 8px;
                                    padding: 16px;
                                    margin: 16px 0;
                                ">
                                    <h4 style="margin: 0 0 8px 0; color: #ff8c00; font-size: 18px;">
                                        üö® Frotas Sem Hist√≥rico de Abastecimento
                                    </h4>
                                    <p style="margin: 0; color: #2c3e50; font-size: 14px;">
                                        Estas frotas s√£o candidatas ideais para exclus√£o, pois n√£o possuem dados de consumo que afetem suas an√°lises.
                                    </p>
                                </div>
                                """, unsafe_allow_html=True)
                                
                                # Filtros para facilitar a busca
                                col_filtro1, col_filtro2, col_filtro3 = st.columns(3)
                                with col_filtro1:
                                    filtro_status = st.selectbox("Filtrar por Status", options=['Todas', 'ATIVO', 'INATIVO'])
                                with col_filtro2:
                                    # Filtrar valores None e ordenar classes
                                    classes_unicas = [classe for classe in df_frotas['Classe_Operacional'].unique() if pd.notna(classe)]
                                    filtro_classe = st.selectbox("Filtrar por Classe", options=['Todas'] + sorted(classes_unicas))
                                with col_filtro3:
                                    filtro_abastecimento = st.selectbox("Filtrar por Abastecimento", options=['Todas', 'Com Abastecimento', 'Sem Abastecimento'])
                                
                                # Aplicar filtros
                                df_filtrado = df_frotas.copy()
                                if filtro_status != 'Todas':
                                    df_filtrado = df_filtrado[df_filtrado['ATIVO'] == filtro_status]
                                if filtro_classe != 'Todas':
                                    df_filtrado = df_filtrado[df_filtrado['Classe_Operacional'] == filtro_classe]
                                
                                # Filtro por hist√≥rico de abastecimento
                                if filtro_abastecimento != 'Todas':
                                    try:
                                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                            cur = conn.cursor()
                                            
                                            # Verificar se a tabela abastecimentos existe
                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='abastecimentos'")
                                            if cur.fetchone():
                                                # Obter c√≥digos de equipamentos com abastecimentos
                                                # A coluna original √© "C√≥d. Equip." (com acento e ponto)
                                                cur.execute("SELECT DISTINCT \"C√≥d. Equip.\" FROM abastecimentos")
                                                equip_com_abastecimento = [row[0] for row in cur.fetchall()]
                                                
                                                if filtro_abastecimento == 'Com Abastecimento':
                                                    df_filtrado = df_filtrado[df_filtrado['Cod_Equip'].isin(equip_com_abastecimento)]
                                                elif filtro_abastecimento == 'Sem Abastecimento':
                                                    df_filtrado = df_filtrado[~df_filtrado['Cod_Equip'].isin(equip_com_abastecimento)]
                                            
                                            conn.close()
                                    except Exception as e:
                                        st.warning(f"‚ö†Ô∏è Erro ao verificar hist√≥rico de abastecimento: {e}")
                                
                                # Estat√≠sticas das frotas filtradas
                                total_frotas = len(df_filtrado)
                                frotas_ativas = len(df_filtrado[df_filtrado['ATIVO'] == 'ATIVO'])
                                frotas_inativas = len(df_filtrado[df_filtrado['ATIVO'] == 'INATIVO'])
                                
                                # Verificar frotas sem abastecimento de uma vez s√≥ (mais eficiente)
                                equip_com_abastecimento = set()
                                try:
                                    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                        cur = conn.cursor()
                                        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='abastecimentos'")
                                        if cur.fetchone():
                                            # A coluna original √© "C√≥d. Equip." (com acento e ponto)
                                            cur.execute("SELECT DISTINCT \"C√≥d. Equip.\" FROM abastecimentos")
                                            equip_com_abastecimento = {row[0] for row in cur.fetchall()}
                                            st.info(f"üîç Debug: Encontrados {len(equip_com_abastecimento)} c√≥digos de equipamentos com abastecimento")
                                        else:
                                            st.warning("‚ö†Ô∏è Tabela 'abastecimentos' n√£o encontrada no banco de dados")
                                        conn.close()
                                except Exception as e:
                                    st.error(f"‚ùå Erro ao consultar banco: {e}")
                                    equip_com_abastecimento = set()
                                
                                # Calcular m√©tricas de uma vez
                                frotas_sem_abastecimento = len(df_filtrado[~df_filtrado['Cod_Equip'].isin(equip_com_abastecimento)])
                                
                                # Debug adicional
                                st.info(f"üîç Debug: Total de frotas filtradas: {len(df_filtrado)}")
                                st.info(f"üîç Debug: Frotas com abastecimento: {len(df_filtrado[df_filtrado['Cod_Equip'].isin(equip_com_abastecimento)])}")
                                st.info(f"üîç Debug: Frotas sem abastecimento: {frotas_sem_abastecimento}")
                                
                                # M√©tricas de resumo
                                col_metrica1, col_metrica2, col_metrica3, col_metrica4 = st.columns(4)
                                with col_metrica1:
                                    st.metric("Total de Frotas", total_frotas)
                                with col_metrica2:
                                    st.metric("Frotas Ativas", frotas_ativas)
                                with col_metrica3:
                                    st.metric("Frotas Inativas", frotas_inativas)
                                with col_metrica4:
                                    st.metric("Sem Abastecimento", frotas_sem_abastecimento)
                                
                                # Bot√µes para exclus√£o em lote
                                if frotas_sem_abastecimento > 0:
                                    st.markdown("---")
                                    st.subheader("üöÄ Exclus√£o em Lote - Otimiza√ß√£o de Tempo")
                                    
                                    # Exclus√£o de frotas sem abastecimento
                                    col_lote1, col_lote2, col_lote3 = st.columns([2, 2, 1])
                                    with col_lote1:
                                        st.markdown(f"""
                                        <div style="
                                            background: linear-gradient(135deg, rgba(255, 165, 0, 0.1), rgba(255, 165, 0, 0.05));
                                            border: 1px solid #ffa500;
                                            border-radius: 8px;
                                            padding: 12px;
                                        ">
                                            <p style="margin: 0; color: #ff8c00; font-size: 14px; font-weight: 600;">
                                                üöÄ <strong>Exclus√£o em Lote:</strong> {frotas_sem_abastecimento} frotas sem abastecimento
                                            </p>
                                        </div>
                                        """, unsafe_allow_html=True)
                                    with col_lote2:
                                        if st.button("üóëÔ∏è Excluir Todas (Sem Abastecimento)", key="delete_lote_sem_abastecimento", type="primary"):
                                            st.warning("‚ö†Ô∏è Esta a√ß√£o excluir√° TODAS as frotas sem hist√≥rico de abastecimento!")
                                            if st.button("‚úÖ CONFIRMAR EXCLUS√ÉO EM LOTE", key="confirm_delete_lote", type="primary"):
                                                try:
                                                    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                        cur = conn.cursor()
                                                        
                                                        # Obter c√≥digos das frotas sem abastecimento
                                                        frotas_sem_abastecimento_codigos = df_filtrado[~df_filtrado['Cod_Equip'].isin(equip_com_abastecimento)]['Cod_Equip'].tolist()
                                                        
                                                        # Verificar se h√° outros dados relacionados (pneus, manuten√ß√µes)
                                                        tem_outros_dados = False
                                                        dados_relacionados = {}
                                                        
                                                        # Verificar pneus
                                                        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='pneus_historico'")
                                                        if cur.fetchone():
                                                            placeholders = ','.join(['?' for _ in frotas_sem_abastecimento_codigos])
                                                            cur.execute(f"SELECT COUNT(*) FROM pneus_historico WHERE Cod_Equip IN ({placeholders})", frotas_sem_abastecimento_codigos)
                                                            num_pneus = cur.fetchone()[0]
                                                            dados_relacionados['pneus'] = num_pneus
                                                            if num_pneus > 0:
                                                                tem_outros_dados = True
                                                        
                                                        # Verificar manuten√ß√µes
                                                        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='manutencoes'")
                                                        if cur.fetchone():
                                                            placeholders = ','.join(['?' for _ in frotas_sem_abastecimento_codigos])
                                                            cur.execute(f"SELECT COUNT(*) FROM manutencoes WHERE Cod_Equip IN ({placeholders})", frotas_sem_abastecimento_codigos)
                                                            num_manutencoes = cur.fetchone()[0]
                                                            dados_relacionados['manutencoes'] = num_manutencoes
                                                            if num_manutencoes > 0:
                                                                tem_outros_dados = True
                                                        
                                                        if tem_outros_dados:
                                                            st.error(f"""
                                                            ‚ùå **Algumas frotas possuem dados relacionados!**
                                                            
                                                            **Dados encontrados:**
                                                            - Pneus: {dados_relacionados.get('pneus', 0)}
                                                            - Manuten√ß√µes: {dados_relacionados.get('manutencoes', 0)}
                                                            
                                                            **Solu√ß√£o:** Use a exclus√£o individual para verificar cada frota.
                                                            """)
                                                        else:
                                                            # Excluir todas as frotas sem abastecimento
                                                            placeholders = ','.join(['?' for _ in frotas_sem_abastecimento_codigos])
                                                            cur.execute(f"DELETE FROM frotas WHERE Cod_Equip IN ({placeholders})", frotas_sem_abastecimento_codigos)
                                                            conn.commit()
                                                            st.success(f"‚úÖ {len(frotas_sem_abastecimento_codigos)} frotas sem abastecimento exclu√≠das com sucesso!")
                                                            rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                                                except Exception as e:
                                                    st.error(f"‚ùå Erro ao excluir frotas em lote: {e}")
                                    with col_lote3:
                                        st.info(f"üí° **Dica:** Use este bot√£o para limpar rapidamente frotas irrelevantes")
                                    
                                    # Exclus√£o por classe operacional (apenas classes sem abastecimento)
                                    st.markdown("---")
                                    col_classe_lote1, col_classe_lote2 = st.columns([3, 2])
                                    with col_classe_lote1:
                                        st.markdown("""
                                        <div style="
                                            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.05));
                                            border: 1px solid #667eea;
                                            border-radius: 8px;
                                            padding: 12px;
                                        ">
                                            <p style="margin: 0; color: #667eea; font-size: 14px; font-weight: 600;">
                                                üéØ <strong>Exclus√£o por Classe:</strong> Classes operacionais SEM NENHUMA frota com abastecimento
                                            </p>
                                        </div>
                                        """, unsafe_allow_html=True)
                                    
                                    # Identificar classes que podem ser exclu√≠das em lote (VERDADEIRAMENTE sem abastecimento)
                                    classes_sem_abastecimento = []
                                    for classe in df_filtrado['Classe_Operacional'].dropna().unique():
                                        frotas_da_classe = df_filtrado[df_filtrado['Classe_Operacional'] == classe]
                                        # Verificar se TODAS as frotas da classe n√£o t√™m abastecimento
                                        todas_sem_abastecimento = True
                                        for _, frota in frotas_da_classe.iterrows():
                                            if frota['Cod_Equip'] in equip_com_abastecimento:
                                                todas_sem_abastecimento = False
                                                break
                                        
                                        if todas_sem_abastecimento and len(frotas_da_classe) > 0:
                                            classes_sem_abastecimento.append({
                                                'classe': classe,
                                                'num_frotas': len(frotas_da_classe)
                                            })
                                    
                                    if classes_sem_abastecimento:
                                        with col_classe_lote2:
                                            st.write(f"**Classes candidatas:** {len(classes_sem_abastecimento)}")
                                            for idx_classe_lote, classe_info in enumerate(classes_sem_abastecimento):
                                                if st.button(f"üóëÔ∏è {classe_info['classe']} ({classe_info['num_frotas']} frotas)", 
                                                           key=f"delete_classe_lote_{idx_classe_lote}", 
                                                           type="secondary"):
                                                    st.warning(f"‚ö†Ô∏è Excluir classe '{classe_info['classe']}' e {classe_info['num_frotas']} frotas?")
                                                    if st.button(f"‚úÖ CONFIRMAR {classe_info['classe']}", 
                                                               key=f"confirm_classe_lote_{idx_classe_lote}", 
                                                               type="primary"):
                                                        try:
                                                            with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                                cur = conn.cursor()
                                                                
                                                                # Obter c√≥digos das frotas da classe
                                                                frotas_classe_codigos = df_filtrado[df_filtrado['Classe_Operacional'] == classe_info['classe']]['Cod_Equip'].tolist()
                                                                
                                                                # Verificar outros dados relacionados
                                                                tem_outros_dados = False
                                                                dados_relacionados = {}
                                                                
                                                                # Verificar pneus
                                                                cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='pneus_historico'")
                                                                if cur.fetchone():
                                                                    placeholders = ','.join(['?' for _ in frotas_classe_codigos])
                                                                    cur.execute(f"SELECT COUNT(*) FROM pneus_historico WHERE Cod_Equip IN ({placeholders})", frotas_classe_codigos)
                                                                    num_pneus = cur.fetchone()[0]
                                                                    dados_relacionados['pneus'] = num_pneus
                                                                    if num_pneus > 0:
                                                                        tem_outros_dados = True
                                                                
                                                                # Verificar manuten√ß√µes
                                                                cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='manutencoes'")
                                                                if cur.fetchone():
                                                                    placeholders = ','.join(['?' for _ in frotas_classe_codigos])
                                                                    cur.execute(f"SELECT COUNT(*) FROM manutencoes WHERE Cod_Equip IN ({placeholders})", frotas_classe_codigos)
                                                                    num_manutencoes = cur.fetchone()[0]
                                                                    dados_relacionados['manutencoes'] = num_manutencoes
                                                                    if num_manutencoes > 0:
                                                                        tem_outros_dados = True
                                                                
                                                                if tem_outros_dados:
                                                                    st.error(f"""
                                                                    ‚ùå **Classe '{classe_info['classe']}' possui dados relacionados!**
                                                                    
                                                                    **Dados encontrados:**
                                                                    - Pneus: {dados_relacionados.get('pneus', 0)}
                                                                    - Manuten√ß√µes: {dados_relacionados.get('manutencoes', 0)}
                                                                    """)
                                                                else:
                                                                    # Excluir todas as frotas da classe
                                                                    placeholders = ','.join(['?' for _ in frotas_classe_codigos])
                                                                    cur.execute(f"DELETE FROM frotas WHERE Cod_Equip IN ({placeholders})", frotas_classe_codigos)
                                                                    conn.commit()
                                                                    st.success(f"‚úÖ Classe '{classe_info['classe']}' e {classe_info['num_frotas']} frotas exclu√≠das com sucesso!")
                                                                    rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                                                        except Exception as e:
                                                            st.error(f"‚ùå Erro ao excluir classe: {e}")
                                    else:
                                        with col_classe_lote2:
                                            st.info("‚úÖ Todas as classes possuem pelo menos uma frota com abastecimento")
                                    
                                    # Debug: Mostrar informa√ß√µes sobre as classes
                                    st.markdown("---")
                                    st.subheader("üîç Debug: An√°lise das Classes")
                                    col_debug1, col_debug2 = st.columns(2)
                                    with col_debug1:
                                        st.write("**Classes analisadas:**")
                                        for classe in df_filtrado['Classe_Operacional'].dropna().unique():
                                            frotas_da_classe = df_filtrado[df_filtrado['Classe_Operacional'] == classe]
                                            frotas_com_abastecimento = sum(1 for _, frota in frotas_da_classe.iterrows() if frota['Cod_Equip'] in equip_com_abastecimento)
                                            frotas_sem_abastecimento = len(frotas_da_classe) - frotas_com_abastecimento
                                            st.write(f"- **{classe}:** {frotas_com_abastecimento} com abastecimento, {frotas_sem_abastecimento} sem")
                                    
                                    with col_debug2:
                                        st.write("**Frotas com abastecimento:**")
                                        st.write(f"Total: {len(equip_com_abastecimento)}")
                                        if len(equip_com_abastecimento) > 0:
                                            st.write("Primeiros 5 c√≥digos:")
                                            for cod in list(equip_com_abastecimento)[:5]:
                                                st.write(f"- {cod}")
                                        
                                        # Debug adicional para entender o problema
                                        st.markdown("---")
                                        st.write("**üîç Debug Detalhado:**")
                                        st.write(f"Tipo de equip_com_abastecimento: {type(equip_com_abastecimento)}")
                                        st.write(f"Tamanho do set: {len(equip_com_abastecimento)}")
                                        if len(equip_com_abastecimento) > 0:
                                            st.write(f"Primeiros 3 c√≥digos: {list(equip_com_abastecimento)[:3]}")
                                        st.write(f"Tipo de df_filtrado['Cod_Equip']: {type(df_filtrado['Cod_Equip'].iloc[0])}")
                                        st.write(f"Primeiros 3 c√≥digos das frotas: {df_filtrado['Cod_Equip'].head(3).tolist()}")
                                    
                                    # Teste de compara√ß√£o adicional
                                    st.markdown("---")
                                    st.subheader("üß™ Teste de Compara√ß√£o")
                                    if len(df_filtrado) > 0 and len(equip_com_abastecimento) > 0:
                                        primeiro_codigo = df_filtrado['Cod_Equip'].iloc[0]
                                        st.write(f"**Primeiro c√≥digo da frota:** {primeiro_codigo} (tipo: {type(primeiro_codigo)})")
                                        st.write(f"**Est√° no set?** {primeiro_codigo in equip_com_abastecimento}")
                                        if len(equip_com_abastecimento) > 0:
                                            st.write(f"**Compara√ß√£o direta:** {primeiro_codigo == list(equip_com_abastecimento)[0]}")
                                            st.write(f"**Valores no set:** {sorted(list(equip_com_abastecimento))[:10]}")
                                    
                                    st.markdown("---")
                                
                                # Mostrar frotas filtradas
                                for idx, (_, frota) in enumerate(df_filtrado.iterrows()):
                                    with st.container():
                                        col_info, col_acoes = st.columns([4, 1])
                                        with col_info:
                                            # Verificar se a frota tem abastecimento (usando o set j√° carregado)
                                            tem_abastecimento = frota['Cod_Equip'] in equip_com_abastecimento
                                            
                                            # Card da frota com destaque para sem abastecimento
                                            cor_borda = '#00ff88' if frota['ATIVO'] == 'ATIVO' else '#ff6b6b'
                                            cor_fundo = 'rgba(0, 255, 136, 0.1)' if frota['ATIVO'] == 'ATIVO' else 'rgba(255, 107, 107, 0.1)'
                                            cor_sombra = 'rgba(0, 255, 136, 0.2)' if frota['ATIVO'] == 'ATIVO' else 'rgba(255, 107, 107, 0.2)'
                                            
                                            # Destacar frotas sem abastecimento
                                            if not tem_abastecimento:
                                                cor_borda = '#ffa500'  # Laranja
                                                cor_fundo = 'rgba(255, 165, 0, 0.15)'
                                                cor_sombra = 'rgba(255, 165, 0, 0.3)'
                                            
                                            st.markdown(f"""
                                            <div style="
                                                border: 2px solid {cor_borda}; 
                                                border-radius: 8px; 
                                                padding: 16px; 
                                                margin: 8px 0; 
                                                background: linear-gradient(135deg, {cor_fundo}, rgba(255, 255, 255, 0.05));
                                                box-shadow: 0 2px 8px {cor_sombra};
                                                position: relative;
                                            ">
                                                {f'<div style="position: absolute; top: 8px; right: 8px; background: #ffa500; color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: bold;">SEM ABASTECIMENTO</div>' if not tem_abastecimento else ''}
                                                <h4 style="
                                                    margin: 0 0 8px 0; 
                                                    color: {'#00cc6a' if frota['ATIVO'] == 'ATIVO' else '#ff4757'}; 
                                                    font-size: 16px; 
                                                    font-weight: 600;
                                                ">
                                                    {frota['DESCRICAO_EQUIPAMENTO']} (C√≥d: {frota['Cod_Equip']})
                                                </h4>
                                                <p style="margin: 4px 0; font-size: 13px; color: #2c3e50;">
                                                    <strong>Classe:</strong> {frota['Classe_Operacional'] if pd.notna(frota['Classe_Operacional']) else 'N/A'} | 
                                                    <strong>Placa:</strong> {frota['PLACA'] if pd.notna(frota['PLACA']) else 'N/A'} | 
                                                    <strong>Status:</strong> {frota['ATIVO']}
                                                </p>
                                                <p style="margin: 4px 0; font-size: 12px; color: {'#ffa500' if not tem_abastecimento else '#27ae60'}; font-weight: 500;">
                                                    üìä <strong>Hist√≥rico:</strong> {'‚ùå Sem abastecimento' if not tem_abastecimento else '‚úÖ Com abastecimento'}
                                                </p>
                                            </div>
                                            """, unsafe_allow_html=True)
                                        with col_acoes:
                                            if st.button("üóëÔ∏è", key=f"delete_frota_{idx}", help="Excluir frota"):
                                                # Confirmar exclus√£o
                                                if st.button("‚úÖ Confirmar Exclus√£o", key=f"confirm_delete_{idx}", type="primary"):
                                                    try:
                                                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                            cur = conn.cursor()
                                                            
                                                            # Verificar se h√° dados relacionados
                                                            num_abastecimentos = 0
                                                            num_pneus = 0
                                                            num_manutencoes = 0
                                                            
                                                            # Verificar se as tabelas existem antes de consultar
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='abastecimentos'")
                                                            if cur.fetchone():
                                                                # A coluna original √© "C√≥d. Equip." (com acento e ponto)
                                                                cur.execute("SELECT COUNT(*) FROM abastecimentos WHERE \"C√≥d. Equip.\" = ?", (frota['Cod_Equip'],))
                                                                num_abastecimentos = cur.fetchone()[0]
                                                            
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='pneus_historico'")
                                                            if cur.fetchone():
                                                                cur.execute("SELECT COUNT(*) FROM pneus_historico WHERE Cod_Equip = ?", (frota['Cod_Equip'],))
                                                                num_pneus = cur.fetchone()[0]
                                                            
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='manutencoes'")
                                                            if cur.fetchone():
                                                                cur.execute("SELECT COUNT(*) FROM manutencoes WHERE Cod_Equip = ?", (frota['Cod_Equip'],))
                                                                num_manutencoes = cur.fetchone()[0]
                                                            
                                                            if num_abastecimentos > 0 or num_pneus > 0 or num_manutencoes > 0:
                                                                st.error(f"""
                                                                ‚ùå **N√£o √© poss√≠vel excluir esta frota!**
                                                                
                                                                **Dados relacionados encontrados:**
                                                                - Abastecimentos: {num_abastecimentos}
                                                                - Pneus: {num_pneus}
                                                                - Manuten√ß√µes: {num_manutencoes}
                                                                
                                                                **Solu√ß√£o:** Primeiro remova todos os dados relacionados ou marque a frota como INATIVA.
                                                                """)
                                                            else:
                                                                # Excluir a frota
                                                                cur.execute("DELETE FROM frotas WHERE Cod_Equip = ?", (frota['Cod_Equip'],))
                                                                conn.commit()
                                                                st.success(f"‚úÖ Frota '{frota['DESCRICAO_EQUIPAMENTO']}' exclu√≠da com sucesso!")
                                                                rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                                                    except Exception as e:
                                                        st.error(f"‚ùå Erro ao excluir frota: {e}")
                            else:
                                st.info("Nenhuma frota cadastrada.")
                        
                        with tab_excluir_classe:
                            st.info("üìã **Excluir Classe Operacional:** Remove uma classe e todas as frotas associadas.")
                            
                            # Mostrar classes existentes
                            if not df_frotas.empty:
                                classes_existentes = sorted(df_frotas['Classe_Operacional'].unique())
                                st.write("**Classes Operacionais Existentes:**")
                                
                                for idx_classe, classe in enumerate(classes_existentes):
                                    # Contar frotas nesta classe
                                    frotas_na_classe = df_frotas[df_frotas['Classe_Operacional'] == classe]
                                    num_frotas = len(frotas_na_classe)
                                    
                                    with st.container():
                                        col_classe_info, col_classe_acoes = st.columns([4, 1])
                                        with col_classe_info:
                                            # Card da classe
                                            st.markdown(f"""
                                            <div style="
                                                border: 1px solid #667eea; 
                                                border-radius: 8px; 
                                                padding: 16px; 
                                                margin: 8px 0; 
                                                background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
                                                box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0; 
                                                    color: #667eea; 
                                                    font-size: 16px; 
                                                    font-weight: 600;
                                                ">
                                                    {classe}
                                                </h4>
                                                <p style="margin: 4px 0; font-size: 13px; color: #2c3e50;">
                                                    <strong>Frotas na classe:</strong> {num_frotas} | 
                                                    <strong>Status:</strong> {'Ativa' if num_frotas > 0 else 'Vazia'}
                                                </p>
                                            </div>
                                            """, unsafe_allow_html=True)
                                        with col_classe_acoes:
                                            if st.button("üóëÔ∏è", key=f"delete_classe_{idx_classe}", help="Excluir classe"):
                                                # Confirmar exclus√£o
                                                if st.button("‚úÖ Confirmar Exclus√£o", key=f"confirm_delete_classe_{idx_classe}", type="primary"):
                                                    try:
                                                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                            cur = conn.cursor()
                                                            
                                                            # Verificar se h√° dados relacionados
                                                            frotas_codigos = frotas_na_classe['Cod_Equip'].tolist()
                                                            
                                                            num_abastecimentos = 0
                                                            num_pneus = 0
                                                            num_manutencoes = 0
                                                            
                                                            # Verificar se as tabelas existem antes de consultar
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='abastecimentos'")
                                                            if cur.fetchone():
                                                                placeholders = ','.join(['?' for _ in frotas_codigos])
                                                                # A coluna original √© "C√≥d. Equip." (com acento e ponto)
                                                                cur.execute(f"SELECT COUNT(*) FROM abastecimentos WHERE \"C√≥d. Equip.\" IN ({placeholders})", frotas_codigos)
                                                                num_abastecimentos = cur.fetchone()[0]
                                                            
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='pneus_historico'")
                                                            if cur.fetchone():
                                                                placeholders = ','.join(['?' for _ in frotas_codigos])
                                                                cur.execute(f"SELECT COUNT(*) FROM pneus_historico WHERE Cod_Equip IN ({placeholders})", frotas_codigos)
                                                                num_pneus = cur.fetchone()[0]
                                                            
                                                            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='manutencoes'")
                                                            if cur.fetchone():
                                                                placeholders = ','.join(['?' for _ in frotas_codigos])
                                                                cur.execute(f"SELECT COUNT(*) FROM manutencoes WHERE Cod_Equip IN ({placeholders})", frotas_codigos)
                                                                num_manutencoes = cur.fetchone()[0]
                                                            
                                                            if num_abastecimentos > 0 or num_pneus > 0 or num_manutencoes > 0:
                                                                st.error(f"""
                                                                ‚ùå **N√£o √© poss√≠vel excluir esta classe!**
                                                                
                                                                **Dados relacionados encontrados:**
                                                                - Abastecimentos: {num_abastecimentos}
                                                                - Pneus: {num_pneus}
                                                                - Manuten√ß√µes: {num_manutencoes}
                                                                
                                                                **Solu√ß√£o:** Primeiro remova todos os dados relacionados ou exclua as frotas individualmente.
                                                                """)
                                                            else:
                                                                # Excluir todas as frotas da classe
                                                                cur.execute(f"DELETE FROM frotas WHERE Cod_Equip IN ({placeholders})", frotas_codigos)
                                                                conn.commit()
                                                                st.success(f"‚úÖ Classe '{classe}' e {num_frotas} frotas exclu√≠das com sucesso!")
                                                                rerun_keep_tab("‚öôÔ∏è Gerir Frotas")
                                                    except Exception as e:
                                                        st.error(f"‚ùå Erro ao excluir classe: {e}")
                            else:
                                st.info("Nenhuma classe operacional encontrada.")
                
                        # NOVA SE√á√ÉO: Gerenciar Tipos de Combust√≠vel
                    st.markdown("---")
                    st.subheader("‚õΩ Gerenciar Tipos de Combust√≠vel")
                    st.info("Esta se√ß√£o permite gerenciar os tipos de combust√≠vel das frotas de forma eficiente. Acesso restrito a administradores.")
                
                    # Criar abas para organizar as funcionalidades
                    tab_combustivel_classe, tab_combustivel_frota = st.tabs(["üîÑ Por Classe", "‚úèÔ∏è Por Frota"])
                
                    with tab_combustivel_classe:
                        st.subheader("üîÑ Aplicar Combust√≠vel a uma Classe Inteira")
                        st.write("Define o tipo de combust√≠vel para todas as frotas de uma classe espec√≠fica. √ötil para padroniza√ß√£o em massa.")
                    
                        # Selecionar classe
                        classes_disponiveis = sorted([c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()])
                    
                        if not classes_disponiveis:
                            st.warning("Nenhuma classe operacional encontrada. Verifique se h√° frotas cadastradas.")
                        else:
                            classe_selecionada = st.selectbox(
                                "Selecione a Classe:",
                                options=classes_disponiveis,
                                key="classe_combustivel_admin"
                            )
                        
                            # Mostrar informa√ß√µes sobre a classe selecionada
                            if classe_selecionada:
                                frotas_da_classe = df_frotas[df_frotas['Classe_Operacional'] == classe_selecionada]
                                st.info(f"**Classe selecionada:** {classe_selecionada}")
                                st.info(f"**Total de frotas:** {len(frotas_da_classe)}")
                                st.info(f"**Frotas ativas:** {len(frotas_da_classe[frotas_da_classe['ATIVO'] == 'ATIVO'])}")
                            
                                # Mostrar tipos de combust√≠vel atuais
                                if 'tipo_combustivel' in frotas_da_classe.columns:
                                    combustiveis_atuais = frotas_da_classe['tipo_combustivel'].value_counts()
                                    st.write("**Tipos de combust√≠vel atuais na classe:**")
                                    for combustivel, count in combustiveis_atuais.items():
                                        st.write(f"- {combustivel}: {count} frotas")
                            
                                # Selecionar novo tipo de combust√≠vel
                                tipos_combustivel = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
                                tipo_combustivel_classe = st.selectbox(
                                    "Novo Tipo de Combust√≠vel:",
                                    options=tipos_combustivel,
                                    key="tipo_combustivel_classe_admin"
                                )
                            
                                if st.button("üîÑ Aplicar √† Classe Inteira", type="primary", use_container_width=True):
                                    with st.spinner("Aplicando tipo de combust√≠vel √† classe..."):
                                        success, message = update_classe_combustivel(classe_selecionada, tipo_combustivel_classe)
                                        if success:
                                            st.success(message)
                                            # Limpar cache para atualizar dados
                                            st.cache_data.clear()
                                            st.rerun()
                                        else:
                                            st.error(message)
                
                    with tab_combustivel_frota:
                        st.subheader("‚úèÔ∏è Editar Combust√≠vel de uma Frota Espec√≠fica")
                        st.write("Define o tipo de combust√≠vel para uma frota espec√≠fica. √ötil para casos especiais ou exce√ß√µes.")
                    
                        # Selecionar frota
                        frotas_disponiveis = df_frotas[df_frotas['ATIVO'] == 'ATIVO'].copy()
                    
                        if frotas_disponiveis.empty:
                            st.warning("Nenhuma frota ativa encontrada. Verifique se h√° frotas cadastradas e ativas.")
                        else:
                            frotas_disponiveis['label_combustivel'] = (
                                frotas_disponiveis['Cod_Equip'].astype(str) + " - " + 
                                frotas_disponiveis['DESCRICAO_EQUIPAMENTO'].fillna('') + 
                                " (" + frotas_disponiveis['PLACA'].fillna('Sem Placa') + ")"
                            )
                        
                            frota_selecionada = st.selectbox(
                                "Selecione a Frota:",
                                options=frotas_disponiveis['label_combustivel'].tolist(),
                                key="frota_combustivel_admin"
                            )
                        
                            if frota_selecionada:
                                # Obter c√≥digo da frota selecionada
                                cod_equip_frota = int(frota_selecionada.split(" - ")[0])
                            
                                # Obter dados da frota
                                dados_frota = frotas_disponiveis[frotas_disponiveis['Cod_Equip'] == cod_equip_frota].iloc[0]
                            
                                # Mostrar informa√ß√µes da frota
                                col_info1, col_info2 = st.columns(2)
                                with col_info1:
                                    st.write(f"**C√≥digo:** {dados_frota['Cod_Equip']}")
                                    st.write(f"**Descri√ß√£o:** {dados_frota['DESCRICAO_EQUIPAMENTO']}")
                                with col_info2:
                                    st.write(f"**Placa:** {dados_frota['PLACA']}")
                                    st.write(f"**Classe:** {dados_frota['Classe_Operacional']}")
                            
                                # Verificar combust√≠vel atual
                                if 'tipo_combustivel' in dados_frota:
                                    combustivel_atual = dados_frota['tipo_combustivel']
                                    combustivel_atual = combustivel_atual if pd.notna(combustivel_atual) else 'Diesel S500'
                                else:
                                    combustivel_atual = 'Diesel S500'
                            
                                st.info(f"**Combust√≠vel atual:** {combustivel_atual}")
                            
                                # Selecionar novo tipo de combust√≠vel
                                tipos_combustivel = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
                                novo_tipo_combustivel = st.selectbox(
                                    "Novo Tipo de Combust√≠vel:",
                                    options=tipos_combustivel,
                                    index=tipos_combustivel.index(combustivel_atual) if combustivel_atual in tipos_combustivel else 0,
                                    key="novo_tipo_combustivel_admin"
                                )
                            
                                if st.button("‚úèÔ∏è Atualizar Frota", type="secondary", use_container_width=True):
                                    with st.spinner("Atualizando tipo de combust√≠vel..."):
                                        success, message = update_frota_combustivel(cod_equip_frota, novo_tipo_combustivel)
                                        if success:
                                            st.success(message)
                                            # Limpar cache para atualizar dados
                                            st.cache_data.clear()
                                            st.rerun()
                                        else:
                                            st.error(message)
                
                    # Resumo dos tipos de combust√≠vel
                    st.markdown("---")
                    st.subheader("üìä Resumo dos Tipos de Combust√≠vel")
                
                    if 'tipo_combustivel' in df_frotas.columns:
                        # Estat√≠sticas gerais
                        col_stats1, col_stats2, col_stats3 = st.columns(3)
                    
                        with col_stats1:
                            total_frotas = len(df_frotas)
                            st.metric("Total de Frotas", total_frotas)
                    
                        with col_stats2:
                            frotas_com_combustivel = df_frotas['tipo_combustivel'].notna().sum()
                            st.metric("Frotas com Combust√≠vel", frotas_com_combustivel)
                    
                        with col_stats3:
                            tipos_unicos = df_frotas['tipo_combustivel'].nunique()
                            st.metric("Tipos de Combust√≠vel", tipos_unicos)
                    
                        # Distribui√ß√£o por tipo de combust√≠vel
                        st.write("**Distribui√ß√£o por Tipo de Combust√≠vel:**")
                        combustivel_dist = df_frotas['tipo_combustivel'].value_counts()
                        for combustivel, count in combustivel_dist.items():
                            percentual = (count / total_frotas) * 100
                            st.write(f"- **{combustivel}: {count} frotas ({percentual:.1f}%)")
                    else:
                        st.warning("Coluna de tipo de combust√≠vel n√£o encontrada. Execute a aplica√ß√£o para criar automaticamente.")

                # ===== NOVA SE√á√ÉO: METAS DE CONSUMO =====
                st.markdown("---")
                st.subheader("üéØ Gerenciar Metas de Consumo das Frotas")
                st.info("""
                **üìã Sobre as Metas de Consumo:**
                
                **‚Ä¢ Por Classe Operacional:** Define uma meta padr√£o para todas as frotas de uma classe espec√≠fica
                **‚Ä¢ Por Frota Individual:** Permite definir metas personalizadas para frotas espec√≠ficas
                **‚Ä¢ Unidades:** L/h (Litros por Hora) para equipamentos com controle por horas, ou Km/L (Quil√¥metros por Litro) para equipamentos com controle por quil√¥metros
                **‚Ä¢ Alertas:** O sistema alerta quando o consumo est√° acima de 105% da meta definida
                """)
                
                # Criar abas para organizar as funcionalidades
                tab_meta_classe, tab_meta_frota, tab_meta_analise = st.tabs(["üîÑ Por Classe", "‚úèÔ∏è Por Frota", "üìä An√°lise"])
                
                with tab_meta_classe:
                    st.subheader("üîÑ Definir Metas por Classe Operacional")
                    st.write("Define uma meta de consumo padr√£o para todas as frotas de uma classe espec√≠fica. √ötil para padroniza√ß√£o em massa.")
                    
                    # Selecionar classe
                    classes_disponiveis = sorted([c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()])
                    
                    if not classes_disponiveis:
                        st.warning("Nenhuma classe operacional encontrada. Verifique se h√° frotas cadastradas.")
                    else:
                        classe_selecionada = st.selectbox(
                            "Selecione a Classe:",
                            options=classes_disponiveis,
                            key="classe_meta_admin"
                        )
                        
                        if classe_selecionada:
                            # Mostrar informa√ß√µes sobre a classe selecionada
                            frotas_da_classe = df_frotas[df_frotas['Classe_Operacional'] == classe_selecionada]
                            tipo_controle = frotas_da_classe['Tipo_Controle'].iloc[0] if 'Tipo_Controle' in frotas_da_classe.columns else 'QUIL√îMETROS'
                            
                            col_info1, col_info2, col_info3 = st.columns(3)
                            with col_info1:
                                st.info(f"**Classe:** {classe_selecionada}")
                            with col_info2:
                                st.info(f"**Total de frotas:** {len(frotas_da_classe)}")
                            with col_info3:
                                st.info(f"**Tipo de controle:** {tipo_controle}")
                            
                            # Verificar meta atual
                            meta_atual = 0.0
                            if 'intervalos_por_classe' in st.session_state:
                                if classe_selecionada in st.session_state.intervalos_por_classe:
                                    meta_atual = st.session_state.intervalos_por_classe[classe_selecionada].get('meta_consumo', 0.0)
                            
                            # Formul√°rio para definir meta
                            with st.form(f"form_meta_classe_{classe_selecionada}", clear_on_submit=False):
                                st.write(f"**Meta de Consumo para Classe: {classe_selecionada}**")
                                
                                # Determinar unidade baseada no tipo de controle
                                if tipo_controle == 'HORAS':
                                    unidade = "L/h (Litros por Hora)"
                                    placeholder = "Ex: 5.0 para 5 litros por hora"
                                    step_value = 0.1
                                else:
                                    unidade = "Km/L (Quil√¥metros por Litro)"
                                    placeholder = "Ex: 2.5 para 2.5 km por litro"
                                    step_value = 0.1
                                
                                nova_meta = st.number_input(
                                    f"Meta de Consumo ({unidade})",
                                    min_value=0.0,
                                    step=step_value,
                                    value=float(meta_atual),
                                    format="%.2f",
                                    help=placeholder,
                                    key=f"meta_classe_{classe_selecionada}"
                                )
                                
                                # Campo para descri√ß√£o da meta
                                descricao_meta = st.text_area(
                                    "Descri√ß√£o/Observa√ß√µes da Meta (opcional)",
                                    value="",
                                    placeholder="Ex: Meta baseada na m√©dia hist√≥rica da classe, considerando opera√ß√£o em terreno plano",
                                    max_chars=200,
                                    key=f"desc_meta_{classe_selecionada}"
                                )
                                
                                submitted_meta = st.form_submit_button("üíæ Salvar Meta da Classe", type="primary")
                                
                                if submitted_meta:
                                    if nova_meta > 0:
                                        # Inicializar estrutura se n√£o existir
                                        if 'intervalos_por_classe' not in st.session_state:
                                            st.session_state.intervalos_por_classe = {}
                                        if classe_selecionada not in st.session_state.intervalos_por_classe:
                                            st.session_state.intervalos_por_classe[classe_selecionada] = {}
                                        
                                        # Salvar meta
                                        st.session_state.intervalos_por_classe[classe_selecionada]['meta_consumo'] = nova_meta
                                        st.session_state.intervalos_por_classe[classe_selecionada]['descricao_meta'] = descricao_meta
                                        st.session_state.intervalos_por_classe[classe_selecionada]['unidade_meta'] = unidade
                                        st.session_state.intervalos_por_classe[classe_selecionada]['data_meta'] = datetime.now().strftime('%d/%m/%Y %H:%M')
                                        
                                        st.success(f"‚úÖ Meta de consumo definida com sucesso para a classe '{classe_selecionada}': **{nova_meta} {unidade}**")
                                        
                                        # Mostrar resumo da meta
                                        st.info(f"""
                                        **üìã Resumo da Meta Definida:**
                                        - **Classe:** {classe_selecionada}
                                        - **Meta:** {nova_meta} {unidade}
                                        - **Descri√ß√£o:** {descricao_meta if descricao_meta else 'Nenhuma descri√ß√£o fornecida'}
                                        - **Data de Defini√ß√£o:** {st.session_state.intervalos_por_classe[classe_selecionada]['data_meta']}
                                        - **Frotas Afetadas:** {len(frotas_da_classe)} equipamentos
                                        """)
                                    else:
                                        st.error("‚ùå A meta deve ser maior que zero!")
                
                with tab_meta_frota:
                    st.subheader("‚úèÔ∏è Definir Metas por Frota Individual")
                    st.write("Define uma meta de consumo personalizada para uma frota espec√≠fica. √ötil para casos especiais ou exce√ß√µes.")
                    
                    # Selecionar frota
                    frotas_disponiveis = df_frotas[df_frotas['ATIVO'] == 'ATIVO'].copy()
                    
                    if frotas_disponiveis.empty:
                        st.warning("Nenhuma frota ativa encontrada. Verifique se h√° frotas cadastradas e ativas.")
                    else:
                        frotas_disponiveis['label_meta'] = (
                            frotas_disponiveis['Cod_Equip'].astype(str) + " - " + 
                            frotas_disponiveis['DESCRICAO_EQUIPAMENTO'].fillna('') + 
                            " (" + frotas_disponiveis['PLACA'].fillna('Sem Placa') + ")"
                        )
                        
                        frota_selecionada = st.selectbox(
                            "Selecione a Frota:",
                            options=frotas_disponiveis['label_meta'].tolist(),
                            key="frota_meta_admin"
                        )
                        
                        if frota_selecionada:
                            # Obter c√≥digo da frota selecionada
                            cod_equip_frota = int(frota_selecionada.split(" - ")[0])
                            
                            # Obter dados da frota
                            dados_frota = frotas_disponiveis[frotas_disponiveis['Cod_Equip'] == cod_equip_frota].iloc[0]
                            classe_frota = dados_frota['Classe_Operacional']
                            tipo_controle_frota = dados_frota.get('Tipo_Controle', 'QUIL√îMETROS')
                            
                            # Verificar meta atual da classe
                            meta_classe = 0.0
                            if 'intervalos_por_classe' in st.session_state:
                                if classe_frota in st.session_state.intervalos_por_classe:
                                    meta_classe = st.session_state.intervalos_por_classe[classe_frota].get('meta_consumo', 0.0)
                            
                            # Verificar meta individual da frota
                            meta_individual = 0.0
                            if 'metas_individuals' not in st.session_state:
                                st.session_state.metas_individuals = {}
                            if cod_equip_frota in st.session_state.metas_individuals:
                                meta_individual = st.session_state.metas_individuals[cod_equip_frota].get('meta_consumo', 0.0)
                            
                            # Mostrar informa√ß√µes da frota
                            col_info1, col_info2 = st.columns(2)
                            with col_info1:
                                st.write(f"**C√≥digo:** {dados_frota['Cod_Equip']}")
                                st.write(f"**Descri√ß√£o:** {dados_frota['DESCRICAO_EQUIPAMENTO']}")
                                st.write(f"**Classe:** {classe_frota}")
                            with col_info2:
                                st.write(f"**Placa:** {dados_frota['PLACA']}")
                                st.write(f"**Tipo de Controle:** {tipo_controle_frota}")
                                if meta_classe > 0:
                                    st.write(f"**Meta da Classe:** {meta_classe}")
                                else:
                                    st.write("**Meta da Classe:** N√£o definida")
                            
                            # Formul√°rio para definir meta individual
                            with st.form(f"form_meta_frota_{cod_equip_frota}", clear_on_submit=False):
                                st.write(f"**Meta de Consumo Individual para: {dados_frota['DESCRICAO_EQUIPAMENTO']}**")
                                
                                # Determinar unidade baseada no tipo de controle
                                if tipo_controle_frota == 'HORAS':
                                    unidade = "L/h (Litros por Hora)"
                                    placeholder = "Ex: 4.5 para 4.5 litros por hora"
                                    step_value = 0.1
                                else:
                                    unidade = "Km/L (Quil√¥metros por Litro)"
                                    placeholder = "Ex: 2.8 para 2.8 km por litro"
                                    step_value = 0.1
                                
                                nova_meta_individual = st.number_input(
                                    f"Meta de Consumo Individual ({unidade})",
                                    min_value=0.0,
                                    step=step_value,
                                    value=float(meta_individual) if meta_individual > 0 else float(meta_classe) if meta_classe > 0 else 0.0,
                                    format="%.2f",
                                    help=placeholder,
                                    key=f"meta_frota_{cod_equip_frota}"
                                )
                                
                                # Campo para descri√ß√£o da meta
                                descricao_meta_individual = st.text_area(
                                    "Descri√ß√£o/Observa√ß√µes da Meta (opcional)",
                                    value=st.session_state.metas_individuals.get(cod_equip_frota, {}).get('descricao_meta', ''),
                                    placeholder="Ex: Meta personalizada devido a opera√ß√£o em terreno acidentado",
                                    max_chars=200,
                                    key=f"desc_meta_frota_{cod_equip_frota}"
                                )
                                
                                # Checkbox para sobrescrever meta da classe
                                sobrescrever_classe = st.checkbox(
                                    "Sobrescrever meta da classe (usar apenas esta meta individual)",
                                    value=meta_individual > 0,
                                    help="Se marcado, apenas a meta individual ser√° considerada, ignorando a meta da classe"
                                )
                                
                                submitted_meta_individual = st.form_submit_button("üíæ Salvar Meta Individual", type="primary")
                                
                                if submitted_meta_individual:
                                    if nova_meta_individual > 0:
                                        # Salvar meta individual
                                        st.session_state.metas_individuals[cod_equip_frota] = {
                                            'meta_consumo': nova_meta_individual,
                                            'descricao_meta': descricao_meta_individual,
                                            'unidade_meta': unidade,
                                            'data_meta': datetime.now().strftime('%d/%m/%Y %H:%M'),
                                            'sobrescrever_classe': sobrescrever_classe,
                                            'classe_operacional': classe_frota
                                        }
                                        
                                        st.success(f"‚úÖ Meta individual definida com sucesso para '{dados_frota['DESCRICAO_EQUIPAMENTO']}': **{nova_meta_individual} {unidade}**")
                                        
                                        # Mostrar resumo da meta
                                        st.info(f"""
                                        **üìã Resumo da Meta Individual:**
                                        - **Frota:** {dados_frota['DESCRICAO_EQUIPAMENTO']} (C√≥d: {cod_equip_frota})
                                        - **Meta Individual:** {nova_meta_individual} {unidade}
                                        - **Descri√ß√£o:** {descricao_meta_individual if descricao_meta_individual else 'Nenhuma descri√ß√£o fornecida'}
                                        - **Data de Defini√ß√£o:** {st.session_state.metas_individuals[cod_equip_frota]['data_meta']}
                                        - **Sobrescreve Classe:** {'Sim' if sobrescrever_classe else 'N√£o'}
                                        """)
                                    else:
                                        st.error("‚ùå A meta deve ser maior que zero!")
                
                with tab_meta_analise:
                    st.subheader("üìä An√°lise e Resumo das Metas")
                    st.write("Visualize e analise todas as metas de consumo definidas no sistema.")
                    
                    # Resumo geral das metas
                    col_res1, col_res2, col_res3 = st.columns(3)
                    
                    with col_res1:
                        total_classes = len([c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()])
                        classes_com_meta = 0
                        if 'intervalos_por_classe' in st.session_state:
                            classes_com_meta = len([c for c in st.session_state.intervalos_por_classe.keys() if st.session_state.intervalos_por_classe[c].get('meta_consumo', 0) > 0])
                        st.metric("Classes com Meta", f"{classes_com_meta}/{total_classes}")
                    
                    with col_res2:
                        total_frotas_ativas = len(df_frotas[df_frotas['ATIVO'] == 'ATIVO'])
                        frotas_com_meta_individual = 0
                        if 'metas_individuals' in st.session_state:
                            frotas_com_meta_individual = len(st.session_state.metas_individuals.keys())
                        st.metric("Frotas com Meta Individual", f"{frotas_com_meta_individual}/{total_frotas_ativas}")
                    
                    with col_res3:
                        total_metas = classes_com_meta + frotas_com_meta_individual
                        st.metric("Total de Metas", total_metas)
                    
                    # Tabela de metas por classe
                    if 'intervalos_por_classe' in st.session_state and any(st.session_state.intervalos_por_classe.values()):
                        st.write("**üìã Metas por Classe Operacional:**")
                        
                        dados_metas_classe = []
                        for classe, config in st.session_state.intervalos_por_classe.items():
                            if config.get('meta_consumo', 0) > 0:
                                dados_metas_classe.append({
                                    'Classe': classe,
                                    'Meta': f"{config.get('meta_consumo', 0):.2f}",
                                    'Unidade': config.get('unidade_meta', 'N/A'),
                                    'Descri√ß√£o': config.get('descricao_meta', 'Nenhuma'),
                                    'Data': config.get('data_meta', 'N/A'),
                                    'Frotas': len(df_frotas[df_frotas['Classe_Operacional'] == classe])
                                })
                        
                        if dados_metas_classe:
                            df_metas_classe = pd.DataFrame(dados_metas_classe)
                            st.dataframe(df_metas_classe, use_container_width=True)
                        else:
                            st.info("Nenhuma meta de classe definida.")
                    else:
                        st.info("Nenhuma meta de classe definida.")
                    
                    # Tabela de metas individuais
                    if 'metas_individuals' in st.session_state and st.session_state.metas_individuals:
                        st.write("**üìã Metas Individuais por Frota:**")
                        
                        dados_metas_individuals = []
                        for cod_equip, config in st.session_state.metas_individuals.items():
                            frota_info = df_frotas[df_frotas['Cod_Equip'] == cod_equip]
                            if not frota_info.empty:
                                dados_metas_individuals.append({
                                    'C√≥digo': cod_equip,
                                    'Frota': frota_info.iloc[0]['DESCRICAO_EQUIPAMENTO'],
                                    'Classe': config.get('classe_operacional', 'N/A'),
                                    'Meta': f"{config.get('meta_consumo', 0):.2f}",
                                    'Unidade': config.get('unidade_meta', 'N/A'),
                                    'Sobrescreve Classe': 'Sim' if config.get('sobrescrever_classe', False) else 'N√£o',
                                    'Data': config.get('data_meta', 'N/A')
                                })
                        
                        if dados_metas_individuals:
                            df_metas_individuals = pd.DataFrame(dados_metas_individuals)
                            st.dataframe(df_metas_individuals, use_container_width=True)
                        else:
                            st.info("Nenhuma meta individual definida.")
                    else:
                        st.info("Nenhuma meta individual definida.")
                    
                    # Bot√£o para exportar todas as metas
                    if (('intervalos_por_classe' in st.session_state and any(st.session_state.intervalos_por_classe.values())) or 
                        ('metas_individuals' in st.session_state and st.session_state.metas_individuals)):
                        
                        if st.button("üì• Exportar Relat√≥rio de Metas", type="secondary", use_container_width=True):
                            # Criar relat√≥rio
                            relatorio_metas = f"""
RELAT√ìRIO DE METAS DE CONSUMO - SISTEMA DE GEST√ÉO DE FROTAS
Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}

METAS POR CLASSE OPERACIONAL:
{chr(10).join([f"- {classe}: {config.get('meta_consumo', 0):.2f} {config.get('unidade_meta', 'N/A')} - {config.get('descricao_meta', 'Nenhuma descri√ß√£o')}" for classe, config in st.session_state.intervalos_por_classe.items() if config.get('meta_consumo', 0) > 0])}

METAS INDIVIDUAIS:
{chr(10).join([f"- C√≥digo {cod_equip}: {config.get('meta_consumo', 0):.2f} {config.get('unidade_meta', 'N/A')} - {config.get('descricao_meta', 'Nenhuma descri√ß√£o')}" for cod_equip, config in st.session_state.metas_individuals.items()])}

---
Relat√≥rio gerado automaticamente pelo sistema de gest√£o de frotas.
                            """
                            
                            st.download_button(
                                "üì• Download Relat√≥rio de Metas",
                                relatorio_metas.encode('utf-8'),
                                "relatorio_metas_consumo.txt",
                                "text/plain"
                            )

                # APAGUE O CONTE√öDO DA SUA "with tab_config:" E SUBSTITUA-O POR ESTE BLOCO

        if tab_config is not None:
            with tab_config:
                st.header("‚öôÔ∏è Configurar Manuten√ß√µes e Checklists")
                
                # Informa√ß√µes sobre as novas funcionalidades
                with st.expander("‚ÑπÔ∏è Sobre as Novas Funcionalidades de Componentes e Lubrificantes", expanded=False):
                    st.info("""
                    **üÜï Novas Funcionalidades Implementadas:**
                    
                    **1. Integra√ß√£o Componentes-Lubrificantes:**
                    - Agora voc√™ pode associar lubrificantes espec√≠ficos aos componentes
                    - Defina intervalos de troca personalizados para cada componente
                    - Escolha o tipo de manuten√ß√£o: Troca, Remonta ou Ambos
                    
                    **2. Registro Avan√ßado de Manuten√ß√£o:**
                    - Registre se foi uma troca ou remonta
                    - Sistema automaticamente atualiza o estoque de lubrificantes
                    - Hist√≥rico detalhado com tipo de servi√ßo e lubrificante utilizado
                    
                    **3. Indicadores na Ficha Individual:**
                    - Status atual de cada componente (km/horas restantes)
                    - Contagem separada de trocas vs remontas
                    - Informa√ß√µes do lubrificante associado
                    - Gr√°ficos de distribui√ß√£o por tipo de manuten√ß√£o
                    
                    **4. Gest√£o de Estoque Autom√°tica:**
                    - Estoque de lubrificantes √© atualizado automaticamente
                    - Controle de entrada e sa√≠da integrado
                    """)
                
                # --- Gest√£o de Componentes e Lubrificantes ---
                exp_comp_open = st.session_state.get('open_expander_config_componentes', False)
                with st.expander("Configurar Componentes e Lubrificantes por Classe", expanded=bool(exp_comp_open)):
                    # Garantir que a tabela de lubrificantes existe
                    ensure_lubrificantes_schema()
                    
                    classes_operacionais = sorted([c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()])
                    df_comp_regras = get_component_rules() # Busca os dados mais recentes
                    
                    # Carregar lubrificantes dispon√≠veis
                    try:
                        conn = sqlite3.connect(DB_PATH)
                        df_lubrificantes = pd.read_sql("SELECT id, nome, tipo, viscosidade FROM lubrificantes ORDER BY nome", conn)
                        conn.close()
                    except Exception as e:
                        # Em caso de erro, criar DataFrame vazio
                        df_lubrificantes = pd.DataFrame(columns=['id', 'nome', 'tipo', 'viscosidade'])
                        st.warning("‚ö†Ô∏è Tabela de lubrificantes n√£o encontrada. Cadastre lubrificantes na aba 'Gest√£o de Lubrificantes'.")

                    # Selecionar classe para configurar
                    classe_selecionada = st.selectbox(
                        "Selecione a Classe Operacional para configurar:",
                        options=classes_operacionais,
                        key="classe_config_select"
                    )
                    
                    if classe_selecionada:
                        st.subheader(f"Configura√ß√£o da Classe: {classe_selecionada}")
                        
                        # Mostrar componentes existentes em uma tabela compacta
                        regras_atuais = df_comp_regras[df_comp_regras['classe_operacional'] == classe_selecionada]
                        
                        if not regras_atuais.empty:
                            st.write("**Componentes Configurados:**")
                            
                            # Criar DataFrame para exibi√ß√£o
                            df_display = regras_atuais.copy()
                            
                            # Verificar se a coluna lubrificante_id existe
                            if 'lubrificante_id' in df_display.columns:
                                df_display['Lubrificante'] = df_display['lubrificante_id'].apply(
                                    lambda x: df_lubrificantes[df_lubrificantes['id'] == x]['nome'].iloc[0] if x and not df_lubrificantes[df_lubrificantes['id'] == x].empty else "Sem lubrificante"
                                )
                            else:
                                # Se a coluna n√£o existe, criar coluna vazia
                                df_display['lubrificante_id'] = None
                                df_display['Lubrificante'] = "Sem lubrificante"
                            
                            df_display['Unidade'] = 'km' if df_frotas[df_frotas['Classe_Operacional'] == classe_selecionada]['Tipo_Controle'].iloc[0] == 'QUIL√îMETROS' else 'h'
                            df_display['Intervalo'] = df_display['intervalo_padrao'].astype(str) + ' ' + df_display['Unidade']
                            
                            # Exibir tabela com a√ß√µes
                            for _, regra in regras_atuais.iterrows():
                                with st.container():
                                    col1, col2, col3, col4, col5 = st.columns([3, 1, 1, 1, 1])
                                    
                                    with col1:
                                        st.write(f"**{regra['nome_componente']}**")
                                    
                                    with col2:
                                        st.write(f"{regra['intervalo_padrao']} {df_display['Unidade'].iloc[0]}")
                                    
                                    with col3:
                                        if 'Lubrificante' in df_display.columns:
                                            lub_info = df_display[df_display['nome_componente'] == regra['nome_componente']]['Lubrificante'].iloc[0]
                                            if lub_info != "Sem lubrificante":
                                                # Buscar estoque do lubrificante
                                                try:
                                                    conn = sqlite3.connect(DB_PATH)
                                                    df_lub_estoque = pd.read_sql(
                                                        "SELECT quantidade_estoque, unidade FROM lubrificantes WHERE nome = ?", 
                                                        conn, params=(lub_info,)
                                                    )
                                                    conn.close()
                                                    
                                                    if not df_lub_estoque.empty:
                                                        estoque = df_lub_estoque.iloc[0]['quantidade_estoque']
                                                        unidade = df_lub_estoque.iloc[0]['unidade']
                                                        
                                                        # Determinar cor do estoque
                                                        if estoque > 10:
                                                            cor_estoque = "üü¢"
                                                        elif estoque > 3:
                                                            cor_estoque = "üü°"
                                                        else:
                                                            cor_estoque = "üî¥"
                                                        
                                                        st.write(f"{lub_info}")
                                                        st.write(f"{cor_estoque} {estoque} {unidade}")
                                                    else:
                                                        st.write(lub_info)
                                                except:
                                                    st.write(lub_info)
                                            else:
                                                st.write("Sem lubrificante")
                                        else:
                                            st.write("Sem lubrificante")
                                    
                                    with col4:
                                        tipo_manut = regra.get('tipo_manutencao', 'Troca') if 'tipo_manutencao' in regra else 'Troca'
                                        st.write(tipo_manut)
                                    
                                    with col5:
                                        # Bot√µes de a√ß√£o
                                        col_edit, col_del = st.columns(2)
                                        with col_edit:
                                            if st.button("‚úèÔ∏è", key=f"edit_comp_{regra['id_regra']}", help="Editar componente"):
                                                st.session_state['editing_component'] = regra['id_regra']
                                                st.session_state['editing_component_data'] = regra.to_dict()
                                                rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                        with col_del:
                                            if st.button("üóëÔ∏è", key=f"del_comp_{regra['id_regra']}", help="Remover componente"):
                                                delete_component_rule(regra['id_regra'])
                                                rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                    
                                    st.markdown("---")
                        else:
                            st.info("Nenhum componente configurado para esta classe.")
                        
                        st.markdown("---")
                        
                        # Verificar se est√° editando um componente
                        editing_component = st.session_state.get('editing_component')
                        editing_data = st.session_state.get('editing_component_data')
                        
                        if editing_component and editing_data:
                            # Formul√°rio de edi√ß√£o
                            with st.form(f"form_edit_{classe_selecionada}", clear_on_submit=True):
                                st.write("**‚úèÔ∏è Editar Componente**")
                                
                                col1, col2 = st.columns(2)
                                
                                with col1:
                                    novo_comp_nome = st.text_input("Nome do Componente", value=editing_data['nome_componente'], key=f"edit_nome_{classe_selecionada}")
                                    novo_comp_intervalo = st.number_input("Intervalo de Troca (km/h)", min_value=1, step=50, value=editing_data['intervalo_padrao'], key=f"edit_int_{classe_selecionada}")
                                
                                with col2:
                                    # Sele√ß√£o de lubrificante (opcional)
                                    if not df_lubrificantes.empty:
                                        lubrificantes_opcoes = ["Sem lubrificante"] + df_lubrificantes['nome'].tolist()
                                        lub_atual = "Sem lubrificante"
                                        if 'lubrificante_id' in editing_data and editing_data.get('lubrificante_id'):
                                            lub_info = df_lubrificantes[df_lubrificantes['id'] == editing_data['lubrificante_id']]
                                            if not lub_info.empty:
                                                lub_atual = lub_info.iloc[0]['nome']
                                        
                                        index_lub = lubrificantes_opcoes.index(lub_atual) if lub_atual in lubrificantes_opcoes else 0
                                        lubrificante_selecionado = st.selectbox("Lubrificante (opcional)", options=lubrificantes_opcoes, index=index_lub, key=f"edit_lub_{classe_selecionada}")
                                    else:
                                        lubrificante_selecionado = st.selectbox("Lubrificante (opcional)", options=["Sem lubrificante"], key=f"edit_lub_{classe_selecionada}")
                                        st.info("üí° Cadastre lubrificantes na aba 'Gest√£o de Lubrificantes' para associ√°-los aos componentes.")
                                    
                                    # Tipo de manuten√ß√£o
                                    tipo_atual = editing_data.get('tipo_manutencao', 'Troca') if 'tipo_manutencao' in editing_data else 'Troca'
                                    tipo_opcoes = ["Troca", "Remonta", "Ambos"]
                                    index_tipo = tipo_opcoes.index(tipo_atual) if tipo_atual in tipo_opcoes else 0
                                    tipo_manutencao = st.selectbox("Tipo de Manuten√ß√£o", options=tipo_opcoes, index=index_tipo, key=f"edit_tipo_{classe_selecionada}")
                                
                                col_save, col_cancel = st.columns(2)
                                with col_save:
                                    if st.form_submit_button("üíæ Salvar Altera√ß√µes"):
                                        if novo_comp_nome:
                                            # Obter ID do lubrificante se selecionado
                                            lubrificante_id = None
                                            if lubrificante_selecionado != "Sem lubrificante":
                                                lub_info = df_lubrificantes[df_lubrificantes['nome'] == lubrificante_selecionado]
                                                if not lub_info.empty:
                                                    lubrificante_id = lub_info.iloc[0]['id']
                                            
                                            success, message = update_component_rule(editing_component, novo_comp_nome, novo_comp_intervalo, lubrificante_id, tipo_manutencao)
                                            if success:
                                                st.success(message)
                                                # Limpar estado de edi√ß√£o
                                                st.session_state.pop('editing_component', None)
                                                st.session_state.pop('editing_component_data', None)
                                                rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                            else:
                                                st.error(message)
                                        else:
                                            st.warning("Por favor, informe o nome do componente.")
                                
                                with col_cancel:
                                    if st.form_submit_button("‚ùå Cancelar"):
                                        st.session_state.pop('editing_component', None)
                                        st.session_state.pop('editing_component_data', None)
                                        rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                        
                        # Formul√°rio para adicionar novo componente
                        with st.form(f"form_add_{classe_selecionada}", clear_on_submit=True):
                            st.write("**‚ûï Adicionar Novo Componente**")
                            
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                novo_comp_nome = st.text_input("Nome do Componente", key=f"nome_{classe_selecionada}")
                                novo_comp_intervalo = st.number_input("Intervalo de Troca (km/h)", min_value=1, step=50, key=f"int_{classe_selecionada}")
                                novo_comp_capacidade = st.number_input("Capacidade (litros)", min_value=0.0, step=0.5, format="%.1f", key=f"cap_{classe_selecionada}")
                            
                            with col2:
                                    # Sele√ß√£o de lubrificante (opcional)
                                if not df_lubrificantes.empty:
                                    lubrificantes_opcoes = ["Sem lubrificante"] + df_lubrificantes['nome'].tolist()
                                    lubrificante_selecionado = st.selectbox("Lubrificante (opcional)", options=lubrificantes_opcoes, key=f"lub_{classe_selecionada}")
                                else:
                                    lubrificante_selecionado = st.selectbox("Lubrificante (opcional)", options=["Sem lubrificante"], key=f"lub_{classe_selecionada}")
                                    st.info("üí° Cadastre lubrificantes na aba 'Gest√£o de Lubrificantes' para associ√°-los aos componentes.")
                                    
                                    # Tipo de manuten√ß√£o
                                tipo_manutencao = st.selectbox("Tipo de Manuten√ß√£o", options=["Troca", "Remonta", "Ambos"], key=f"tipo_{classe_selecionada}")
                            
                            # Informa√ß√µes sobre tipos de manuten√ß√£o
                            st.info("""
                            **üí° Sobre Tipos de Manuten√ß√£o:**
                            
                            **üîÑ Troca vs Remonta:**
                            
                            **Troca:**
                            - Reinicia o contador de km/horas
                            - Exemplos: troca de √≥leo, filtros, correias
                            - Usado para manuten√ß√µes que "zeram" o ciclo
                            
                            **Remonta:**
                            - N√ÉO reinicia o contador de km/horas
                            - Exemplos: ajuste, limpeza, reparo
                            - Usado para manuten√ß√µes complementares
                            
                            **Ambos:**
                            - Permite escolher entre troca ou remonta
                            - Flex√≠vel para componentes que podem ter ambos os tipos
                            
                            **‚ö†Ô∏è Importante:** Apenas TROCAS reiniciam o contador para calcular pr√≥xima manuten√ß√£o!
                            """)
                            
                            if st.form_submit_button("‚ûï Adicionar Componente"):
                                if novo_comp_nome:
                                    # Obter ID do lubrificante se selecionado
                                    lubrificante_id = None
                                    if lubrificante_selecionado != "Sem lubrificante":
                                        lub_info = df_lubrificantes[df_lubrificantes['nome'] == lubrificante_selecionado]
                                        if not lub_info.empty:
                                            lubrificante_id = lub_info.iloc[0]['id']
                                    
                                    success, message = add_component_rule_advanced(classe_selecionada, novo_comp_nome, novo_comp_intervalo, lubrificante_id, tipo_manutencao, novo_comp_capacidade)
                                    if success:
                                        st.success(message)
                                        st.session_state['open_expander_config_componentes'] = True
                                        rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                    else:
                                        st.error(message)
                                else:
                                    st.warning("Por favor, informe o nome do componente.")

                # --- Gest√£o de Checklists ---
                exp_chk_open = st.session_state.get('open_expander_config_checklists', True)
                with st.expander("Configurar Checklists Di√°rios", expanded=bool(exp_chk_open)):
                    regras_checklist = get_checklist_rules()
                    
                    # Se√ß√£o de checklists existentes
                    if not regras_checklist.empty:
                        st.subheader("üìã Modelos de Checklist Existentes")
                        
                        # Criar abas para cada checklist
                        for _, regra in regras_checklist.iterrows():
                            with st.container():
                                col1, col2, col3, col4, col5 = st.columns([3, 1, 1, 1, 1])
                                
                                with col1:
                                    st.write(f"**{regra['titulo_checklist']}**")
                                
                                with col2:
                                    st.write(regra['classe_operacional'])
                                
                                with col3:
                                    st.write(regra['frequencia'])
                                
                                with col4:
                                    st.write(regra['turno'])
                                
                                with col5:
                                    # Bot√µes de a√ß√£o
                                    col_edit_chk, col_del_chk = st.columns(2)
                                    with col_edit_chk:
                                        if st.button("‚úèÔ∏è", key=f"edit_chk_{regra['id_regra']}", help="Editar checklist"):
                                            st.session_state['editing_checklist'] = regra['id_regra']
                                            st.session_state['editing_checklist_data'] = regra.to_dict()
                                            rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                    with col_del_chk:
                                        if st.button("üóëÔ∏è", key=f"del_chk_{regra['id_regra']}", help="Remover checklist"):
                                            # Buscar e excluir itens primeiro
                                            itens_checklist = get_checklist_items(regra['id_regra'])
                                            for _, item in itens_checklist.iterrows():
                                                delete_checklist_item(item['id_item'])
                                            # Excluir regra
                                            delete_checklist_rule(regra['id_regra'])
                                            st.success("Checklist removido com sucesso!")
                                            rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                
                                # Mostrar itens do checklist
                                itens_checklist = get_checklist_items(regra['id_regra'])
                                if not itens_checklist.empty:
                                    st.write(f"**Itens do checklist '{regra['titulo_checklist']}':**")
                                    for _, item in itens_checklist.iterrows():
                                        col_item, col_del_item = st.columns([4, 1])
                                        with col_item:
                                            st.write(f"‚Ä¢ {item['nome_item']}")
                                        with col_del_item:
                                            if st.button("üóëÔ∏è", key=f"del_item_{item['id_item']}", help="Remover item"):
                                                delete_checklist_item(item['id_item'])
                                                st.success("Item removido!")
                                                rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                
                                st.markdown("---")
                    else:
                        st.info("Nenhum modelo de checklist criado.")
                    
                    # Verificar se est√° editando um checklist
                    editing_checklist = st.session_state.get('editing_checklist')
                    editing_checklist_data = st.session_state.get('editing_checklist_data')
                    
                    if editing_checklist and editing_checklist_data:
                        # Formul√°rio de edi√ß√£o de checklist
                        with st.form(f"form_edit_checklist", clear_on_submit=True):
                            st.subheader("‚úèÔ∏è Editar Checklist")
                            
                            col1_edit, col2_edit = st.columns(2)
                            
                            with col1_edit:
                                novo_titulo = st.text_input("T√≠tulo do Checklist", value=editing_checklist_data['titulo_checklist'], key="edit_chk_titulo")
                                nova_frequencia = st.selectbox("Frequ√™ncia", options=['Di√°rio', 'Dias Pares', 'Dias √çmpares'], 
                                                             index=['Di√°rio', 'Dias Pares', 'Dias √çmpares'].index(editing_checklist_data['frequencia']), 
                                                             key="edit_chk_freq")
                            
                            with col2_edit:
                                nova_classe = st.selectbox("Classe Operacional", options=classes_operacionais, 
                                                         index=classes_operacionais.index(editing_checklist_data['classe_operacional']), 
                                                         key="edit_chk_classe")
                                novo_turno = st.selectbox("Turno", options=['Manh√£', 'Noite', 'N/A'], 
                                                        index=['Manh√£', 'Noite', 'N/A'].index(editing_checklist_data['turno']), 
                                                        key="edit_chk_turno")
                            
                            # Mostrar itens atuais
                            itens_atuais = get_checklist_items(editing_checklist)
                            if not itens_atuais.empty:
                                st.write("**Itens atuais:**")
                                for _, item in itens_atuais.iterrows():
                                    st.write(f"‚Ä¢ {item['nome_item']}")
                            
                            st.write("**Novos itens (substituir√£o os atuais):**")
                            novos_itens_texto = st.text_area("Itens do Checklist", height=150, key="edit_chk_itens", 
                                                           placeholder="N√≠vel do √ìleo\nPress√£o dos Pneus\nVerificar Facas")
                            
                            col_save_chk, col_cancel_chk = st.columns(2)
                            with col_save_chk:
                                if st.form_submit_button("üíæ Salvar Altera√ß√µes"):
                                    if novo_titulo and novos_itens_texto:
                                        # Atualizar regra
                                        success, msg = edit_checklist_rule(editing_checklist, editing_checklist_data['classe_operacional'], 
                                                                         novo_titulo, editing_checklist_data['turno'], nova_frequencia)
                                        if success:
                                            # Remover itens antigos
                                            for _, item in itens_atuais.iterrows():
                                                delete_checklist_item(item['id_item'])
                                            
                                            # Adicionar novos itens
                                            itens_lista = [item.strip() for item in novos_itens_texto.split('\n') if item.strip()]
                                            for item in itens_lista:
                                                add_checklist_item(editing_checklist, item)
                                            
                                            st.success("Checklist atualizado com sucesso!")
                                            st.session_state.pop('editing_checklist', None)
                                            st.session_state.pop('editing_checklist_data', None)
                                            rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                                        else:
                                            st.error(msg)
                                    else:
                                        st.warning("Por favor, preencha todos os campos obrigat√≥rios.")
                            
                            with col_cancel_chk:
                                if st.form_submit_button("‚ùå Cancelar"):
                                    st.session_state.pop('editing_checklist', None)
                                    st.session_state.pop('editing_checklist_data', None)
                                    rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                    
                    # Formul√°rio para adicionar novo checklist
                    with st.form("form_add_checklist", clear_on_submit=True):
                        st.subheader("‚ûï Criar Novo Modelo de Checklist")
                        
                        col1_form, col2_form = st.columns(2)
                        nova_classe = col1_form.selectbox("Aplicar √† Classe Operacional", options=classes_operacionais, key="chk_classe")
                        novo_titulo = col1_form.text_input("T√≠tulo do Checklist (ex: Verifica√ß√£o Matinal Colhedoras)", key="chk_titulo")
                        nova_frequencia = col2_form.selectbox("Frequ√™ncia", options=['Di√°rio', 'Dias Pares', 'Dias √çmpares'], key="chk_freq")
                        novo_turno = col2_form.selectbox("Turno", options=['Manh√£', 'Noite', 'N/A'], key="chk_turno")
                        
                        st.write("**Itens a serem verificados (um por linha):**")
                        novos_itens_texto = st.text_area("Itens do Checklist", height=150, key="chk_itens", placeholder="N√≠vel do √ìleo\nPress√£o dos Pneus\nVerificar Facas")
                        
                        if st.form_submit_button("‚ûï Salvar Novo Modelo de Checklist"):
                            if nova_classe and novo_titulo and novos_itens_texto:
                                # Ordem correta dos par√¢metros: (classe, t√≠tulo, turno, frequ√™ncia)
                                rule_id = add_checklist_rule_and_get_id(nova_classe, novo_titulo, novo_turno, nova_frequencia)
                                if rule_id is None:
                                    st.error("N√£o foi poss√≠vel criar a regra do checklist.")
                                else:
                                    itens_lista = [item.strip() for item in novos_itens_texto.split('\n') if item.strip()]
                                    for item in itens_lista:
                                        add_checklist_item(rule_id, item)
                                    st.success("Novo modelo de checklist criado com sucesso!")
                                    st.session_state['open_expander_config_checklists'] = True
                                    rerun_keep_tab("‚öôÔ∏è Configura√ß√µes")
                            else:
                                st.warning("Por favor, preencha todos os campos obrigat√≥rios.")
                        
        if tab_importar is not None:
            with tab_importar:
                st.header("üì§ Importar Dados")
                sub_tab_abastec, sub_tab_motoristas, sub_tab_precos, sub_tab_pneus, sub_tab_lubrificantes, sub_tab_componentes, sub_tab_sucateamento = st.tabs(
                    ["‚õΩ Abastecimentos", "üë§ Motoristas", "üí≤ Pre√ßos de Combust√≠vel", "üöö Pneus", "üõ¢Ô∏è Lubrificantes", "‚öôÔ∏è Componentes", "üìä An√°lise Sucateamento"]
                )

                with sub_tab_abastec:
                    st.subheader("Importar Novos Abastecimentos de uma Planilha")
                    st.info("Carregue m√∫ltiplos abastecimentos de uma vez (Excel .xlsx). Colunas: `C√≥d. Equip.`, `Data`, `Qtde Litros`, `Hod. Hor. Atual`, `Safra`, `M√™s`, `Classe Operacional`, opcional `Matricula`, `Cod_Pessoa`.")
                    arquivo_carregado = st.file_uploader(
                        "Selecione a sua planilha de abastecimentos",
                        type=['xlsx'], key="upl_abast"
                    )
                    if arquivo_carregado is not None:
                        st.markdown("---")
                        st.write("Pr√©-visualiza√ß√£o:")
                        try:
                            df_preview = pd.read_excel(arquivo_carregado)
                            st.dataframe(df_preview.head())
                            if st.button("Confirmar e Inserir Dados", type="primary"):
                                with st.spinner("Importando dados..."):
                                    num_inseridos, num_duplicados, mensagem = importar_abastecimentos_de_planilha(DB_PATH, arquivo_carregado)
                                if num_inseridos > 0:
                                    msg_sucesso = f"{num_inseridos} registos importados."
                                    if num_duplicados > 0:
                                        msg_sucesso += f" {num_duplicados} duplicados ignorados."
                                    st.success(msg_sucesso)
                                    rerun_keep_tab("üì§ Importar Dados")
                                else:
                                    st.error(mensagem)
                        except Exception as e:
                            st.error(f"N√£o foi poss√≠vel ler a planilha: {e}")

                with sub_tab_motoristas:
                    st.subheader("Importar Motoristas por Planilha")
                    st.info("Colunas esperadas: `Matricula`, `Nome`, opcional `Cod_Pessoa`. A matr√≠cula ser√° exibida nos gr√°ficos; na consulta ser√° mostrada matr√≠cula e nome.")
                    arquivo_motoristas = st.file_uploader("Selecione a planilha de motoristas", type=['xlsx'], key="upl_motoristas")
                    if arquivo_motoristas is not None:
                            try:
                                df_prev = pd.read_excel(arquivo_motoristas)
                                st.dataframe(df_prev.head())
                                if st.button("Confirmar e Inserir Motoristas", type="primary"):
                                    with st.spinner("Importando motoristas..."):
                                        ensure_motoristas_schema()
                                        inseridos, duplicados, msg = importar_motoristas_de_planilha(DB_PATH, arquivo_motoristas)
                                    if inseridos > 0:
                                        st.success(f"{msg}")
                                        rerun_keep_tab("üì§ Importar Dados")
                                    else:
                                        st.error(msg)
                            except Exception as e:
                                st.error(f"Erro ao ler planilha: {e}")

                with sub_tab_precos:
                    st.subheader("Definir Pre√ßos por Tipo de Combust√≠vel")
                    ok, msg = ensure_precos_combustivel_schema()
                    if not ok:
                        st.warning(msg)
                        precos_map = get_precos_combustivel_map()
                        tipos = ['Diesel S500', 'Diesel S10', 'Gasolina', 'Etanol', 'Biodiesel']
                        cols = st.columns(5)
                        novos_precos = {}
                        for i, t in enumerate(tipos):
                            with cols[i % 5]:
                                valor = st.number_input(f"{t}", min_value=0.0, format="%.3f", value=float(precos_map.get(t) or 0.0), key=f"preco_{t}")
                                novos_precos[t] = valor
                        if st.button("Salvar Pre√ßos", type="secondary"):
                            with st.spinner("Salvando pre√ßos..."):
                                ok_all = True
                                for t, p in novos_precos.items():
                                    ok, _ = upsert_preco_combustivel(t, float(p) if p is not None else None)
                                    ok_all = ok_all and ok
                                if ok_all:
                                    st.success("Pre√ßos atualizados.")
                                else:
                                    st.warning("Alguns pre√ßos podem n√£o ter sido salvos.")
                                    
                with sub_tab_pneus:
                    st.subheader("Importar Hist√≥rico de Pneus")
                    st.info(
                            "Colunas obrigat√≥rias na planilha: `Cod_Equip`, `posicao`, `marca`, `modelo`, `numero_fogo`, `data_instalacao`, `hodometro_instalacao`. Opcional: `observacoes`.\n"
                            "Cada pneu ser√° vinculado √† frota pelo campo `Cod_Equip`."
                        )
                    arquivo_pneus = st.file_uploader("Selecione a planilha de pneus", type=['xlsx'], key="upl_pneus")
                    if arquivo_pneus is not None:
                            try:
                                df_prev = pd.read_excel(arquivo_pneus)
                                st.dataframe(df_prev.head())
                                if st.button("Confirmar e Inserir Pneus", type="primary"):
                                    ensure_pneus_schema()
                                    inseridos, duplicados, msg = importar_pneus_de_planilha(DB_PATH, arquivo_pneus)
                                    if inseridos > 0:
                                        st.success(f"{msg}")
                                        st.rerun()
                                    else:
                                        st.error(msg)
                            except Exception as e:
                                st.error(f"Erro ao ler planilha: {e}")

                    st.markdown("---")
                    st.subheader("Cadastrar Pneus Manualmente")
                    with st.form("form_add_pneu", clear_on_submit=True):
                            cod_equip = st.number_input("C√≥digo da Frota", min_value=1, step=1)
                            posicao = st.text_input("Posi√ß√£o do Pneu (ex: Dianteiro Esquerdo)")
                            marca = st.text_input("Marca")
                            modelo = st.text_input("Modelo")
                            numero_fogo = st.text_input("N¬∫ de Fogo do Pneu")
                            data_instalacao = st.date_input("Data de Instala√ß√£o")
                            hodometro_instalacao = st.number_input("Leitura na Instala√ß√£o", min_value=0.0, format="%.2f")
                            
                            observacoes = st.text_area("Observa√ß√µes", height=50)
                            status = st.selectbox("Status do Pneu", ["Ativo", "Sucateado", "Reformado"])
                            vida_atual = st.number_input("Vida Atual do Pneu", min_value=1, step=1, value=1)
                            if st.form_submit_button("Salvar Pneu"):
                                ensure_pneus_schema()
                                try:
                                    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                        cur = conn.cursor()
                                        cur.execute(
                                            "INSERT INTO pneus_historico (Cod_Equip, posicao, marca, modelo, numero_fogo, data_instalacao, hodometro_instalacao, observacoes, status, vida_atual) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                                            (cod_equip, posicao, marca, modelo, numero_fogo, data_instalacao.strftime("%Y-%m-%d"), hodometro_instalacao, observacoes, status, vida_atual)
                                        )
                                        conn.commit()
                                    st.success("Pneu cadastrado com sucesso!")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Erro ao cadastrar pneu: {e}")

                    st.markdown("---")
                    st.subheader("Consultar Hist√≥rico de Pneus por Frota")
                    cod_equip_pneu = st.number_input("C√≥digo da Frota para consulta", min_value=1, step=1)
                    filtro_marca = st.text_input("Filtrar por Marca (opcional)")
                    filtro_posicao = st.text_input("Filtrar por Posi√ß√£o (opcional)")
                    if cod_equip_pneu:
                            df_hist_pneus = get_pneus_historico(cod_equip_pneu)
                            if filtro_marca:
                                df_hist_pneus = df_hist_pneus[df_hist_pneus['marca'].str.contains(filtro_marca, case=False, na=False)]
                            if filtro_posicao:
                                df_hist_pneus = df_hist_pneus[df_hist_pneus['posicao'].str.contains(filtro_posicao, case=False, na=False)]
                            if not df_hist_pneus.empty:
                                # Mostrar estat√≠sticas resumidas
                                col1, col2, col3, col4 = st.columns(4)
                                with col1:
                                    st.metric("Total de Pneus", len(df_hist_pneus), delta=None)
                                with col2:
                                    ativos = len(df_hist_pneus[df_hist_pneus['status'] == 'Ativo'])
                                    st.metric("Pneus Ativos", ativos, delta=None)
                                with col3:
                                    sucateados = len(df_hist_pneus[df_hist_pneus['status'] == 'Sucateado'])
                                    st.metric("Pneus Sucateados", sucateados, delta=None)
                                with col4:
                                    vida_media = df_hist_pneus[df_hist_pneus['status'] == 'Ativo']['vida_atual'].mean()
                                    st.metric("Vida M√©dia Atual", f"{vida_media:.1f}" if not pd.isna(vida_media) else "N/A", delta=None)
                                
                                # Filtros avan√ßados
                                st.markdown("""
                                <div style="
                                    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
                                    padding: 16px;
                                    border-radius: 8px;
                                    margin: 20px 0;
                                    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
                                ">
                                    <h3 style="
                                        color: white; 
                                        margin: 0; 
                                        font-size: 18px; 
                                        font-weight: 600;
                                        text-align: center;
                                    ">
                                        üîç Filtros Avan√ßados
                                    </h3>
                                </div>
                                """, unsafe_allow_html=True)
                                col_filtro1, col_filtro2, col_filtro3 = st.columns(3)
                                with col_filtro1:
                                    filtro_status = st.selectbox("Status", options=['Todos', 'Ativo', 'Sucateado'])
                                with col_filtro2:
                                    filtro_vida = st.selectbox("Vida Atual", options=['Todas', '1¬™', '2¬™', '3¬™', '4¬™+'])
                                with col_filtro3:
                                    filtro_data = st.date_input("Instalados a partir de", value=None)
                                
                                # Aplicar filtros
                                df_filtrado = df_hist_pneus.copy()
                                if filtro_status != 'Todos':
                                    df_filtrado = df_filtrado[df_filtrado['status'] == filtro_status]
                                if filtro_vida != 'Todas':
                                    if filtro_vida == '1¬™':
                                        df_filtrado = df_filtrado[df_filtrado['vida_atual'] == 1]
                                    elif filtro_vida == '2¬™':
                                        df_filtrado = df_filtrado[df_filtrado['vida_atual'] == 2]
                                    elif filtro_vida == '3¬™':
                                        df_filtrado = df_filtrado[df_filtrado['vida_atual'] == 3]
                                    elif filtro_vida == '4¬™+':
                                        df_filtrado = df_filtrado[df_filtrado['vida_atual'] >= 4]
                                if filtro_data:
                                    df_filtrado = df_filtrado[pd.to_datetime(df_filtrado['data_instalacao']) >= filtro_data]
                                
                                # Mostrar resultados filtrados em cards
                                st.markdown(f"""
                                <div style="
                                    background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%);
                                    padding: 16px;
                                    border-radius: 8px;
                                    margin: 20px 0;
                                    box-shadow: 0 4px 12px rgba(17, 153, 142, 0.3);
                                ">
                                    <h3 style="
                                        color: white; 
                                        margin: 0; 
                                        font-size: 18px; 
                                        font-weight: 600;
                                        text-align: center;
                                    ">
                                        üìä Resultados ({len(df_filtrado)} pneus)
                                    </h3>
                                </div>
                                """, unsafe_allow_html=True)
                                if not df_filtrado.empty:
                                    for _, pneu in df_filtrado.iterrows():
                                        with st.container():
                                            col_info, col_acoes = st.columns([4, 1])
                                            with col_info:
                                                # Card do pneu
                                                st.markdown(f'''
                                                <div style="
                                                    border: 1px solid {'#00ff88' if pneu['status'] == 'Ativo' else '#ff6b6b'}; 
                                                    border-radius: 8px; 
                                                    padding: 16px; 
                                                    margin: 12px 0; 
                                                    background: linear-gradient(135deg, {'rgba(0, 255, 136, 0.1)' if pneu['status'] == 'Ativo' else 'rgba(255, 107, 107, 0.1)'}, {'rgba(0, 255, 136, 0.05)' if pneu['status'] == 'Ativo' else 'rgba(255, 107, 107, 0.05)'});
                                                    box-shadow: 0 2px 8px {'rgba(0, 255, 136, 0.2)' if pneu['status'] == 'Ativo' else 'rgba(255, 107, 107, 0.2)'};
                                                    transition: all 0.3s ease;
                                                ">
                                                    <h4 style="
                                                        margin: 0 0 12px 0; 
                                                        color: {'#00cc6a' if pneu['status'] == 'Ativo' else '#ff4757'}; 
                                                        font-size: 18px; 
                                                        font-weight: 600;
                                                        border-bottom: 2px solid {'#00ff88' if pneu['status'] == 'Ativo' else '#ff6b6b'};
                                                        padding-bottom: 8px;
                                                    ">
                                                        {pneu['marca']} {pneu['modelo']} - {pneu['posicao']}
                                                    </h4>
                                                    <p style="
                                                        margin: 8px 0; 
                                                        font-size: 14px; 
                                                        color: #E8E8E8; 
                                                        line-height: 1.4;
                                                    ">
                                                        <strong style="color: {'#00ff88' if pneu['status'] == 'Ativo' else '#ff6b6b'}">N¬∫ Fogo:</strong> {pneu.get('numero_fogo', 'N/A')} | 
                                                        <strong style="color: {'#00ff88' if pneu['status'] == 'Ativo' else '#ff6b6b'}">Status:</strong> {pneu['status']} | 
                                                        <strong style="color: {'#00ff88' if pneu['status'] == 'Ativo' else '#ff6b6b'}">Vida Atual:</strong> {pneu['vida_atual']}¬™
                                                    </p>
                                                    <p style="
                                                        margin: 8px 0; 
                                                        font-size: 13px; 
                                                        color: #B8B8B8; 
                                                        line-height: 1.3;
                                                    ">
                                                        <strong style="color: #E8E8E8">Instalado:</strong> {pneu['data_instalacao']} | 
                                                        <strong style="color: #E8E8E8">Hod√¥metro:</strong> {pneu['hodometro_instalacao']:,.0f}
                                                    </p>
                                                </div>
                                                ''', unsafe_allow_html=True)
                                            with col_acoes:
                                                if pneu['status'] == 'Ativo':
                                                    st.button("‚úèÔ∏è", key=f"edit_{pneu['id']}", help="Editar pneu")
                                                st.button("üóëÔ∏è", key=f"delete_{pneu['id']}", help="Excluir pneu")
                                # Edi√ß√£o e exclus√£o
                                st.markdown("### Editar ou Excluir Pneus")
                                df_hist_pneus['label'] = (
                                    df_hist_pneus['id'].astype(str) + " | " +
                                    df_hist_pneus['posicao'] + " | " +
                                    df_hist_pneus['marca'] + " | " +
                                    df_hist_pneus['modelo'] + " | " +
                                    df_hist_pneus.get('numero_fogo', '').fillna('')
                                )
                                pneu_sel = st.selectbox("Selecione o pneu para editar/excluir", options=df_hist_pneus['label'])
                                if pneu_sel:
                                    pneu_row = df_hist_pneus[df_hist_pneus['label'] == pneu_sel].iloc[0]
                                    with st.expander("Editar Pneu"):
                                        with st.form("form_edit_pneu", clear_on_submit=True):
                                            nova_posicao = st.text_input("Posi√ß√£o", value=pneu_row['posicao'])
                                            nova_marca = st.text_input("Marca", value=pneu_row['marca'])
                                            novo_modelo = st.text_input("Modelo", value=pneu_row['modelo'])
                                            novo_numero_fogo = st.text_input("N¬∫ de Fogo do Pneu", value=pneu_row.get('numero_fogo', ''))
                                            nova_data = st.date_input("Data de Instala√ß√£o", value=pd.to_datetime(pneu_row['data_instalacao']))
                                            novo_hod = st.number_input("Leitura na Instala√ß√£o", value=float(pneu_row['hodometro_instalacao']), format="%.2f")
                                            
                                            novas_obs = st.text_area("Observa√ß√µes", value=pneu_row['observacoes'], height=50)
                                            if st.form_submit_button("Salvar Altera√ß√µes"):
                                                try:
                                                    with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                        cur = conn.cursor()
                                                        cur.execute(
                                                            "UPDATE pneus_historico SET posicao=?, marca=?, modelo=?, numero_fogo=?, data_instalacao=?, hodometro_instalacao=?, observacoes=? WHERE id=?",
                                                            (nova_posicao, nova_marca, novo_modelo, novo_numero_fogo, nova_data.strftime("%Y-%m-%d"), novo_hod, novas_obs, pneu_row['id'])
                                                        )
                                                        conn.commit()
                                                    st.success("Pneu atualizado com sucesso!")
                                                    st.rerun()
                                                except Exception as e:
                                                    st.error(f"Erro ao editar pneu: {e}")
                                    
                                    # Funcionalidade de Sucateamento
                                    if pneu_row['status'] != 'Sucateado':
                                        with st.expander("üö´ Sucatear Pneu"):
                                            st.warning("‚ö†Ô∏è **ATEN√á√ÉO:** Ao sucatear um pneu, ele ser√° desvinculado da frota e n√£o aparecer√° mais nas consultas de pneus ativos.")
                                            
                                            with st.form("form_sucatear_pneu", clear_on_submit=True):
                                                causa_sucateamento = st.selectbox(
                                                    "Causa do Sucateamento",
                                                    options=[
                                                        "Desgaste excessivo",
                                                        "Furo irrepar√°vel",
                                                        "Rachadura na lateral",
                                                        "Deforma√ß√£o da carca√ßa",
                                                        "Vida √∫til esgotada",
                                                        "Acidente/Dano mec√¢nico",
                                                        "Problema de fabrica√ß√£o",
                                                        "Outros"
                                                    ],
                                                    help="Selecione a principal causa do sucateamento"
                                                )
                                                
                                                if causa_sucateamento == "Outros":
                                                    causa_sucateamento = st.text_input("Especifique a causa:", placeholder="Descreva a causa espec√≠fica")
                                                
                                                data_sucateamento = st.date_input("Data do Sucateamento", value=datetime.now().date())
                                                observacoes_sucateamento = st.text_area("Observa√ß√µes Adicionais", height=80, placeholder="Detalhes adicionais sobre o sucateamento...")
                                                
                                                if st.form_submit_button("üö´ Confirmar Sucateamento"):
                                                    try:
                                                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                            cur = conn.cursor()
                                                            
                                                            # Verificar se a coluna causa_sucateamento existe
                                                            cur.execute("PRAGMA table_info(pneus_historico)")
                                                            cols = [c[1] for c in cur.fetchall()]
                                                            if 'causa_sucateamento' not in cols:
                                                                cur.execute("ALTER TABLE pneus_historico ADD COLUMN causa_sucateamento TEXT")
                                                            if 'data_sucateamento' not in cols:
                                                                cur.execute("ALTER TABLE pneus_historico ADD COLUMN data_sucateamento TEXT")
                                                            
                                                            # Atualizar o pneu para sucateado
                                                            cur.execute("""
                                                                UPDATE pneus_historico 
                                                                SET status = 'Sucateado', 
                                                                    causa_sucateamento = ?,
                                                                    data_sucateamento = ?,
                                                                    observacoes = ?
                                                                WHERE id = ?
                                                            """, (causa_sucateamento, data_sucateamento.strftime("%Y-%m-%d"), observacoes_sucateamento, pneu_row['id']))
                                                            
                                                            conn.commit()
                                                            
                                                        st.success(f"‚úÖ Pneu sucateado com sucesso! Causa: {causa_sucateamento}")
                                                        st.info("‚ÑπÔ∏è O pneu foi desvinculado da frota e n√£o aparecer√° mais nas consultas de pneus ativos.")
                                                        st.rerun()
                                                        
                                                    except Exception as e:
                                                        st.error(f"‚ùå Erro ao sucatear pneu: {e}")
                                    
                                    if st.button("Excluir Pneu Selecionado", type="primary"):
                                        try:
                                            with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                                                cur = conn.cursor()
                                                cur.execute("DELETE FROM pneus_historico WHERE id=?", (pneu_row['id'],))
                                                conn.commit()
                                            st.success("Pneu exclu√≠do com sucesso!")
                                            st.rerun()
                                        except Exception as e:
                                            st.error(f"Erro ao excluir pneu: {e}")
                            else:
                                st.info("Nenhum registro de pneus para esta frota.")
                with sub_tab_lubrificantes:
                        st.subheader("Importar Lubrificantes por Planilha")
                        st.info("Colunas obrigat√≥rias: nome, tipo (graxa/√≥leo), viscosidade, quantidade_estoque, unidade, observacoes")
                        arquivo_lub = st.file_uploader("Selecione a planilha de lubrificantes", type=['xlsx'], key="upl_lub")
                        if arquivo_lub is not None:
                            try:
                                df_lub_import = pd.read_excel(arquivo_lub)
                                st.dataframe(df_lub_import.head())
                                if st.button("Confirmar e Inserir Lubrificantes", type="primary"):
                                    with st.spinner("Importando lubrificantes..."):
                                        inseridos, duplicados, msg = importar_lubrificantes_de_planilha(DB_PATH, arquivo_lub)
                                    if inseridos > 0:
                                        st.success(f"{msg}")
                                        st.rerun()
                                    else:
                                        st.error(msg)
                            except Exception as e:
                                st.error(f"Erro ao importar lubrificantes: {e}")

                        st.markdown("---")
                        st.subheader("Cadastrar Lubrificante Manualmente")
                        with st.form("form_add_lub", clear_on_submit=True):
                            nome = st.text_input("Nome")
                            tipo = st.selectbox("Tipo", ["√≥leo", "graxa"])
                            viscosidade = st.text_input("Viscosidade")
                            quantidade = st.number_input("Quantidade Inicial", min_value=0.0, format="%.2f")
                            unidade = st.selectbox("Unidade", ["L", "kg", "gal"])
                            obs = st.text_area("Observa√ß√µes")
                            if st.form_submit_button("Salvar Lubrificante"):
                                with sqlite3.connect(DB_PATH) as conn:
                                    cur = conn.cursor()
                                    cur.execute("PRAGMA table_info(lubrificantes)")
                                    cols = [c[1] for c in cur.fetchall()]
                                    if 'tipo' not in cols:
                                        cur.execute("ALTER TABLE lubrificantes ADD COLUMN tipo TEXT DEFAULT '√≥leo'")
                                    cur.execute(
                                        "INSERT INTO lubrificantes (nome, tipo, viscosidade, quantidade_estoque, unidade, observacoes) VALUES (?, ?, ?, ?, ?, ?)",
                                        (nome, tipo, viscosidade, quantidade, unidade, obs)
                                    )
                                    conn.commit()
                                st.success("Lubrificante cadastrado!")
                                st.rerun()

                with sub_tab_componentes:
                    st.subheader("Importar Componentes por Planilha")
                    st.info(
                        "**Colunas obrigat√≥rias:** `nome_componente`, `intervalo_padrao`\n"
                        "**Colunas opcionais:** `lubrificante_nome`, `capacidade_litros`\n\n"
                        "üí° **Dicas:**\n"
                        "‚Ä¢ Se o lubrificante n√£o existir, ser√° criado automaticamente\n"
                        "‚Ä¢ Componentes duplicados na mesma classe ser√£o ignorados\n"
                        "‚Ä¢ Componentes com mesmo nome em classes diferentes ser√£o adicionados normalmente\n"
                        "‚Ä¢ O tipo de manuten√ß√£o (Troca/Remonta) ser√° definido manualmente ao registrar a manuten√ß√£o\n"
                        "‚Ä¢ A capacidade em litros ajuda no controle de estoque"
                    )
                    
                    # Sele√ß√£o da classe operacional
                    classes_operacionais = sorted([c for c in df_frotas['Classe_Operacional'].unique() if pd.notna(c) and str(c).strip()])
                    classe_selecionada = st.selectbox("Classe Operacional para importa√ß√£o", options=classes_operacionais, 
                                                    help="Selecione a classe onde os componentes ser√£o importados")
                    
                    arquivo_componentes = st.file_uploader("Selecione a planilha de componentes", type=['xlsx'], key="upl_componentes")
                    if arquivo_componentes is not None:
                        try:
                            df_comp_import = pd.read_excel(arquivo_componentes)
                            st.write("**Pr√©-visualiza√ß√£o dos dados:**")
                            st.dataframe(df_comp_import.head())
                            
                            if st.button("Confirmar e Inserir Componentes", type="primary"):
                                with st.spinner("Importando componentes..."):
                                    # Garantir que as tabelas existem
                                    ensure_lubrificantes_schema()
                                    
                                    # Importar componentes
                                    inseridos, duplicados, lubrificantes_criados, msg = importar_componentes_de_planilha(
                                        DB_PATH, arquivo_componentes, classe_selecionada
                                    )
                                
                                if inseridos > 0:
                                    msg_sucesso = f"‚úÖ **{inseridos}** componentes importados com sucesso!"
                                    if duplicados > 0:
                                        msg_sucesso += f"\n‚ö†Ô∏è **{duplicados}** componentes duplicados ignorados"
                                    if lubrificantes_criados > 0:
                                        msg_sucesso += f"\nüõ¢Ô∏è **{lubrificantes_criados}** lubrificantes criados automaticamente"
                                    
                                    st.success(msg_sucesso)
                                    st.info(f"üìã **Detalhes:** {msg}")
                                    rerun_keep_tab("üì§ Importar Dados")
                                else:
                                    st.error(f"‚ùå Erro na importa√ß√£o: {msg}")
                        except Exception as e:
                            st.error(f"Erro ao ler planilha: {e}")
                    
                    # Exemplo de planilha
                    with st.expander("üìã Exemplo de Planilha de Componentes", expanded=False):
                        st.write("**Estrutura recomendada da planilha:**")
                        
                        # Criar DataFrame de exemplo
                        exemplo_data = {
                            'nome_componente': ['√ìleo do Motor', 'Filtro de Ar', 'Filtro de √ìleo', 'Correia Dentada'],
                            'intervalo_padrao': [5000, 10000, 5000, 80000],
                            'lubrificante_nome': ['√ìleo 15W40', 'Sem lubrificante', '√ìleo 15W40', 'Sem lubrificante'],
                            'capacidade_litros': [15.0, 0.0, 0.5, 0.0]
                        }
                        df_exemplo = pd.DataFrame(exemplo_data)
                        
                        st.dataframe(df_exemplo, use_container_width=True)
                        
                        st.write("**Colunas aceitas:**")
                        st.markdown("""
                        - **nome_componente** (obrigat√≥rio): Nome do componente
                        - **componente**: Alternativa para nome_componente
                        - **intervalo_padrao** (obrigat√≥rio): Intervalo em km/horas
                        - **intervalo**: Alternativa para intervalo_padrao
                        - **lubrificante_nome** (opcional): Nome do lubrificante associado
                        - **lubrificante**: Alternativa para lubrificante_nome
                        - **capacidade_litros** (opcional): Capacidade do componente em litros
                        - **capacidade**: Alternativa para capacidade_litros
                        """)
                        
                        # Bot√£o para download do exemplo
                        csv_exemplo = df_exemplo.to_csv(index=False)
                        st.download_button(
                            label="üì• Baixar Planilha de Exemplo",
                            data=csv_exemplo,
                            file_name="exemplo_componentes.csv",
                            mime="text/csv"
                        )

                # ============================================================================
                # NOVA ABA: AN√ÅLISE DE SUCATEAMENTO DE PNEUS
                # ============================================================================
                
                with sub_tab_sucateamento:
                    st.header("üìä An√°lise de Sucateamento de Pneus")
                    st.info("üìà Esta aba fornece an√°lises detalhadas sobre as causas de sucateamento e perda de pneus para otimizar a gest√£o da frota.")
                    
                    # Estat√≠sticas gerais
                    col1_stats, col2_stats, col3_stats, col4_stats = st.columns(4)
                    
                    try:
                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                            # Total de pneus
                            total_pneus = pd.read_sql_query("SELECT COUNT(*) as total FROM pneus_historico", conn).iloc[0]['total']
                            
                            # Pneus ativos
                            pneus_ativos = pd.read_sql_query("SELECT COUNT(*) as ativos FROM pneus_historico WHERE status != 'Sucateado'", conn).iloc[0]['ativos']
                            
                            # Pneus sucateados
                            pneus_sucateados = pd.read_sql_query("SELECT COUNT(*) as sucateados FROM pneus_historico WHERE status = 'Sucateado'", conn).iloc[0]['sucateados']
                            
                            # Taxa de sucateamento
                            taxa_sucateamento = (pneus_sucateados / total_pneus * 100) if total_pneus > 0 else 0
                            
                    except Exception as e:
                        total_pneus = pneus_ativos = pneus_sucateados = taxa_sucateamento = 0
                        st.error(f"Erro ao buscar estat√≠sticas: {e}")
                    
                    with col1_stats:
                        st.metric("Total de Pneus", total_pneus)
                    
                    with col2_stats:
                        st.metric("Pneus Ativos", pneus_ativos)
                    
                    with col3_stats:
                        st.metric("Pneus Sucateados", pneus_sucateados)
                    
                    with col4_stats:
                        st.metric("Taxa de Sucateamento", f"{taxa_sucateamento:.1f}%")
                    
                    st.markdown("---")
                    
                    # An√°lise por causa de sucateamento
                    st.subheader("üîç An√°lise por Causa de Sucateamento")
                    
                    try:
                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                            # Verificar se a coluna existe
                            cur = conn.cursor()
                            cur.execute("PRAGMA table_info(pneus_historico)")
                            cols = [c[1] for c in cur.fetchall()]
                            
                            if 'causa_sucateamento' in cols:
                                # Buscar causas de sucateamento
                                df_causas = pd.read_sql_query("""
                                    SELECT 
                                        causa_sucateamento,
                                        COUNT(*) as quantidade,
                                        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM pneus_historico WHERE status = 'Sucateado'), 2) as percentual
                                    FROM pneus_historico 
                                    WHERE status = 'Sucateado' 
                                    AND causa_sucateamento IS NOT NULL 
                                    AND causa_sucateamento != ''
                                    GROUP BY causa_sucateamento 
                                    ORDER BY quantidade DESC
                                """, conn)
                                
                                if not df_causas.empty:
                                    # Gr√°fico de pizza das causas
                                    fig_causas = px.pie(
                                        df_causas, 
                                        values='quantidade', 
                                        names='causa_sucateamento',
                                        title='Distribui√ß√£o das Causas de Sucateamento',
                                        color_discrete_sequence=px.colors.qualitative.Set3
                                    )
                                    fig_causas.update_traces(textposition='inside', textinfo='percent+label')
                                    st.plotly_chart(fig_causas, use_container_width=True)
                                    
                                    # Tabela detalhada
                                    st.subheader("üìã Detalhamento por Causa")
                                    st.dataframe(
                                        df_causas,
                                        column_config={
                                            "causa_sucateamento": "Causa",
                                            "quantidade": "Quantidade",
                                            "percentual": st.column_config.NumberColumn("Percentual (%)", format="%.1f%%")
                                        },
                                        use_container_width=True
                                    )
                                    
                                    # Download dos dados
                                    csv_causas = df_causas.to_csv(index=False, sep=';', decimal=',')
                                    st.download_button(
                                        label="üì• Baixar Relat√≥rio de Causas",
                                        data=csv_causas,
                                        file_name=f"causas_sucateamento_{datetime.now().strftime('%Y%m%d')}.csv",
                                        mime="text/csv"
                                    )
                                else:
                                    st.info("‚ÑπÔ∏è Nenhum pneu sucateado com causa registrada encontrado.")
                            else:
                                st.warning("‚ö†Ô∏è A coluna 'causa_sucateamento' ainda n√£o foi criada. Sucateie alguns pneus primeiro para gerar as an√°lises.")
                    
                    except Exception as e:
                        st.error(f"Erro ao analisar causas de sucateamento: {e}")
                    
                    st.markdown("---")
                    
                    # Lista detalhada de pneus sucateados
                    st.subheader("üìã Lista Detalhada de Pneus Sucateados")
                    
                    try:
                        with sqlite3.connect(DB_PATH, check_same_thread=False) as conn:
                            # Verificar se as colunas existem
                            cur = conn.cursor()
                            cur.execute("PRAGMA table_info(pneus_historico)")
                            cols = [c[1] for c in cur.fetchall()]
                            
                            if 'causa_sucateamento' in cols and 'data_sucateamento' in cols:
                                df_sucateados = pd.read_sql_query("""
                                    SELECT 
                                        id,
                                        Cod_Equip,
                                        posicao,
                                        marca,
                                        modelo,
                                        numero_fogo,
                                        data_instalacao,
                                        data_sucateamento,
                                        causa_sucateamento,
                                        observacoes
                                    FROM pneus_historico
                                    WHERE status = 'Sucateado'
                                    ORDER BY data_sucateamento DESC, Cod_Equip, posicao
                                """, conn)
                                
                                if not df_sucateados.empty:
                                    # Filtros
                                    col_filtro1, col_filtro2 = st.columns(2)
                                    
                                    with col_filtro1:
                                        causas_filtro = ['Todas'] + sorted(df_sucateados['causa_sucateamento'].dropna().unique().tolist())
                                        causa_selecionada = st.selectbox("Filtrar por Causa", options=causas_filtro)
                                    
                                    with col_filtro2:
                                        frotas_filtro = ['Todas'] + sorted(df_sucateados['Cod_Equip'].dropna().unique().tolist())
                                        frota_selecionada = st.selectbox("Filtrar por Frota", options=frotas_filtro)
                                    
                                    # Aplicar filtros
                                    df_filtrado = df_sucateados.copy()
                                    
                                    if causa_selecionada != 'Todas':
                                        df_filtrado = df_filtrado[df_filtrado['causa_sucateamento'] == causa_selecionada]
                                    
                                    if frota_selecionada != 'Todas':
                                        df_filtrado = df_filtrado[df_filtrado['Cod_Equip'] == frota_selecionada]
                                    
                                    # Exibir dados filtrados
                                    st.dataframe(
                                        df_filtrado,
                                        column_config={
                                            "id": "ID",
                                            "Cod_Equip": "C√≥d. Frota",
                                            "posicao": "Posi√ß√£o",
                                            "marca": "Marca",
                                            "modelo": "Modelo",
                                            "numero_fogo": "N¬∫ Fogo",
                                            "data_instalacao": "Data Instala√ß√£o",
                                            "data_sucateamento": "Data Sucateamento",
                                            "causa_sucateamento": "Causa",
                                            "observacoes": "Observa√ß√µes"
                                        },
                                        use_container_width=True
                                    )
                                    
                                    # Download dos dados filtrados
                                    csv_sucateados = df_filtrado.to_csv(index=False, sep=';', decimal=',')
                                    st.download_button(
                                        label="üì• Baixar Lista de Pneus Sucateados",
                                        data=csv_sucateados,
                                        file_name=f"pneus_sucateados_{datetime.now().strftime('%Y%m%d')}.csv",
                                        mime="text/csv"
                                    )
                                else:
                                    st.info("‚ÑπÔ∏è Nenhum pneu sucateado encontrado.")
                            else:
                                st.warning("‚ö†Ô∏è As colunas de sucateamento ainda n√£o foram criadas. Sucateie alguns pneus primeiro.")
                    
                    except Exception as e:
                        st.error(f"Erro ao buscar pneus sucateados: {e}")
                    
                    st.markdown("---")
                    
                    # Recomenda√ß√µes baseadas na an√°lise
                    st.subheader("üí° Recomenda√ß√µes e Insights")
                    
                    try:
                        if 'causa_sucateamento' in cols:
                            # Buscar a causa mais frequente
                            causa_mais_frequente = df_causas.iloc[0]['causa_sucateamento'] if not df_causas.empty else None
                            
                            if causa_mais_frequente:
                                st.info(f"üéØ **Causa mais frequente:** {causa_mais_frequente}")
                                
                                # Recomenda√ß√µes espec√≠ficas
                                if "Desgaste excessivo" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Revisar press√£o dos pneus e alinhamento da frota regularmente.")
                                elif "Furo irrepar√°vel" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Implementar inspe√ß√£o visual di√°ria e treinamento da equipe.")
                                elif "Rachadura na lateral" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Verificar condi√ß√µes das estradas e velocidade de opera√ß√£o.")
                                elif "Deforma√ß√£o da carca√ßa" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Revisar sobrecarga e condi√ß√µes de opera√ß√£o.")
                                elif "Vida √∫til esgotada" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Otimizar rota√ß√£o de pneus e monitorar desgaste.")
                                elif "Acidente/Dano mec√¢nico" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Refor√ßar treinamento de operadores e manuten√ß√£o preventiva.")
                                elif "Problema de fabrica√ß√£o" in causa_mais_frequente:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Revisar fornecedores e qualidade dos pneus.")
                                else:
                                    st.success("‚úÖ **Recomenda√ß√£o:** Analisar padr√µes espec√≠ficos para esta causa.")
                        
                        # Estat√≠sticas de tend√™ncia
                        if taxa_sucateamento > 20:
                            st.warning("‚ö†Ô∏è **Alerta:** Taxa de sucateamento alta. Considere revisar pol√≠ticas de manuten√ß√£o.")
                        elif taxa_sucateamento < 10:
                            st.success("‚úÖ **Excelente:** Taxa de sucateamento baixa. Mantenha as boas pr√°ticas!")
                        
                    except Exception as e:
                        st.error(f"Erro ao gerar recomenda√ß√µes: {e}")
        if tab_gerir_checklists is not None:
            with tab_gerir_checklists:
                    st.header("‚úÖ Gerir Checklists")
                    
                    # Criar abas para organizar melhor as funcionalidades
                    tab_config, tab_historico = st.tabs(["‚öôÔ∏è Configura√ß√£o", "üóëÔ∏è Hist√≥rico"])
                    
                    if tab_config is not None:
                        with tab_config:
                            col_regras, col_itens = st.columns(2)
                        with col_regras:

                            st.subheader("üìã Regras de Checklist")
                            regras_df = get_checklist_rules()
                            if not regras_df.empty:
                                st.dataframe(regras_df)
                            else:
                                st.info("Nenhuma regra cadastrada.")

                            with st.form("form_add_regra", clear_on_submit=True):
                                id_regra_edit = st.selectbox(
                                    "Editar Regra (ou deixe em branco para criar nova)",
                                    options=[""] + (regras_df['id_regra'].astype(str).tolist() if not regras_df.empty else [""])
                                )
                                classe_op = st.text_input("Classe Operacional")
                                titulo = st.text_input("T√≠tulo do Checklist")
                                frequencia = st.selectbox("Frequ√™ncia", ["Di√°rio", "Dias Pares", "Dias √çmpares"])
                                turno = st.selectbox("Turno", ["Manh√£", "Tarde", "Noite"]) 

                                if st.form_submit_button("Salvar Regra"):
                                    if id_regra_edit:
                                        ok, msg = edit_checklist_rule(int(id_regra_edit), classe_op, titulo, turno, frequencia)
                                    else:
                                        ok, msg = add_checklist_rule(classe_op, titulo, turno, frequencia)
                                    if ok:
                                        st.success(str(msg))
                                    else:
                                        st.error(str(msg))
                                    rerun_keep_tab("‚úÖ Gerir Checklists")

                            if not regras_df.empty:
                                regra_del = st.selectbox("Selecione a Regra para excluir", regras_df['id_regra'])
                                if st.button("Excluir Regra"):
                                    ok, msg = delete_checklist_rule(regra_del)
                                    if ok:
                                        st.success(str(msg))
                                    else:
                                        st.error(str(msg))
                                    rerun_keep_tab("‚úÖ Gerir Checklists")

            with col_itens:
                    st.subheader("üìù Itens de Checklist")
                    if regras_df.empty:
                        st.warning("Cadastre pelo menos uma regra para poder adicionar itens.")
                    else:
                        regra_sel = st.selectbox("Selecione uma Regra para gerenciar itens", regras_df['id_regra'])
                        itens_df = get_checklist_items(regra_sel)
                        if not itens_df.empty:
                            st.dataframe(itens_df)
                        else:
                            st.info("Nenhum item para esta regra.")

                        with st.form("form_add_item", clear_on_submit=True):
                            id_item_edit = st.selectbox(
                                "Editar Item (ou deixe em branco para criar novo)",
                                options=[""] + itens_df['id_item'].astype(str).tolist() if not itens_df.empty else [""]
                            )
                            nome_item = st.text_input("Nome do Item")
                            if st.form_submit_button("Salvar Item"):
                                if id_item_edit:
                                    ok, msg = edit_checklist_item(int(id_item_edit), nome_item)
                                else:
                                    ok, msg = add_checklist_item(regra_sel, nome_item)
                                if ok:
                                    st.success(str(msg))
                                else:
                                    st.error(str(msg))
                                rerun_keep_tab("‚úÖ Gerir Checklists")

                        if not itens_df.empty:
                            item_del = st.selectbox("Selecione o Item para excluir", itens_df['id_item'])
                            if st.button("Excluir Item"):
                                ok, msg = delete_checklist_item(item_del)
                                if ok:
                                    st.success(str(msg))
                                else:
                                    st.error(str(msg))
                                rerun_keep_tab("‚úÖ Gerir Checklists")
            
            with tab_historico:
                st.subheader("üóëÔ∏è Excluir Checklists Lan√ßados")
                st.info("Esta se√ß√£o permite excluir checklists que j√° foram preenchidos e salvos no hist√≥rico.")
                
                # Carregar dados do hist√≥rico
                df_historico = df_checklist_historico.copy()
                
                if df_historico.empty:
                    st.warning("Nenhum checklist foi preenchido ainda.")
                else:
                    # Adicionar informa√ß√µes do equipamento ao hist√≥rico
                    df_historico = df_historico.merge(
                        df_frotas[['Cod_Equip', 'DESCRICAO_EQUIPAMENTO']], 
                        on='Cod_Equip', 
                        how='left'
                    )
                    
                    # Criar labels para sele√ß√£o
                    df_historico['label_exclusao'] = (
                        df_historico['data_preenchimento'] + " | " +
                        df_historico['Cod_Equip'].astype(str) + " - " +
                        df_historico['DESCRICAO_EQUIPAMENTO'].fillna('N/A') + " | " +
                        df_historico['titulo_checklist'] + " | " +
                        df_historico['turno'] + " | " +
                        "Status: " + df_historico['status_geral']
                    )
                    
                    # Ordenar por data mais recente
                    df_historico = df_historico.sort_values(by='data_preenchimento', ascending=False)
                    
                    # Sele√ß√£o do checklist para excluir
                    checklist_selecionado = st.selectbox(
                        "Selecione o checklist para excluir:",
                        options=df_historico['label_exclusao'],
                        key="checklist_exclusao"
                    )
                    
                    if checklist_selecionado:
                        # Encontrar os detalhes do checklist selecionado
                        checklist_detalhes = df_historico[df_historico['label_exclusao'] == checklist_selecionado].iloc[0]
                        
                        # Mostrar detalhes do checklist selecionado
                        st.warning("**Aten√ß√£o:** Voc√™ est√° prestes a excluir o seguinte checklist. Esta a√ß√£o n√£o pode ser desfeita.")
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            st.write(f"**Data:** {checklist_detalhes['data_preenchimento']}")
                            st.write(f"**Equipamento:** {checklist_detalhes['Cod_Equip']} - {checklist_detalhes['DESCRICAO_EQUIPAMENTO']}")
                        with col2:
                            st.write(f"**T√≠tulo:** {checklist_detalhes['titulo_checklist']}")
                            st.write(f"**Turno:** {checklist_detalhes['turno']}")
                            st.write(f"**Status:** {checklist_detalhes['status_geral']}")
                        
                        # Bot√£o de confirma√ß√£o
                        if st.button("üóëÔ∏è Confirmar Exclus√£o", type="primary"):
                            # Debug: mostrar os valores que ser√£o usados
                            st.write(f"**Debug:** Tentando excluir checklist com:")
                            st.write(f"- Cod_Equip: {checklist_detalhes['Cod_Equip']}")
                            st.write(f"- T√≠tulo: {checklist_detalhes['titulo_checklist']}")
                            st.write(f"- Data: {checklist_detalhes['data_preenchimento']}")
                            st.write(f"- Turno: {checklist_detalhes['turno']}")
                            
                            # Verificar status do banco antes da exclus√£o
                            sync_success, sync_msg = force_database_sync()
                            if sync_success:
                                st.info(f"Status do banco: {sync_msg}")
                            
                            success, message = delete_checklist_history(
                                checklist_detalhes['Cod_Equip'],
                                checklist_detalhes['titulo_checklist'],
                                checklist_detalhes['data_preenchimento'],
                                checklist_detalhes['turno']
                            )
                            if success:
                                st.success(message)
                                # Invalidar cache para atualizar contadores
                                force_cache_clear()
                            else:
                                st.error(message)
        
        # Aba de Backup para persist√™ncia no Streamlit Cloud
        if tab_backup is not None:
            with tab_backup:
                st.header("üíæ Backup e Restaura√ß√£o")
                st.info("Esta se√ß√£o permite gerenciar backups dos dados para garantir persist√™ncia no Streamlit Cloud.")
                
                col_backup, col_restore = st.columns(2)
                
                with col_backup:
                    st.subheader("üì§ Criar Backup")
                    st.write("Cria um backup completo dos dados atuais e salva na sess√£o do Streamlit.")
                    
                    if st.button("üíæ Criar Backup", type="primary"):
                        with st.spinner("Criando backup..."):
                            success, message = save_backup_to_session_state()
                            if success:
                                st.success(message)
                                st.info(f"Backup criado em: {st.session_state.get('backup_timestamp', 'N/A')}")
                            else:
                                st.error(message)
                    
                    # Mostrar status do backup atual
                    if 'database_backup' in st.session_state:
                        st.success("‚úÖ Backup dispon√≠vel na sess√£o")
                        st.info(f"√öltimo backup: {st.session_state.get('backup_timestamp', 'N/A')}")
                        
                        # Bot√£o para download do backup
                        backup_b64 = st.session_state['database_backup']
                        backup_bytes = base64.b64decode(backup_b64)
                        
                        st.download_button(
                            label="üì• Download do Backup",
                            data=backup_bytes,
                            file_name=f"backup_database_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                            mime="application/json"
                        )
                    else:
                        st.warning("‚ö†Ô∏è Nenhum backup dispon√≠vel")
                
                with col_restore:
                    st.subheader("üì• Restaurar Backup")
                    st.write("Restaura dados de um backup salvo na sess√£o.")
                    
                    if 'database_backup' in st.session_state:
                        if st.button("üîÑ Restaurar Backup", type="secondary"):
                            with st.spinner("Restaurando backup..."):
                                success, message = restore_backup_from_session_state()
                                if success:
                                    st.success(message)
                                    st.info("Os dados foram restaurados. A aplica√ß√£o ser√° recarregada.")
                                else:
                                    st.error(message)
                    else:
                        st.info("Crie um backup primeiro para poder restaurar.")
                
                # Se√ß√£o de informa√ß√µes sobre persist√™ncia
                st.markdown("---")
                st.subheader("‚ÑπÔ∏è Sobre Persist√™ncia no Streamlit Cloud")
                
                st.info("""
                **Por que os dados voltam ap√≥s reiniciar?**
                
                O Streamlit Cloud recria o ambiente a cada deploy ou reinicializa√ß√£o, 
                perdendo todos os dados do banco SQLite. Para resolver isso:
                
                1. **Crie um backup** sempre que fizer altera√ß√µes importantes
                2. **O backup √© salvo na sess√£o** e persiste durante a navega√ß√£o
                3. **Ap√≥s reiniciar**, restaure o backup para recuperar os dados
                
                **Dica:** Fa√ßa backup antes de sair da aplica√ß√£o!
                """)
                
                # Backup autom√°tico ap√≥s opera√ß√µes importantes
                if st.button("üîÑ Backup Autom√°tico", type="secondary"):
                    with st.spinner("Verificando e criando backup autom√°tico..."):
                        # Verificar se h√° dados no banco
                        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
                        cursor = conn.cursor()
                        cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
                        num_tables = cursor.fetchone()[0]
                        conn.close()
                        
                        if num_tables > 0:
                            success, message = save_backup_to_session_state()
                            if success:
                                st.success(f"Backup autom√°tico criado: {message}")
                            else:
                                st.error(f"Erro no backup autom√°tico: {message}")
                        else:
                            st.warning("Nenhuma tabela encontrada no banco de dados.")
        
        # Aba de Sa√∫de dos Dados
        if tab_saude is not None:
            with tab_saude:
                st.header("‚öïÔ∏è Sa√∫de dos Dados")
                st.info("Esta se√ß√£o permite verificar a integridade e qualidade dos dados da aplica√ß√£o.")
                
                # Verifica√ß√£o de integridade do banco
                st.subheader("üîç Verifica√ß√£o de Integridade do Banco")
                
                if st.button("üîç Verificar Integridade", type="primary"):
                    with st.spinner("Verificando integridade dos dados..."):
                        try:
                            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
                            cursor = conn.cursor()
                            
                            # Verificar tabelas existentes
                            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                            tabelas = [row[0] for row in cursor.fetchall()]
                            
                            # Verificar integridade de cada tabela
                            resultados_integridade = []
                            
                            for tabela in tabelas:
                                try:
                                    # Verificar se a tabela pode ser lida
                                    cursor.execute(f"SELECT COUNT(*) FROM {tabela}")
                                    count = cursor.fetchone()[0]
                                    
                                    # Verificar estrutura da tabela
                                    cursor.execute(f"PRAGMA table_info({tabela})")
                                    colunas = cursor.fetchall()
                                    
                                    resultados_integridade.append({
                                        'tabela': tabela,
                                        'registros': count,
                                        'colunas': len(colunas),
                                        'status': '‚úÖ OK'
                                    })
                                except Exception as e:
                                    resultados_integridade.append({
                                        'tabela': tabela,
                                        'registros': 0,
                                        'colunas': 0,
                                        'status': f'‚ùå Erro: {str(e)}'
                                    })
                            
                            conn.close()
                            
                            # Exibir resultados
                            st.success("‚úÖ Verifica√ß√£o conclu√≠da!")
                            
                            # Criar DataFrame com resultados
                            df_integridade = pd.DataFrame(resultados_integridade)
                            st.dataframe(df_integridade, use_container_width=True)
                            
                            # Resumo
                            total_tabelas = len(resultados_integridade)
                            tabelas_ok = len([r for r in resultados_integridade if '‚úÖ' in r['status']])
                            tabelas_erro = total_tabelas - tabelas_ok
                            
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Total de Tabelas", total_tabelas)
                            with col2:
                                st.metric("Tabelas OK", tabelas_ok)
                            with col3:
                                st.metric("Tabelas com Erro", tabelas_erro)
                            
                        except Exception as e:
                            st.error(f"Erro ao verificar integridade: {e}")
                
                # Verifica√ß√£o de dados espec√≠ficos
                st.markdown("---")
                st.subheader("üìä Verifica√ß√£o de Dados Espec√≠ficos")
                
                col_verif1, col_verif2 = st.columns(2)
                
                with col_verif1:
                    st.write("**Verifica√ß√£o de Frotas:**")
                    if not df_frotas.empty:
                        frotas_ativas = df_frotas[df_frotas['ATIVO'] == 'ATIVO'].shape[0]
                        frotas_inativas = df_frotas[df_frotas['ATIVO'] != 'ATIVO'].shape[0]
                        
                        st.metric("Frotas Ativas", frotas_ativas)
                        st.metric("Frotas Inativas", frotas_inativas)
                        
                        if frotas_inativas > 0:
                            st.warning(f"‚ö†Ô∏è {frotas_inativas} frotas inativas encontradas")
                    else:
                        st.error("‚ùå Nenhuma frota cadastrada")
                
                with col_verif2:
                    st.write("**Verifica√ß√£o de Abastecimentos:**")
                    if not df.empty:
                        total_abastecimentos = df.shape[0]
                        abastecimentos_sem_data = df[df['Data'].isna()].shape[0]
                        
                        st.metric("Total Abastecimentos", total_abastecimentos)
                        st.metric("Sem Data", abastecimentos_sem_data)
                        
                        if abastecimentos_sem_data > 0:
                            st.warning(f"‚ö†Ô∏è {abastecimentos_sem_data} abastecimentos sem data")
                    else:
                        st.error("‚ùå Nenhum abastecimento registrado")
                
                # Verifica√ß√£o de consist√™ncia
                st.markdown("---")
                st.subheader("üîó Verifica√ß√£o de Consist√™ncia")
                
                if st.button("üîó Verificar Consist√™ncia", type="secondary"):
                    with st.spinner("Verificando consist√™ncia dos dados..."):
                        inconsistencias = []
                        
                        # Verificar se h√° abastecimentos para frotas inexistentes
                        if not df.empty and not df_frotas.empty:
                            codigos_abastecimento = set(df['Cod_Equip'].unique())
                            codigos_frota = set(df_frotas['Cod_Equip'].unique())
                            
                            codigos_orfas = codigos_abastecimento - codigos_frota
                            if codigos_orfas:
                                inconsistencias.append(f"‚ùå {len(codigos_orfas)} abastecimentos para frotas inexistentes")
                        
                        # Verificar se h√° componentes para classes inexistentes
                        if 'df_comp_regras' in locals() and not df_comp_regras.empty and not df_frotas.empty:
                            classes_componentes = set(df_comp_regras['classe_operacional'].unique())
                            classes_frota = set(df_frotas['Classe_Operacional'].unique())
                            
                            classes_orfas = classes_componentes - classes_frota
                            if classes_orfas:
                                inconsistencias.append(f"‚ùå {len(classes_orfas)} componentes para classes inexistentes")
                        
                        if inconsistencias:
                            st.error("‚ö†Ô∏è Inconsist√™ncias encontradas:")
                            for inc in inconsistencias:
                                st.write(inc)
                        else:
                            st.success("‚úÖ Nenhuma inconsist√™ncia encontrada!")
        
        # Aba de Gerir Utilizadores
        if tab_gerir_users is not None:
            with tab_gerir_users:
                st.header("üë§ Gerir Utilizadores")
                st.info("Esta se√ß√£o permite gerenciar usu√°rios e suas permiss√µes na aplica√ß√£o.")
                
                # Verificar se existe sistema de usu√°rios
                if 'users' not in st.session_state:
                    st.session_state['users'] = {}
                
                # Lista de usu√°rios existentes
                st.subheader("üìã Usu√°rios Cadastrados")
                
                if st.session_state['users']:
                    df_users = pd.DataFrame(list(st.session_state['users'].items()), 
                                          columns=['Username', 'Role'])
                    st.dataframe(df_users, use_container_width=True)
                else:
                    st.info("Nenhum usu√°rio cadastrado al√©m do administrador padr√£o.")
                
                # Adicionar novo usu√°rio
                st.markdown("---")
                st.subheader("‚ûï Adicionar Novo Usu√°rio")
                
                with st.form("form_add_user", clear_on_submit=True):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        novo_username = st.text_input("Nome de usu√°rio", key="new_user_username")
                        nova_senha = st.text_input("Senha", type="password", key="new_user_password")
                    
                    with col2:
                        novo_role = st.selectbox("Tipo de usu√°rio", ["user", "admin"], key="new_user_role")
                        novo_email = st.text_input("Email (opcional)", key="new_user_email")
                    
                    submitted_user = st.form_submit_button("‚ûï Adicionar Usu√°rio", type="primary")
                    if submitted_user:
                        if novo_username and nova_senha:
                            if novo_username not in st.session_state['users']:
                                # Em uma aplica√ß√£o real, a senha seria criptografada
                                st.session_state['users'][novo_username] = {
                                    'role': novo_role,
                                    'password': nova_senha,  # Em produ√ß√£o, usar hash
                                    'email': novo_email,
                                    'created_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                }
                                st.success(f"‚úÖ Usu√°rio '{novo_username}' criado com sucesso!")
                                st.rerun()
                            else:
                                st.error("‚ùå Nome de usu√°rio j√° existe!")
                        else:
                            st.warning("‚ö†Ô∏è Preencha todos os campos obrigat√≥rios!")
                
                # Gerenciar usu√°rios existentes
                if st.session_state['users']:
                    st.markdown("---")
                    st.subheader("‚úèÔ∏è Gerenciar Usu√°rios Existentes")
                    
                    usuarios_lista = list(st.session_state['users'].keys())
                    usuario_selecionado = st.selectbox("Selecionar usu√°rio para gerenciar:", usuarios_lista)
                    
                    if usuario_selecionado:
                        user_data = st.session_state['users'][usuario_selecionado]
                        
                        col_info, col_actions = st.columns([2, 1])
                        
                        with col_info:
                            st.write(f"**Usu√°rio:** {usuario_selecionado}")
                            st.write(f"**Tipo:** {user_data['role']}")
                            st.write(f"**Email:** {user_data.get('email', 'N√£o informado')}")
                            st.write(f"**Criado em:** {user_data.get('created_at', 'N/A')}")
                        
                        with col_actions:
                            if st.button("üóëÔ∏è Excluir Usu√°rio", type="secondary"):
                                if usuario_selecionado != 'admin':  # Proteger admin
                                    del st.session_state['users'][usuario_selecionado]
                                    st.success(f"‚úÖ Usu√°rio '{usuario_selecionado}' exclu√≠do!")
                                    st.rerun()
                                else:
                                    st.error("‚ùå N√£o √© poss√≠vel excluir o usu√°rio administrador!")
                        
                        # Alterar senha
                        st.markdown("---")
                        st.subheader("üîê Alterar Senha")
                        
                        with st.form("form_change_password", clear_on_submit=True):
                            nova_senha_alt = st.text_input("Nova senha", type="password", key="change_password")
                            confirmar_senha = st.text_input("Confirmar nova senha", type="password", key="confirm_password")
                            
                            if st.form_submit_button("üîê Alterar Senha", type="primary"):
                                if nova_senha_alt == confirmar_senha:
                                    if nova_senha_alt:
                                        st.session_state['users'][usuario_selecionado]['password'] = nova_senha_alt
                                        st.success("‚úÖ Senha alterada com sucesso!")
                                        st.rerun()
                                    else:
                                        st.warning("‚ö†Ô∏è A nova senha n√£o pode estar vazia!")
                                else:
                                    st.error("‚ùå As senhas n√£o coincidem!")
                
                # Informa√ß√µes sobre o sistema de usu√°rios
                st.markdown("---")
                st.subheader("‚ÑπÔ∏è Sobre o Sistema de Usu√°rios")
                
                st.info("""
                **Como funciona:**
                
                - **Admin:** Acesso total a todas as funcionalidades
                - **User:** Acesso limitado (apenas p√°gina inicial)
                
                **Seguran√ßa:**
                
                ‚ö†Ô∏è **ATEN√á√ÉO:** Este √© um sistema b√°sico de usu√°rios para demonstra√ß√£o.
                Em produ√ß√£o, implemente:
                
                1. **Criptografia de senhas** (bcrypt, hashlib)
                2. **Autentica√ß√£o segura** (JWT, sessions)
                3. **Valida√ß√£o de entrada** robusta
                4. **Logs de auditoria** para a√ß√µes sens√≠veis
                5. **Rate limiting** para tentativas de login
                
                **Dica:** As senhas s√£o armazenadas em texto plano na sess√£o atual!
                """)
                        
if __name__ == "__main__":
    main()
